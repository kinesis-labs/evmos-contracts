{
  "language": "Solidity",
  "sources": {
    "contracts/AmplificationUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\r\nimport \"./SwapUtils.sol\";\r\n\r\n/**\r\n * @title AmplificationUtils library\r\n * @notice A library to calculate and ramp the A parameter of a given `SwapUtils.Swap` struct.\r\n * This library assumes the struct is fully validated.\r\n */\r\nlibrary AmplificationUtils {\r\n    using SafeMath for uint256;\r\n\r\n    event RampA(\r\n        uint256 oldA,\r\n        uint256 newA,\r\n        uint256 initialTime,\r\n        uint256 futureTime\r\n    );\r\n    event StopRampA(uint256 currentA, uint256 time);\r\n\r\n    // Constant values used in ramping A calculations\r\n    uint256 public constant A_PRECISION = 100;\r\n    uint256 public constant MAX_A = 10**6;\r\n    uint256 private constant MAX_A_CHANGE = 2;\r\n    uint256 private constant MIN_RAMP_TIME = 14 days;\r\n\r\n    /**\r\n     * @notice Return A, the amplification coefficient * n * (n - 1)\r\n     * @dev See the StableSwap paper for details\r\n     * @param self Swap struct to read from\r\n     * @return A parameter\r\n     */\r\n    function getA(SwapUtils.Swap storage self) external view returns (uint256) {\r\n        return _getAPrecise(self).div(A_PRECISION);\r\n    }\r\n\r\n    /**\r\n     * @notice Return A in its raw precision\r\n     * @dev See the StableSwap paper for details\r\n     * @param self Swap struct to read from\r\n     * @return A parameter in its raw precision form\r\n     */\r\n    function getAPrecise(SwapUtils.Swap storage self)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _getAPrecise(self);\r\n    }\r\n\r\n    /**\r\n     * @notice Return A in its raw precision\r\n     * @dev See the StableSwap paper for details\r\n     * @param self Swap struct to read from\r\n     * @return A parameter in its raw precision form\r\n     */\r\n    function _getAPrecise(SwapUtils.Swap storage self)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 t1 = self.futureATime; // time when ramp is finished\r\n        uint256 a1 = self.futureA; // final A value when ramp is finished\r\n\r\n        if (block.timestamp < t1) {\r\n            uint256 t0 = self.initialATime; // time when ramp is started\r\n            uint256 a0 = self.initialA; // initial A value when ramp is started\r\n            if (a1 > a0) {\r\n                // a0 + (a1 - a0) * (block.timestamp - t0) / (t1 - t0)\r\n                return\r\n                    a0.add(\r\n                        a1.sub(a0).mul(block.timestamp.sub(t0)).div(t1.sub(t0))\r\n                    );\r\n            } else {\r\n                // a0 - (a0 - a1) * (block.timestamp - t0) / (t1 - t0)\r\n                return\r\n                    a0.sub(\r\n                        a0.sub(a1).mul(block.timestamp.sub(t0)).div(t1.sub(t0))\r\n                    );\r\n            }\r\n        } else {\r\n            return a1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Start ramping up or down A parameter towards given futureA_ and futureTime_\r\n     * Checks if the change is too rapid, and commits the new A value only when it falls under\r\n     * the limit range.\r\n     * @param self Swap struct to update\r\n     * @param futureA_ the new A to ramp towards\r\n     * @param futureTime_ timestamp when the new A should be reached\r\n     */\r\n    function rampA(\r\n        SwapUtils.Swap storage self,\r\n        uint256 futureA_,\r\n        uint256 futureTime_\r\n    ) external {\r\n        require(\r\n            block.timestamp >= self.initialATime.add(1 days),\r\n            \"Wait 1 day before starting ramp\"\r\n        );\r\n        require(\r\n            futureTime_ >= block.timestamp.add(MIN_RAMP_TIME),\r\n            \"Insufficient ramp time\"\r\n        );\r\n        require(\r\n            futureA_ > 0 && futureA_ < MAX_A,\r\n            \"futureA_ must be > 0 and < MAX_A\"\r\n        );\r\n\r\n        uint256 initialAPrecise = _getAPrecise(self);\r\n        uint256 futureAPrecise = futureA_.mul(A_PRECISION);\r\n\r\n        if (futureAPrecise < initialAPrecise) {\r\n            require(\r\n                futureAPrecise.mul(MAX_A_CHANGE) >= initialAPrecise,\r\n                \"futureA_ is too small\"\r\n            );\r\n        } else {\r\n            require(\r\n                futureAPrecise <= initialAPrecise.mul(MAX_A_CHANGE),\r\n                \"futureA_ is too large\"\r\n            );\r\n        }\r\n\r\n        self.initialA = initialAPrecise;\r\n        self.futureA = futureAPrecise;\r\n        self.initialATime = block.timestamp;\r\n        self.futureATime = futureTime_;\r\n\r\n        emit RampA(\r\n            initialAPrecise,\r\n            futureAPrecise,\r\n            block.timestamp,\r\n            futureTime_\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Stops ramping A immediately. Once this function is called, rampA()\r\n     * cannot be called for another 24 hours\r\n     * @param self Swap struct to update\r\n     */\r\n    function stopRampA(SwapUtils.Swap storage self) external {\r\n        require(self.futureATime > block.timestamp, \"Ramp is already stopped\");\r\n\r\n        uint256 currentA = _getAPrecise(self);\r\n        self.initialA = currentA;\r\n        self.futureA = currentA;\r\n        self.initialATime = block.timestamp;\r\n        self.futureATime = block.timestamp;\r\n\r\n        emit StopRampA(currentA, block.timestamp);\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/SwapUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\r\nimport \"./AmplificationUtils.sol\";\r\nimport \"./LPToken.sol\";\r\nimport \"./MathUtils.sol\";\r\n\r\n/**\r\n * @title SwapUtils library\r\n * @notice A library to be used within Swap.sol. Contains functions responsible for custody and AMM functionalities.\r\n * @dev Contracts relying on this library must initialize SwapUtils.Swap struct then use this library\r\n * for SwapUtils.Swap struct. Note that this library contains both functions called by users and admins.\r\n * Admin functions should be protected within contracts using this library.\r\n */\r\nlibrary SwapUtils {\r\n    using SafeERC20 for IERC20;\r\n    using SafeMath for uint256;\r\n    using MathUtils for uint256;\r\n\r\n    /*** EVENTS ***/\r\n\r\n    event TokenSwap(\r\n        address indexed buyer,\r\n        uint256 tokensSold,\r\n        uint256 tokensBought,\r\n        uint128 soldId,\r\n        uint128 boughtId\r\n    );\r\n    event AddLiquidity(\r\n        address indexed provider,\r\n        uint256[] tokenAmounts,\r\n        uint256[] fees,\r\n        uint256 invariant,\r\n        uint256 lpTokenSupply\r\n    );\r\n    event RemoveLiquidity(\r\n        address indexed provider,\r\n        uint256[] tokenAmounts,\r\n        uint256 lpTokenSupply\r\n    );\r\n    event RemoveLiquidityOne(\r\n        address indexed provider,\r\n        uint256 lpTokenAmount,\r\n        uint256 lpTokenSupply,\r\n        uint256 boughtId,\r\n        uint256 tokensBought\r\n    );\r\n    event RemoveLiquidityImbalance(\r\n        address indexed provider,\r\n        uint256[] tokenAmounts,\r\n        uint256[] fees,\r\n        uint256 invariant,\r\n        uint256 lpTokenSupply\r\n    );\r\n    event NewAdminFee(uint256 newAdminFee);\r\n    event NewSwapFee(uint256 newSwapFee);\r\n\r\n    struct Swap {\r\n        // variables around the ramp management of A,\r\n        // the amplification coefficient * n * (n - 1)\r\n        // see https://www.curve.fi/stableswap-paper.pdf for details\r\n        uint256 initialA;\r\n        uint256 futureA;\r\n        uint256 initialATime;\r\n        uint256 futureATime;\r\n        // fee calculation\r\n        uint256 swapFee;\r\n        uint256 adminFee;\r\n        LPToken lpToken;\r\n        // contract references for all tokens being pooled\r\n        IERC20[] pooledTokens;\r\n        // multipliers for each pooled token's precision to get to POOL_PRECISION_DECIMALS\r\n        // for example, TBTC has 18 decimals, so the multiplier should be 1. WBTC\r\n        // has 8, so the multiplier should be 10 ** 18 / 10 ** 8 => 10 ** 10\r\n        uint256[] tokenPrecisionMultipliers;\r\n        // the pool balance of each token, in the token's precision\r\n        // the contract's actual token balance might differ\r\n        uint256[] balances;\r\n    }\r\n\r\n    // Struct storing variables used in calculations in the\r\n    // calculateWithdrawOneTokenDY function to avoid stack too deep errors\r\n    struct CalculateWithdrawOneTokenDYInfo {\r\n        uint256 d0;\r\n        uint256 d1;\r\n        uint256 newY;\r\n        uint256 feePerToken;\r\n        uint256 preciseA;\r\n    }\r\n\r\n    // Struct storing variables used in calculations in the\r\n    // {add,remove}Liquidity functions to avoid stack too deep errors\r\n    struct ManageLiquidityInfo {\r\n        uint256 d0;\r\n        uint256 d1;\r\n        uint256 d2;\r\n        uint256 preciseA;\r\n        LPToken lpToken;\r\n        uint256 totalSupply;\r\n        uint256[] balances;\r\n        uint256[] multipliers;\r\n    }\r\n\r\n    // the precision all pools tokens will be converted to\r\n    uint8 public constant POOL_PRECISION_DECIMALS = 18;\r\n\r\n    // the denominator used to calculate admin and LP fees. For example, an\r\n    // LP fee might be something like tradeAmount.mul(fee).div(FEE_DENOMINATOR)\r\n    uint256 private constant FEE_DENOMINATOR = 10**10;\r\n\r\n    // Max swap fee is 1% or 100bps of each swap\r\n    uint256 public constant MAX_SWAP_FEE = 10**8;\r\n\r\n    // Max adminFee is 100% of the swapFee\r\n    // adminFee does not add additional fee on top of swapFee\r\n    // Instead it takes a certain % of the swapFee. Therefore it has no impact on the\r\n    // users but only on the earnings of LPs\r\n    uint256 public constant MAX_ADMIN_FEE = 10**10;\r\n\r\n    // Constant value used as max loop limit\r\n    uint256 private constant MAX_LOOP_LIMIT = 256;\r\n\r\n    /*** VIEW & PURE FUNCTIONS ***/\r\n\r\n    function _getAPrecise(Swap storage self) internal view returns (uint256) {\r\n        return AmplificationUtils._getAPrecise(self);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the dy, the amount of selected token that user receives and\r\n     * the fee of withdrawing in one token\r\n     * @param tokenAmount the amount to withdraw in the pool's precision\r\n     * @param tokenIndex which token will be withdrawn\r\n     * @param self Swap struct to read from\r\n     * @return the amount of token user will receive\r\n     */\r\n    function calculateWithdrawOneToken(\r\n        Swap storage self,\r\n        uint256 tokenAmount,\r\n        uint8 tokenIndex\r\n    ) external view returns (uint256) {\r\n        (uint256 availableTokenAmount, ) = _calculateWithdrawOneToken(\r\n            self,\r\n            tokenAmount,\r\n            tokenIndex,\r\n            self.lpToken.totalSupply()\r\n        );\r\n        return availableTokenAmount;\r\n    }\r\n\r\n    function _calculateWithdrawOneToken(\r\n        Swap storage self,\r\n        uint256 tokenAmount,\r\n        uint8 tokenIndex,\r\n        uint256 totalSupply\r\n    ) internal view returns (uint256, uint256) {\r\n        uint256 dy;\r\n        uint256 newY;\r\n        uint256 currentY;\r\n\r\n        (dy, newY, currentY) = calculateWithdrawOneTokenDY(\r\n            self,\r\n            tokenIndex,\r\n            tokenAmount,\r\n            totalSupply\r\n        );\r\n\r\n        // dy_0 (without fees)\r\n        // dy, dy_0 - dy\r\n\r\n        uint256 dySwapFee = currentY\r\n            .sub(newY)\r\n            .div(self.tokenPrecisionMultipliers[tokenIndex])\r\n            .sub(dy);\r\n\r\n        return (dy, dySwapFee);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the dy of withdrawing in one token\r\n     * @param self Swap struct to read from\r\n     * @param tokenIndex which token will be withdrawn\r\n     * @param tokenAmount the amount to withdraw in the pools precision\r\n     * @return the d and the new y after withdrawing one token\r\n     */\r\n    function calculateWithdrawOneTokenDY(\r\n        Swap storage self,\r\n        uint8 tokenIndex,\r\n        uint256 tokenAmount,\r\n        uint256 totalSupply\r\n    )\r\n        internal\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        )\r\n    {\r\n        // Get the current D, then solve the stableswap invariant\r\n        // y_i for D - tokenAmount\r\n        uint256[] memory xp = _xp(self);\r\n\r\n        require(tokenIndex < xp.length, \"Token index out of range\");\r\n\r\n        CalculateWithdrawOneTokenDYInfo\r\n            memory v = CalculateWithdrawOneTokenDYInfo(0, 0, 0, 0, 0);\r\n        v.preciseA = _getAPrecise(self);\r\n        v.d0 = getD(xp, v.preciseA);\r\n        v.d1 = v.d0.sub(tokenAmount.mul(v.d0).div(totalSupply));\r\n\r\n        require(tokenAmount <= xp[tokenIndex], \"Withdraw exceeds available\");\r\n\r\n        v.newY = getYD(v.preciseA, tokenIndex, xp, v.d1);\r\n\r\n        uint256[] memory xpReduced = new uint256[](xp.length);\r\n\r\n        v.feePerToken = _feePerToken(self.swapFee, xp.length);\r\n        for (uint256 i = 0; i < xp.length; i++) {\r\n            uint256 xpi = xp[i];\r\n            // if i == tokenIndex, dxExpected = xp[i] * d1 / d0 - newY\r\n            // else dxExpected = xp[i] - (xp[i] * d1 / d0)\r\n            // xpReduced[i] -= dxExpected * fee / FEE_DENOMINATOR\r\n            xpReduced[i] = xpi.sub(\r\n                (\r\n                    (i == tokenIndex)\r\n                        ? xpi.mul(v.d1).div(v.d0).sub(v.newY)\r\n                        : xpi.sub(xpi.mul(v.d1).div(v.d0))\r\n                ).mul(v.feePerToken).div(FEE_DENOMINATOR)\r\n            );\r\n        }\r\n\r\n        uint256 dy = xpReduced[tokenIndex].sub(\r\n            getYD(v.preciseA, tokenIndex, xpReduced, v.d1)\r\n        );\r\n        dy = dy.sub(1).div(self.tokenPrecisionMultipliers[tokenIndex]);\r\n\r\n        return (dy, v.newY, xp[tokenIndex]);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the price of a token in the pool with given\r\n     * precision-adjusted balances and a particular D.\r\n     *\r\n     * @dev This is accomplished via solving the invariant iteratively.\r\n     * See the StableSwap paper and Curve.fi implementation for further details.\r\n     *\r\n     * x_1**2 + x1 * (sum' - (A*n**n - 1) * D / (A * n**n)) = D ** (n + 1) / (n ** (2 * n) * prod' * A)\r\n     * x_1**2 + b*x_1 = c\r\n     * x_1 = (x_1**2 + c) / (2*x_1 + b)\r\n     *\r\n     * @param a the amplification coefficient * n * (n - 1). See the StableSwap paper for details.\r\n     * @param tokenIndex Index of token we are calculating for.\r\n     * @param xp a precision-adjusted set of pool balances. Array should be\r\n     * the same cardinality as the pool.\r\n     * @param d the stableswap invariant\r\n     * @return the price of the token, in the same precision as in xp\r\n     */\r\n    function getYD(\r\n        uint256 a,\r\n        uint8 tokenIndex,\r\n        uint256[] memory xp,\r\n        uint256 d\r\n    ) internal pure returns (uint256) {\r\n        uint256 numTokens = xp.length;\r\n        require(tokenIndex < numTokens, \"Token not found\");\r\n\r\n        uint256 c = d;\r\n        uint256 s;\r\n        uint256 nA = a.mul(numTokens);\r\n\r\n        for (uint256 i = 0; i < numTokens; i++) {\r\n            if (i != tokenIndex) {\r\n                s = s.add(xp[i]);\r\n                c = c.mul(d).div(xp[i].mul(numTokens));\r\n                // If we were to protect the division loss we would have to keep the denominator separate\r\n                // and divide at the end. However this leads to overflow with large numTokens or/and D.\r\n                // c = c * D * D * D * ... overflow!\r\n            }\r\n        }\r\n        c = c.mul(d).mul(AmplificationUtils.A_PRECISION).div(nA.mul(numTokens));\r\n\r\n        uint256 b = s.add(d.mul(AmplificationUtils.A_PRECISION).div(nA));\r\n        uint256 yPrev;\r\n        uint256 y = d;\r\n        for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {\r\n            yPrev = y;\r\n            y = y.mul(y).add(c).div(y.mul(2).add(b).sub(d));\r\n            if (y.within1(yPrev)) {\r\n                return y;\r\n            }\r\n        }\r\n        revert(\"Approximation did not converge\");\r\n    }\r\n\r\n    /**\r\n     * @notice Get D, the StableSwap invariant, based on a set of balances and a particular A.\r\n     * @param xp a precision-adjusted set of pool balances. Array should be the same cardinality\r\n     * as the pool.\r\n     * @param a the amplification coefficient * n * (n - 1) in A_PRECISION.\r\n     * See the StableSwap paper for details\r\n     * @return the invariant, at the precision of the pool\r\n     */\r\n    function getD(uint256[] memory xp, uint256 a)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 numTokens = xp.length;\r\n        uint256 s;\r\n        for (uint256 i = 0; i < numTokens; i++) {\r\n            s = s.add(xp[i]);\r\n        }\r\n        if (s == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 prevD;\r\n        uint256 d = s;\r\n        uint256 nA = a.mul(numTokens);\r\n\r\n        for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {\r\n            uint256 dP = d;\r\n            for (uint256 j = 0; j < numTokens; j++) {\r\n                dP = dP.mul(d).div(xp[j].mul(numTokens));\r\n                // If we were to protect the division loss we would have to keep the denominator separate\r\n                // and divide at the end. However this leads to overflow with large numTokens or/and D.\r\n                // dP = dP * D * D * D * ... overflow!\r\n            }\r\n            prevD = d;\r\n            d = nA\r\n                .mul(s)\r\n                .div(AmplificationUtils.A_PRECISION)\r\n                .add(dP.mul(numTokens))\r\n                .mul(d)\r\n                .div(\r\n                    nA\r\n                        .sub(AmplificationUtils.A_PRECISION)\r\n                        .mul(d)\r\n                        .div(AmplificationUtils.A_PRECISION)\r\n                        .add(numTokens.add(1).mul(dP))\r\n                );\r\n            if (d.within1(prevD)) {\r\n                return d;\r\n            }\r\n        }\r\n\r\n        // Convergence should occur in 4 loops or less. If this is reached, there may be something wrong\r\n        // with the pool. If this were to occur repeatedly, LPs should withdraw via `removeLiquidity()`\r\n        // function which does not rely on D.\r\n        revert(\"D does not converge\");\r\n    }\r\n\r\n    /**\r\n     * @notice Given a set of balances and precision multipliers, return the\r\n     * precision-adjusted balances.\r\n     *\r\n     * @param balances an array of token balances, in their native precisions.\r\n     * These should generally correspond with pooled tokens.\r\n     *\r\n     * @param precisionMultipliers an array of multipliers, corresponding to\r\n     * the amounts in the balances array. When multiplied together they\r\n     * should yield amounts at the pool's precision.\r\n     *\r\n     * @return an array of amounts \"scaled\" to the pool's precision\r\n     */\r\n    function _xp(\r\n        uint256[] memory balances,\r\n        uint256[] memory precisionMultipliers\r\n    ) internal pure returns (uint256[] memory) {\r\n        uint256 numTokens = balances.length;\r\n        require(\r\n            numTokens == precisionMultipliers.length,\r\n            \"Balances must match multipliers\"\r\n        );\r\n        uint256[] memory xp = new uint256[](numTokens);\r\n        for (uint256 i = 0; i < numTokens; i++) {\r\n            xp[i] = balances[i].mul(precisionMultipliers[i]);\r\n        }\r\n        return xp;\r\n    }\r\n\r\n    /**\r\n     * @notice Return the precision-adjusted balances of all tokens in the pool\r\n     * @param self Swap struct to read from\r\n     * @return the pool balances \"scaled\" to the pool's precision, allowing\r\n     * them to be more easily compared.\r\n     */\r\n    function _xp(Swap storage self) internal view returns (uint256[] memory) {\r\n        return _xp(self.balances, self.tokenPrecisionMultipliers);\r\n    }\r\n\r\n    /**\r\n     * @notice Get the virtual price, to help calculate profit\r\n     * @param self Swap struct to read from\r\n     * @return the virtual price, scaled to precision of POOL_PRECISION_DECIMALS\r\n     */\r\n    function getVirtualPrice(Swap storage self)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 d = getD(_xp(self), _getAPrecise(self));\r\n        LPToken lpToken = self.lpToken;\r\n        uint256 supply = lpToken.totalSupply();\r\n        if (supply > 0) {\r\n            return d.mul(10**uint256(POOL_PRECISION_DECIMALS)).div(supply);\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the new balances of the tokens given the indexes of the token\r\n     * that is swapped from (FROM) and the token that is swapped to (TO).\r\n     * This function is used as a helper function to calculate how much TO token\r\n     * the user should receive on swap.\r\n     *\r\n     * @param preciseA precise form of amplification coefficient\r\n     * @param tokenIndexFrom index of FROM token\r\n     * @param tokenIndexTo index of TO token\r\n     * @param x the new total amount of FROM token\r\n     * @param xp balances of the tokens in the pool\r\n     * @return the amount of TO token that should remain in the pool\r\n     */\r\n    function getY(\r\n        uint256 preciseA,\r\n        uint8 tokenIndexFrom,\r\n        uint8 tokenIndexTo,\r\n        uint256 x,\r\n        uint256[] memory xp\r\n    ) internal pure returns (uint256) {\r\n        uint256 numTokens = xp.length;\r\n        require(\r\n            tokenIndexFrom != tokenIndexTo,\r\n            \"Can't compare token to itself\"\r\n        );\r\n        require(\r\n            tokenIndexFrom < numTokens && tokenIndexTo < numTokens,\r\n            \"Tokens must be in pool\"\r\n        );\r\n\r\n        uint256 d = getD(xp, preciseA);\r\n        uint256 c = d;\r\n        uint256 s;\r\n        uint256 nA = numTokens.mul(preciseA);\r\n\r\n        uint256 _x;\r\n        for (uint256 i = 0; i < numTokens; i++) {\r\n            if (i == tokenIndexFrom) {\r\n                _x = x;\r\n            } else if (i != tokenIndexTo) {\r\n                _x = xp[i];\r\n            } else {\r\n                continue;\r\n            }\r\n            s = s.add(_x);\r\n            c = c.mul(d).div(_x.mul(numTokens));\r\n            // If we were to protect the division loss we would have to keep the denominator separate\r\n            // and divide at the end. However this leads to overflow with large numTokens or/and D.\r\n            // c = c * D * D * D * ... overflow!\r\n        }\r\n        c = c.mul(d).mul(AmplificationUtils.A_PRECISION).div(nA.mul(numTokens));\r\n        uint256 b = s.add(d.mul(AmplificationUtils.A_PRECISION).div(nA));\r\n        uint256 yPrev;\r\n        uint256 y = d;\r\n\r\n        // iterative approximation\r\n        for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {\r\n            yPrev = y;\r\n            y = y.mul(y).add(c).div(y.mul(2).add(b).sub(d));\r\n            if (y.within1(yPrev)) {\r\n                return y;\r\n            }\r\n        }\r\n        revert(\"Approximation did not converge\");\r\n    }\r\n\r\n    /**\r\n     * @notice Externally calculates a swap between two tokens.\r\n     * @param self Swap struct to read from\r\n     * @param tokenIndexFrom the token to sell\r\n     * @param tokenIndexTo the token to buy\r\n     * @param dx the number of tokens to sell. If the token charges a fee on transfers,\r\n     * use the amount that gets transferred after the fee.\r\n     * @return dy the number of tokens the user will get\r\n     */\r\n    function calculateSwap(\r\n        Swap storage self,\r\n        uint8 tokenIndexFrom,\r\n        uint8 tokenIndexTo,\r\n        uint256 dx\r\n    ) external view returns (uint256 dy) {\r\n        (dy, ) = _calculateSwap(\r\n            self,\r\n            tokenIndexFrom,\r\n            tokenIndexTo,\r\n            dx,\r\n            self.balances\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Internally calculates a swap between two tokens.\r\n     *\r\n     * @dev The caller is expected to transfer the actual amounts (dx and dy)\r\n     * using the token contracts.\r\n     *\r\n     * @param self Swap struct to read from\r\n     * @param tokenIndexFrom the token to sell\r\n     * @param tokenIndexTo the token to buy\r\n     * @param dx the number of tokens to sell. If the token charges a fee on transfers,\r\n     * use the amount that gets transferred after the fee.\r\n     * @return dy the number of tokens the user will get\r\n     * @return dyFee the associated fee\r\n     */\r\n    function _calculateSwap(\r\n        Swap storage self,\r\n        uint8 tokenIndexFrom,\r\n        uint8 tokenIndexTo,\r\n        uint256 dx,\r\n        uint256[] memory balances\r\n    ) internal view returns (uint256 dy, uint256 dyFee) {\r\n        uint256[] memory multipliers = self.tokenPrecisionMultipliers;\r\n        uint256[] memory xp = _xp(balances, multipliers);\r\n        require(\r\n            tokenIndexFrom < xp.length && tokenIndexTo < xp.length,\r\n            \"Token index out of range\"\r\n        );\r\n        uint256 x = dx.mul(multipliers[tokenIndexFrom]).add(xp[tokenIndexFrom]);\r\n        uint256 y = getY(\r\n            _getAPrecise(self),\r\n            tokenIndexFrom,\r\n            tokenIndexTo,\r\n            x,\r\n            xp\r\n        );\r\n        dy = xp[tokenIndexTo].sub(y).sub(1);\r\n        dyFee = dy.mul(self.swapFee).div(FEE_DENOMINATOR);\r\n        dy = dy.sub(dyFee).div(multipliers[tokenIndexTo]);\r\n    }\r\n\r\n    /**\r\n     * @notice A simple method to calculate amount of each underlying\r\n     * tokens that is returned upon burning given amount of\r\n     * LP tokens\r\n     *\r\n     * @param amount the amount of LP tokens that would to be burned on\r\n     * withdrawal\r\n     * @return array of amounts of tokens user will receive\r\n     */\r\n    function calculateRemoveLiquidity(Swap storage self, uint256 amount)\r\n        external\r\n        view\r\n        returns (uint256[] memory)\r\n    {\r\n        return\r\n            _calculateRemoveLiquidity(\r\n                self.balances,\r\n                amount,\r\n                self.lpToken.totalSupply()\r\n            );\r\n    }\r\n\r\n    function _calculateRemoveLiquidity(\r\n        uint256[] memory balances,\r\n        uint256 amount,\r\n        uint256 totalSupply\r\n    ) internal pure returns (uint256[] memory) {\r\n        require(amount <= totalSupply, \"Cannot exceed total supply\");\r\n\r\n        uint256[] memory amounts = new uint256[](balances.length);\r\n\r\n        for (uint256 i = 0; i < balances.length; i++) {\r\n            amounts[i] = balances[i].mul(amount).div(totalSupply);\r\n        }\r\n        return amounts;\r\n    }\r\n\r\n    /**\r\n     * @notice A simple method to calculate prices from deposits or\r\n     * withdrawals, excluding fees but including slippage. This is\r\n     * helpful as an input into the various \"min\" parameters on calls\r\n     * to fight front-running\r\n     *\r\n     * @dev This shouldn't be used outside frontends for user estimates.\r\n     *\r\n     * @param self Swap struct to read from\r\n     * @param amounts an array of token amounts to deposit or withdrawal,\r\n     * corresponding to pooledTokens. The amount should be in each\r\n     * pooled token's native precision. If a token charges a fee on transfers,\r\n     * use the amount that gets transferred after the fee.\r\n     * @param deposit whether this is a deposit or a withdrawal\r\n     * @return if deposit was true, total amount of lp token that will be minted and if\r\n     * deposit was false, total amount of lp token that will be burned\r\n     */\r\n    function calculateTokenAmount(\r\n        Swap storage self,\r\n        uint256[] calldata amounts,\r\n        bool deposit\r\n    ) external view returns (uint256) {\r\n        uint256 a = _getAPrecise(self);\r\n        uint256[] memory balances = self.balances;\r\n        uint256[] memory multipliers = self.tokenPrecisionMultipliers;\r\n\r\n        uint256 d0 = getD(_xp(balances, multipliers), a);\r\n        for (uint256 i = 0; i < balances.length; i++) {\r\n            if (deposit) {\r\n                balances[i] = balances[i].add(amounts[i]);\r\n            } else {\r\n                balances[i] = balances[i].sub(\r\n                    amounts[i],\r\n                    \"Cannot withdraw more than available\"\r\n                );\r\n            }\r\n        }\r\n        uint256 d1 = getD(_xp(balances, multipliers), a);\r\n        uint256 totalSupply = self.lpToken.totalSupply();\r\n\r\n        if (deposit) {\r\n            return d1.sub(d0).mul(totalSupply).div(d0);\r\n        } else {\r\n            return d0.sub(d1).mul(totalSupply).div(d0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice return accumulated amount of admin fees of the token with given index\r\n     * @param self Swap struct to read from\r\n     * @param index Index of the pooled token\r\n     * @return admin balance in the token's precision\r\n     */\r\n    function getAdminBalance(Swap storage self, uint256 index)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        require(index < self.pooledTokens.length, \"Token index out of range\");\r\n        return\r\n            self.pooledTokens[index].balanceOf(address(this)).sub(\r\n                self.balances[index]\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @notice internal helper function to calculate fee per token multiplier used in\r\n     * swap fee calculations\r\n     * @param swapFee swap fee for the tokens\r\n     * @param numTokens number of tokens pooled\r\n     */\r\n    function _feePerToken(uint256 swapFee, uint256 numTokens)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return swapFee.mul(numTokens).div(numTokens.sub(1).mul(4));\r\n    }\r\n\r\n    /*** STATE MODIFYING FUNCTIONS ***/\r\n\r\n    /**\r\n     * @notice swap two tokens in the pool\r\n     * @param self Swap struct to read from and write to\r\n     * @param tokenIndexFrom the token the user wants to sell\r\n     * @param tokenIndexTo the token the user wants to buy\r\n     * @param dx the amount of tokens the user wants to sell\r\n     * @param minDy the min amount the user would like to receive, or revert.\r\n     * @return amount of token user received on swap\r\n     */\r\n    function swap(\r\n        Swap storage self,\r\n        uint8 tokenIndexFrom,\r\n        uint8 tokenIndexTo,\r\n        uint256 dx,\r\n        uint256 minDy\r\n    ) external returns (uint256) {\r\n        {\r\n            IERC20 tokenFrom = self.pooledTokens[tokenIndexFrom];\r\n            require(\r\n                dx <= tokenFrom.balanceOf(msg.sender),\r\n                \"Cannot swap more than you own\"\r\n            );\r\n            // Transfer tokens first to see if a fee was charged on transfer\r\n            uint256 beforeBalance = tokenFrom.balanceOf(address(this));\r\n            tokenFrom.safeTransferFrom(msg.sender, address(this), dx);\r\n\r\n            // Use the actual transferred amount for AMM math\r\n            dx = tokenFrom.balanceOf(address(this)).sub(beforeBalance);\r\n        }\r\n\r\n        uint256 dy;\r\n        uint256 dyFee;\r\n        uint256[] memory balances = self.balances;\r\n        (dy, dyFee) = _calculateSwap(\r\n            self,\r\n            tokenIndexFrom,\r\n            tokenIndexTo,\r\n            dx,\r\n            balances\r\n        );\r\n        require(dy >= minDy, \"Swap didn't result in min tokens\");\r\n\r\n        uint256 dyAdminFee = dyFee.mul(self.adminFee).div(FEE_DENOMINATOR).div(\r\n            self.tokenPrecisionMultipliers[tokenIndexTo]\r\n        );\r\n\r\n        self.balances[tokenIndexFrom] = balances[tokenIndexFrom].add(dx);\r\n        self.balances[tokenIndexTo] = balances[tokenIndexTo].sub(dy).sub(\r\n            dyAdminFee\r\n        );\r\n\r\n        self.pooledTokens[tokenIndexTo].safeTransfer(msg.sender, dy);\r\n\r\n        emit TokenSwap(msg.sender, dx, dy, tokenIndexFrom, tokenIndexTo);\r\n\r\n        return dy;\r\n    }\r\n\r\n    /**\r\n     * @notice Add liquidity to the pool\r\n     * @param self Swap struct to read from and write to\r\n     * @param amounts the amounts of each token to add, in their native precision\r\n     * @param minToMint the minimum LP tokens adding this amount of liquidity\r\n     * should mint, otherwise revert. Handy for front-running mitigation\r\n     * allowed addresses. If the pool is not in the guarded launch phase, this parameter will be ignored.\r\n     * @return amount of LP token user received\r\n     */\r\n    function addLiquidity(\r\n        Swap storage self,\r\n        uint256[] memory amounts,\r\n        uint256 minToMint\r\n    ) external returns (uint256) {\r\n        IERC20[] memory pooledTokens = self.pooledTokens;\r\n        require(\r\n            amounts.length == pooledTokens.length,\r\n            \"Amounts must match pooled tokens\"\r\n        );\r\n\r\n        // current state\r\n        ManageLiquidityInfo memory v = ManageLiquidityInfo(\r\n            0,\r\n            0,\r\n            0,\r\n            _getAPrecise(self),\r\n            self.lpToken,\r\n            0,\r\n            self.balances,\r\n            self.tokenPrecisionMultipliers\r\n        );\r\n        v.totalSupply = v.lpToken.totalSupply();\r\n\r\n        if (v.totalSupply != 0) {\r\n            v.d0 = getD(_xp(v.balances, v.multipliers), v.preciseA);\r\n        }\r\n\r\n        uint256[] memory newBalances = new uint256[](pooledTokens.length);\r\n\r\n        for (uint256 i = 0; i < pooledTokens.length; i++) {\r\n            require(\r\n                v.totalSupply != 0 || amounts[i] > 0,\r\n                \"Must supply all tokens in pool\"\r\n            );\r\n\r\n            // Transfer tokens first to see if a fee was charged on transfer\r\n            if (amounts[i] != 0) {\r\n                uint256 beforeBalance = pooledTokens[i].balanceOf(\r\n                    address(this)\r\n                );\r\n                pooledTokens[i].safeTransferFrom(\r\n                    msg.sender,\r\n                    address(this),\r\n                    amounts[i]\r\n                );\r\n\r\n                // Update the amounts[] with actual transfer amount\r\n                amounts[i] = pooledTokens[i].balanceOf(address(this)).sub(\r\n                    beforeBalance\r\n                );\r\n            }\r\n\r\n            newBalances[i] = v.balances[i].add(amounts[i]);\r\n        }\r\n\r\n        // invariant after change\r\n        v.d1 = getD(_xp(newBalances, v.multipliers), v.preciseA);\r\n        require(v.d1 > v.d0, \"D should increase\");\r\n\r\n        // updated to reflect fees and calculate the user's LP tokens\r\n        v.d2 = v.d1;\r\n        uint256[] memory fees = new uint256[](pooledTokens.length);\r\n\r\n        if (v.totalSupply != 0) {\r\n            uint256 feePerToken = _feePerToken(\r\n                self.swapFee,\r\n                pooledTokens.length\r\n            );\r\n            for (uint256 i = 0; i < pooledTokens.length; i++) {\r\n                uint256 idealBalance = v.d1.mul(v.balances[i]).div(v.d0);\r\n                fees[i] = feePerToken\r\n                    .mul(idealBalance.difference(newBalances[i]))\r\n                    .div(FEE_DENOMINATOR);\r\n                self.balances[i] = newBalances[i].sub(\r\n                    fees[i].mul(self.adminFee).div(FEE_DENOMINATOR)\r\n                );\r\n                newBalances[i] = newBalances[i].sub(fees[i]);\r\n            }\r\n            v.d2 = getD(_xp(newBalances, v.multipliers), v.preciseA);\r\n        } else {\r\n            // the initial depositor doesn't pay fees\r\n            self.balances = newBalances;\r\n        }\r\n\r\n        uint256 toMint;\r\n        if (v.totalSupply == 0) {\r\n            toMint = v.d1;\r\n        } else {\r\n            toMint = v.d2.sub(v.d0).mul(v.totalSupply).div(v.d0);\r\n        }\r\n\r\n        require(toMint >= minToMint, \"Couldn't mint min requested\");\r\n\r\n        // mint the user's LP tokens\r\n        v.lpToken.mint(msg.sender, toMint);\r\n\r\n        emit AddLiquidity(\r\n            msg.sender,\r\n            amounts,\r\n            fees,\r\n            v.d1,\r\n            v.totalSupply.add(toMint)\r\n        );\r\n\r\n        return toMint;\r\n    }\r\n\r\n    /**\r\n     * @notice Burn LP tokens to remove liquidity from the pool.\r\n     * @dev Liquidity can always be removed, even when the pool is paused.\r\n     * @param self Swap struct to read from and write to\r\n     * @param amount the amount of LP tokens to burn\r\n     * @param minAmounts the minimum amounts of each token in the pool\r\n     * acceptable for this burn. Useful as a front-running mitigation\r\n     * @return amounts of tokens the user received\r\n     */\r\n    function removeLiquidity(\r\n        Swap storage self,\r\n        uint256 amount,\r\n        uint256[] calldata minAmounts\r\n    ) external returns (uint256[] memory) {\r\n        LPToken lpToken = self.lpToken;\r\n        IERC20[] memory pooledTokens = self.pooledTokens;\r\n        require(amount <= lpToken.balanceOf(msg.sender), \">LP.balanceOf\");\r\n        require(\r\n            minAmounts.length == pooledTokens.length,\r\n            \"minAmounts must match poolTokens\"\r\n        );\r\n\r\n        uint256[] memory balances = self.balances;\r\n        uint256 totalSupply = lpToken.totalSupply();\r\n\r\n        uint256[] memory amounts = _calculateRemoveLiquidity(\r\n            balances,\r\n            amount,\r\n            totalSupply\r\n        );\r\n\r\n        for (uint256 i = 0; i < amounts.length; i++) {\r\n            require(amounts[i] >= minAmounts[i], \"amounts[i] < minAmounts[i]\");\r\n            self.balances[i] = balances[i].sub(amounts[i]);\r\n            pooledTokens[i].safeTransfer(msg.sender, amounts[i]);\r\n        }\r\n\r\n        lpToken.burnFrom(msg.sender, amount);\r\n\r\n        emit RemoveLiquidity(msg.sender, amounts, totalSupply.sub(amount));\r\n\r\n        return amounts;\r\n    }\r\n\r\n    /**\r\n     * @notice Remove liquidity from the pool all in one token.\r\n     * @param self Swap struct to read from and write to\r\n     * @param tokenAmount the amount of the lp tokens to burn\r\n     * @param tokenIndex the index of the token you want to receive\r\n     * @param minAmount the minimum amount to withdraw, otherwise revert\r\n     * @return amount chosen token that user received\r\n     */\r\n    function removeLiquidityOneToken(\r\n        Swap storage self,\r\n        uint256 tokenAmount,\r\n        uint8 tokenIndex,\r\n        uint256 minAmount\r\n    ) external returns (uint256) {\r\n        LPToken lpToken = self.lpToken;\r\n        IERC20[] memory pooledTokens = self.pooledTokens;\r\n\r\n        require(tokenAmount <= lpToken.balanceOf(msg.sender), \">LP.balanceOf\");\r\n        require(tokenIndex < pooledTokens.length, \"Token not found\");\r\n\r\n        uint256 totalSupply = lpToken.totalSupply();\r\n\r\n        (uint256 dy, uint256 dyFee) = _calculateWithdrawOneToken(\r\n            self,\r\n            tokenAmount,\r\n            tokenIndex,\r\n            totalSupply\r\n        );\r\n\r\n        require(dy >= minAmount, \"dy < minAmount\");\r\n\r\n        self.balances[tokenIndex] = self.balances[tokenIndex].sub(\r\n            dy.add(dyFee.mul(self.adminFee).div(FEE_DENOMINATOR))\r\n        );\r\n        lpToken.burnFrom(msg.sender, tokenAmount);\r\n        pooledTokens[tokenIndex].safeTransfer(msg.sender, dy);\r\n\r\n        emit RemoveLiquidityOne(\r\n            msg.sender,\r\n            tokenAmount,\r\n            totalSupply,\r\n            tokenIndex,\r\n            dy\r\n        );\r\n\r\n        return dy;\r\n    }\r\n\r\n    /**\r\n     * @notice Remove liquidity from the pool, weighted differently than the\r\n     * pool's current balances.\r\n     *\r\n     * @param self Swap struct to read from and write to\r\n     * @param amounts how much of each token to withdraw\r\n     * @param maxBurnAmount the max LP token provider is willing to pay to\r\n     * remove liquidity. Useful as a front-running mitigation.\r\n     * @return actual amount of LP tokens burned in the withdrawal\r\n     */\r\n    function removeLiquidityImbalance(\r\n        Swap storage self,\r\n        uint256[] memory amounts,\r\n        uint256 maxBurnAmount\r\n    ) public returns (uint256) {\r\n        ManageLiquidityInfo memory v = ManageLiquidityInfo(\r\n            0,\r\n            0,\r\n            0,\r\n            _getAPrecise(self),\r\n            self.lpToken,\r\n            0,\r\n            self.balances,\r\n            self.tokenPrecisionMultipliers\r\n        );\r\n        v.totalSupply = v.lpToken.totalSupply();\r\n\r\n        IERC20[] memory pooledTokens = self.pooledTokens;\r\n\r\n        require(\r\n            amounts.length == pooledTokens.length,\r\n            \"Amounts should match pool tokens\"\r\n        );\r\n\r\n        require(\r\n            maxBurnAmount <= v.lpToken.balanceOf(msg.sender) &&\r\n                maxBurnAmount != 0,\r\n            \">LP.balanceOf\"\r\n        );\r\n\r\n        uint256 feePerToken = _feePerToken(self.swapFee, pooledTokens.length);\r\n        uint256[] memory fees = new uint256[](pooledTokens.length);\r\n        {\r\n            uint256[] memory balances1 = new uint256[](pooledTokens.length);\r\n            v.d0 = getD(_xp(v.balances, v.multipliers), v.preciseA);\r\n            for (uint256 i = 0; i < pooledTokens.length; i++) {\r\n                balances1[i] = v.balances[i].sub(\r\n                    amounts[i],\r\n                    \"Cannot withdraw more than available\"\r\n                );\r\n            }\r\n            v.d1 = getD(_xp(balances1, v.multipliers), v.preciseA);\r\n\r\n            for (uint256 i = 0; i < pooledTokens.length; i++) {\r\n                uint256 idealBalance = v.d1.mul(v.balances[i]).div(v.d0);\r\n                uint256 difference = idealBalance.difference(balances1[i]);\r\n                fees[i] = feePerToken.mul(difference).div(FEE_DENOMINATOR);\r\n                self.balances[i] = balances1[i].sub(\r\n                    fees[i].mul(self.adminFee).div(FEE_DENOMINATOR)\r\n                );\r\n                balances1[i] = balances1[i].sub(fees[i]);\r\n            }\r\n\r\n            v.d2 = getD(_xp(balances1, v.multipliers), v.preciseA);\r\n        }\r\n        uint256 tokenAmount = v.d0.sub(v.d2).mul(v.totalSupply).div(v.d0);\r\n        require(tokenAmount != 0, \"Burnt amount cannot be zero\");\r\n        tokenAmount = tokenAmount.add(1);\r\n\r\n        require(tokenAmount <= maxBurnAmount, \"tokenAmount > maxBurnAmount\");\r\n\r\n        v.lpToken.burnFrom(msg.sender, tokenAmount);\r\n\r\n        for (uint256 i = 0; i < pooledTokens.length; i++) {\r\n            pooledTokens[i].safeTransfer(msg.sender, amounts[i]);\r\n        }\r\n\r\n        emit RemoveLiquidityImbalance(\r\n            msg.sender,\r\n            amounts,\r\n            fees,\r\n            v.d1,\r\n            v.totalSupply.sub(tokenAmount)\r\n        );\r\n\r\n        return tokenAmount;\r\n    }\r\n\r\n    /**\r\n     * @notice withdraw all admin fees to a given address\r\n     * @param self Swap struct to withdraw fees from\r\n     * @param to Address to send the fees to\r\n     */\r\n    function withdrawAdminFees(Swap storage self, address to) external {\r\n        IERC20[] memory pooledTokens = self.pooledTokens;\r\n        for (uint256 i = 0; i < pooledTokens.length; i++) {\r\n            IERC20 token = pooledTokens[i];\r\n            uint256 balance = token.balanceOf(address(this)).sub(\r\n                self.balances[i]\r\n            );\r\n            if (balance != 0) {\r\n                token.safeTransfer(to, balance);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the admin fee\r\n     * @dev adminFee cannot be higher than 100% of the swap fee\r\n     * @param self Swap struct to update\r\n     * @param newAdminFee new admin fee to be applied on future transactions\r\n     */\r\n    function setAdminFee(Swap storage self, uint256 newAdminFee) external {\r\n        require(newAdminFee <= MAX_ADMIN_FEE, \"Fee is too high\");\r\n        self.adminFee = newAdminFee;\r\n\r\n        emit NewAdminFee(newAdminFee);\r\n    }\r\n\r\n    /**\r\n     * @notice update the swap fee\r\n     * @dev fee cannot be higher than 1% of each swap\r\n     * @param self Swap struct to update\r\n     * @param newSwapFee new swap fee to be applied on future transactions\r\n     */\r\n    function setSwapFee(Swap storage self, uint256 newSwapFee) external {\r\n        require(newSwapFee <= MAX_SWAP_FEE, \"Fee is too high\");\r\n        self.swapFee = newSwapFee;\r\n\r\n        emit NewSwapFee(newSwapFee);\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/LPToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20BurnableUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport \"./interfaces/ISwap.sol\";\r\n\r\n/**\r\n * @title Liquidity Provider Token\r\n * @notice This token is an ERC20 detailed token with added capability to be minted by the owner.\r\n * It is used to represent user's shares when providing liquidity to swap contracts.\r\n * @dev Only Swap contracts should initialize and own LPToken contracts.\r\n */\r\ncontract LPToken is ERC20BurnableUpgradeable, OwnableUpgradeable {\r\n    using SafeMathUpgradeable for uint256;\r\n\r\n    /**\r\n     * @notice Initializes this LPToken contract with the given name and symbol\r\n     * @dev The caller of this function will become the owner. A Swap contract should call this\r\n     * in its initializer function.\r\n     * @param name name of this token\r\n     * @param symbol symbol of this token\r\n     */\r\n    function initialize(string memory name, string memory symbol)\r\n        external\r\n        initializer\r\n        returns (bool)\r\n    {\r\n        __Context_init_unchained();\r\n        __ERC20_init_unchained(name, symbol);\r\n        __Ownable_init_unchained();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Mints the given amount of LPToken to the recipient.\r\n     * @dev only owner can call this mint function\r\n     * @param recipient address of account to receive the tokens\r\n     * @param amount amount of tokens to mint\r\n     */\r\n    function mint(address recipient, uint256 amount) external onlyOwner {\r\n        require(amount != 0, \"LPToken: cannot mint 0\");\r\n        _mint(recipient, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Overrides ERC20._beforeTokenTransfer() which get called on every transfers including\r\n     * minting and burning. This ensures that Swap.updateUserWithdrawFees are called everytime.\r\n     * This assumes the owner is set to a Swap contract's address.\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual override(ERC20Upgradeable) {\r\n        super._beforeTokenTransfer(from, to, amount);\r\n        require(to != address(this), \"LPToken: cannot send to itself\");\r\n    }\r\n}\r\n"
    },
    "contracts/MathUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\n\r\n/**\r\n * @title MathUtils library\r\n * @notice A library to be used in conjunction with SafeMath. Contains functions for calculating\r\n * differences between two uint256.\r\n */\r\nlibrary MathUtils {\r\n    /**\r\n     * @notice Compares a and b and returns true if the difference between a and b\r\n     *         is less than 1 or equal to each other.\r\n     * @param a uint256 to compare with\r\n     * @param b uint256 to compare with\r\n     * @return True if the difference between a and b is less than 1 or equal,\r\n     *         otherwise return false\r\n     */\r\n    function within1(uint256 a, uint256 b) internal pure returns (bool) {\r\n        return (difference(a, b) <= 1);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates absolute difference between a and b\r\n     * @param a uint256 to compare with\r\n     * @param b uint256 to compare with\r\n     * @return Difference between a and b\r\n     */\r\n    function difference(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a > b) {\r\n            return a - b;\r\n        }\r\n        return b - a;\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20BurnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"./ERC20Upgradeable.sol\";\nimport \"../../proxy/Initializable.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20BurnableUpgradeable is Initializable, ContextUpgradeable, ERC20Upgradeable {\n    function __ERC20Burnable_init() internal initializer {\n        __Context_init_unchained();\n        __ERC20Burnable_init_unchained();\n    }\n\n    function __ERC20Burnable_init_unchained() internal initializer {\n    }\n    using SafeMathUpgradeable for uint256;\n\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, \"ERC20: burn amount exceeds allowance\");\n\n        _approve(account, _msgSender(), decreasedAllowance);\n        _burn(account, amount);\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/Initializable.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal initializer {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal initializer {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/interfaces/ISwap.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"./IAllowlist.sol\";\r\n\r\ninterface ISwap {\r\n    // pool data view functions\r\n    function getA() external view returns (uint256);\r\n\r\n    function getAPrecise() external view returns (uint256);\r\n\r\n    function getAllowlist() external view returns (IAllowlist);\r\n\r\n    function getToken(uint8 index) external view returns (IERC20);\r\n\r\n    function getTokenIndex(address tokenAddress) external view returns (uint8);\r\n\r\n    function getTokenBalance(uint8 index) external view returns (uint256);\r\n\r\n    function getVirtualPrice() external view returns (uint256);\r\n\r\n    function owner() external view returns (address);\r\n\r\n    function isGuarded() external view returns (bool);\r\n\r\n    function paused() external view returns (bool);\r\n\r\n    function swapStorage()\r\n        external\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            address\r\n        );\r\n\r\n    // min return calculation functions\r\n    function calculateSwap(\r\n        uint8 tokenIndexFrom,\r\n        uint8 tokenIndexTo,\r\n        uint256 dx\r\n    ) external view returns (uint256);\r\n\r\n    function calculateTokenAmount(uint256[] calldata amounts, bool deposit)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function calculateRemoveLiquidity(uint256 amount)\r\n        external\r\n        view\r\n        returns (uint256[] memory);\r\n\r\n    function calculateRemoveLiquidityOneToken(\r\n        uint256 tokenAmount,\r\n        uint8 tokenIndex\r\n    ) external view returns (uint256 availableTokenAmount);\r\n\r\n    // state modifying functions\r\n    function initialize(\r\n        IERC20[] memory pooledTokens,\r\n        uint8[] memory decimals,\r\n        string memory lpTokenName,\r\n        string memory lpTokenSymbol,\r\n        uint256 a,\r\n        uint256 fee,\r\n        uint256 adminFee,\r\n        address lpTokenTargetAddress\r\n    ) external;\r\n\r\n    function swap(\r\n        uint8 tokenIndexFrom,\r\n        uint8 tokenIndexTo,\r\n        uint256 dx,\r\n        uint256 minDy,\r\n        uint256 deadline\r\n    ) external returns (uint256);\r\n\r\n    function addLiquidity(\r\n        uint256[] calldata amounts,\r\n        uint256 minToMint,\r\n        uint256 deadline\r\n    ) external returns (uint256);\r\n\r\n    function removeLiquidity(\r\n        uint256 amount,\r\n        uint256[] calldata minAmounts,\r\n        uint256 deadline\r\n    ) external returns (uint256[] memory);\r\n\r\n    function removeLiquidityOneToken(\r\n        uint256 tokenAmount,\r\n        uint8 tokenIndex,\r\n        uint256 minAmount,\r\n        uint256 deadline\r\n    ) external returns (uint256);\r\n\r\n    function removeLiquidityImbalance(\r\n        uint256[] calldata amounts,\r\n        uint256 maxBurnAmount,\r\n        uint256 deadline\r\n    ) external returns (uint256);\r\n}\r\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\nimport \"../proxy/Initializable.sol\";\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n    }\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"./IERC20Upgradeable.sol\";\nimport \"../../math/SafeMathUpgradeable.sol\";\nimport \"../../proxy/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable {\n    using SafeMathUpgradeable for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal initializer {\n        __Context_init_unchained();\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal initializer {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal virtual {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n    uint256[44] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// solhint-disable-next-line compiler-version\npragma solidity >=0.4.24 <0.8.0;\n\nimport \"../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || _isConstructor() || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /// @dev Returns true if and only if the function is running in the constructor\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMathUpgradeable {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) public {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal virtual {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "contracts/interfaces/IAllowlist.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\n\r\ninterface IAllowlist {\r\n    function getPoolAccountLimit(address poolAddress)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function getPoolCap(address poolAddress) external view returns (uint256);\r\n\r\n    function verifyAddress(address account, bytes32[] calldata merkleProof)\r\n        external\r\n        returns (bool);\r\n}\r\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "contracts/Swap.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\r\nimport \"./OwnerPausableUpgradeable.sol\";\r\nimport \"./SwapUtils.sol\";\r\nimport \"./AmplificationUtils.sol\";\r\n\r\n/**\r\n * @title Swap - A StableSwap implementation in solidity.\r\n * @notice This contract is responsible for custody of closely pegged assets (eg. group of stablecoins)\r\n * and automatic market making system. Users become an LP (Liquidity Provider) by depositing their tokens\r\n * in desired ratios for an exchange of the pool token that represents their share of the pool.\r\n * Users can burn pool tokens and withdraw their share of token(s).\r\n *\r\n * Each time a swap between the pooled tokens happens, a set fee incurs which effectively gets\r\n * distributed to the LPs.\r\n *\r\n * In case of emergencies, admin can pause additional deposits, swaps, or single-asset withdraws - which\r\n * stops the ratio of the tokens in the pool from changing.\r\n * Users can always withdraw their tokens via multi-asset withdraws.\r\n *\r\n * @dev Most of the logic is stored as a library `SwapUtils` for the sake of reducing contract's\r\n * deployment size.\r\n */\r\ncontract Swap is OwnerPausableUpgradeable, ReentrancyGuardUpgradeable {\r\n    using SafeERC20 for IERC20;\r\n    using SafeMath for uint256;\r\n    using SwapUtils for SwapUtils.Swap;\r\n    using AmplificationUtils for SwapUtils.Swap;\r\n\r\n    // Struct storing data responsible for automatic market maker functionalities. In order to\r\n    // access this data, this contract uses SwapUtils library. For more details, see SwapUtils.sol\r\n    SwapUtils.Swap public swapStorage;\r\n\r\n    // Maps token address to an index in the pool. Used to prevent duplicate tokens in the pool.\r\n    // getTokenIndex function also relies on this mapping to retrieve token index.\r\n    mapping(address => uint8) private tokenIndexes;\r\n\r\n    /*** EVENTS ***/\r\n\r\n    // events replicated from SwapUtils to make the ABI easier for dumb\r\n    // clients\r\n    event TokenSwap(\r\n        address indexed buyer,\r\n        uint256 tokensSold,\r\n        uint256 tokensBought,\r\n        uint128 soldId,\r\n        uint128 boughtId\r\n    );\r\n    event AddLiquidity(\r\n        address indexed provider,\r\n        uint256[] tokenAmounts,\r\n        uint256[] fees,\r\n        uint256 invariant,\r\n        uint256 lpTokenSupply\r\n    );\r\n    event RemoveLiquidity(\r\n        address indexed provider,\r\n        uint256[] tokenAmounts,\r\n        uint256 lpTokenSupply\r\n    );\r\n    event RemoveLiquidityOne(\r\n        address indexed provider,\r\n        uint256 lpTokenAmount,\r\n        uint256 lpTokenSupply,\r\n        uint256 boughtId,\r\n        uint256 tokensBought\r\n    );\r\n    event RemoveLiquidityImbalance(\r\n        address indexed provider,\r\n        uint256[] tokenAmounts,\r\n        uint256[] fees,\r\n        uint256 invariant,\r\n        uint256 lpTokenSupply\r\n    );\r\n    event NewAdminFee(uint256 newAdminFee);\r\n    event NewSwapFee(uint256 newSwapFee);\r\n    event NewWithdrawFee(uint256 newWithdrawFee);\r\n    event RampA(\r\n        uint256 oldA,\r\n        uint256 newA,\r\n        uint256 initialTime,\r\n        uint256 futureTime\r\n    );\r\n    event StopRampA(uint256 currentA, uint256 time);\r\n\r\n    /**\r\n     * @notice Initializes this Swap contract with the given parameters.\r\n     * This will also clone a LPToken contract that represents users'\r\n     * LP positions. The owner of LPToken will be this contract - which means\r\n     * only this contract is allowed to mint/burn tokens.\r\n     *\r\n     * @param _pooledTokens an array of ERC20s this pool will accept\r\n     * @param decimals the decimals to use for each pooled token,\r\n     * eg 8 for WBTC. Cannot be larger than POOL_PRECISION_DECIMALS\r\n     * @param lpTokenName the long-form name of the token to be deployed\r\n     * @param lpTokenSymbol the short symbol for the token to be deployed\r\n     * @param _a the amplification coefficient * n * (n - 1). See the\r\n     * StableSwap paper for details\r\n     * @param _fee default swap fee to be initialized with\r\n     * @param _adminFee default adminFee to be initialized with\r\n     * @param lpTokenTargetAddress the address of an existing LPToken contract to use as a target\r\n     */\r\n    function initialize(\r\n        IERC20[] memory _pooledTokens,\r\n        uint8[] memory decimals,\r\n        string memory lpTokenName,\r\n        string memory lpTokenSymbol,\r\n        uint256 _a,\r\n        uint256 _fee,\r\n        uint256 _adminFee,\r\n        address lpTokenTargetAddress\r\n    ) public payable virtual initializer {\r\n        __OwnerPausable_init();\r\n        __ReentrancyGuard_init();\r\n        // Check _pooledTokens and precisions parameter\r\n        require(_pooledTokens.length > 1, \"_pooledTokens.length <= 1\");\r\n        require(_pooledTokens.length <= 32, \"_pooledTokens.length > 32\");\r\n        require(\r\n            _pooledTokens.length == decimals.length,\r\n            \"_pooledTokens decimals mismatch\"\r\n        );\r\n\r\n        uint256[] memory precisionMultipliers = new uint256[](decimals.length);\r\n\r\n        for (uint8 i = 0; i < _pooledTokens.length; i++) {\r\n            if (i > 0) {\r\n                // Check if index is already used. Check if 0th element is a duplicate.\r\n                require(\r\n                    tokenIndexes[address(_pooledTokens[i])] == 0 &&\r\n                        _pooledTokens[0] != _pooledTokens[i],\r\n                    \"Duplicate tokens\"\r\n                );\r\n            }\r\n            require(\r\n                address(_pooledTokens[i]) != address(0),\r\n                \"The 0 address isn't an ERC-20\"\r\n            );\r\n            require(\r\n                decimals[i] <= SwapUtils.POOL_PRECISION_DECIMALS,\r\n                \"Token decimals exceeds max\"\r\n            );\r\n            precisionMultipliers[i] =\r\n                10 **\r\n                    uint256(SwapUtils.POOL_PRECISION_DECIMALS).sub(\r\n                        uint256(decimals[i])\r\n                    );\r\n            tokenIndexes[address(_pooledTokens[i])] = i;\r\n        }\r\n\r\n        // Check _a, _fee, _adminFee, _withdrawFee parameters\r\n        require(_a < AmplificationUtils.MAX_A, \"_a exceeds maximum\");\r\n        require(_fee < SwapUtils.MAX_SWAP_FEE, \"_fee exceeds maximum\");\r\n        require(\r\n            _adminFee < SwapUtils.MAX_ADMIN_FEE,\r\n            \"_adminFee exceeds maximum\"\r\n        );\r\n\r\n        // Clone and initialize a LPToken contract\r\n        LPToken lpToken = LPToken(Clones.clone(lpTokenTargetAddress));\r\n        require(\r\n            lpToken.initialize(lpTokenName, lpTokenSymbol),\r\n            \"could not init lpToken clone\"\r\n        );\r\n\r\n        // Initialize swapStorage struct\r\n        swapStorage.lpToken = lpToken;\r\n        swapStorage.pooledTokens = _pooledTokens;\r\n        swapStorage.tokenPrecisionMultipliers = precisionMultipliers;\r\n        swapStorage.balances = new uint256[](_pooledTokens.length);\r\n        swapStorage.initialA = _a.mul(AmplificationUtils.A_PRECISION);\r\n        swapStorage.futureA = _a.mul(AmplificationUtils.A_PRECISION);\r\n        // swapStorage.initialATime = 0;\r\n        // swapStorage.futureATime = 0;\r\n        swapStorage.swapFee = _fee;\r\n        swapStorage.adminFee = _adminFee;\r\n    }\r\n\r\n    /*** MODIFIERS ***/\r\n\r\n    /**\r\n     * @notice Modifier to check deadline against current timestamp\r\n     * @param deadline latest timestamp to accept this transaction\r\n     */\r\n    modifier deadlineCheck(uint256 deadline) {\r\n        require(block.timestamp <= deadline, \"Deadline not met\");\r\n        _;\r\n    }\r\n\r\n    /*** VIEW FUNCTIONS ***/\r\n\r\n    /**\r\n     * @notice Return A, the amplification coefficient * n * (n - 1)\r\n     * @dev See the StableSwap paper for details\r\n     * @return A parameter\r\n     */\r\n    function getA() external view virtual returns (uint256) {\r\n        return swapStorage.getA();\r\n    }\r\n\r\n    /**\r\n     * @notice Return A in its raw precision form\r\n     * @dev See the StableSwap paper for details\r\n     * @return A parameter in its raw precision form\r\n     */\r\n    function getAPrecise() external view virtual returns (uint256) {\r\n        return swapStorage.getAPrecise();\r\n    }\r\n\r\n    /**\r\n     * @notice Return address of the pooled token at given index. Reverts if tokenIndex is out of range.\r\n     * @param index the index of the token\r\n     * @return address of the token at given index\r\n     */\r\n    function getToken(uint8 index) public view virtual returns (IERC20) {\r\n        require(index < swapStorage.pooledTokens.length, \"Out of range\");\r\n        return swapStorage.pooledTokens[index];\r\n    }\r\n\r\n    /**\r\n     * @notice Return the index of the given token address. Reverts if no matching\r\n     * token is found.\r\n     * @param tokenAddress address of the token\r\n     * @return the index of the given token address\r\n     */\r\n    function getTokenIndex(address tokenAddress)\r\n        public\r\n        view\r\n        virtual\r\n        returns (uint8)\r\n    {\r\n        uint8 index = tokenIndexes[tokenAddress];\r\n        require(\r\n            address(getToken(index)) == tokenAddress,\r\n            \"Token does not exist\"\r\n        );\r\n        return index;\r\n    }\r\n\r\n    /**\r\n     * @notice Return current balance of the pooled token at given index\r\n     * @param index the index of the token\r\n     * @return current balance of the pooled token at given index with token's native precision\r\n     */\r\n    function getTokenBalance(uint8 index)\r\n        external\r\n        view\r\n        virtual\r\n        returns (uint256)\r\n    {\r\n        require(index < swapStorage.pooledTokens.length, \"Index out of range\");\r\n        return swapStorage.balances[index];\r\n    }\r\n\r\n    /**\r\n     * @notice Get the virtual price, to help calculate profit\r\n     * @return the virtual price, scaled to the POOL_PRECISION_DECIMALS\r\n     */\r\n    function getVirtualPrice() external view virtual returns (uint256) {\r\n        return swapStorage.getVirtualPrice();\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate amount of tokens you receive on swap\r\n     * @param tokenIndexFrom the token the user wants to sell\r\n     * @param tokenIndexTo the token the user wants to buy\r\n     * @param dx the amount of tokens the user wants to sell. If the token charges\r\n     * a fee on transfers, use the amount that gets transferred after the fee.\r\n     * @return amount of tokens the user will receive\r\n     */\r\n    function calculateSwap(\r\n        uint8 tokenIndexFrom,\r\n        uint8 tokenIndexTo,\r\n        uint256 dx\r\n    ) external view virtual returns (uint256) {\r\n        return swapStorage.calculateSwap(tokenIndexFrom, tokenIndexTo, dx);\r\n    }\r\n\r\n    /**\r\n     * @notice A simple method to calculate prices from deposits or\r\n     * withdrawals, excluding fees but including slippage. This is\r\n     * helpful as an input into the various \"min\" parameters on calls\r\n     * to fight front-running\r\n     *\r\n     * @dev This shouldn't be used outside frontends for user estimates.\r\n     *\r\n     * @param amounts an array of token amounts to deposit or withdrawal,\r\n     * corresponding to pooledTokens. The amount should be in each\r\n     * pooled token's native precision. If a token charges a fee on transfers,\r\n     * use the amount that gets transferred after the fee.\r\n     * @param deposit whether this is a deposit or a withdrawal\r\n     * @return token amount the user will receive\r\n     */\r\n    function calculateTokenAmount(uint256[] calldata amounts, bool deposit)\r\n        external\r\n        view\r\n        virtual\r\n        returns (uint256)\r\n    {\r\n        return swapStorage.calculateTokenAmount(amounts, deposit);\r\n    }\r\n\r\n    /**\r\n     * @notice A simple method to calculate amount of each underlying\r\n     * tokens that is returned upon burning given amount of LP tokens\r\n     * @param amount the amount of LP tokens that would be burned on withdrawal\r\n     * @return array of token balances that the user will receive\r\n     */\r\n    function calculateRemoveLiquidity(uint256 amount)\r\n        external\r\n        view\r\n        virtual\r\n        returns (uint256[] memory)\r\n    {\r\n        return swapStorage.calculateRemoveLiquidity(amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the amount of underlying token available to withdraw\r\n     * when withdrawing via only single token\r\n     * @param tokenAmount the amount of LP token to burn\r\n     * @param tokenIndex index of which token will be withdrawn\r\n     * @return availableTokenAmount calculated amount of underlying token\r\n     * available to withdraw\r\n     */\r\n    function calculateRemoveLiquidityOneToken(\r\n        uint256 tokenAmount,\r\n        uint8 tokenIndex\r\n    ) external view virtual returns (uint256 availableTokenAmount) {\r\n        return swapStorage.calculateWithdrawOneToken(tokenAmount, tokenIndex);\r\n    }\r\n\r\n    /**\r\n     * @notice This function reads the accumulated amount of admin fees of the token with given index\r\n     * @param index Index of the pooled token\r\n     * @return admin's token balance in the token's precision\r\n     */\r\n    function getAdminBalance(uint256 index)\r\n        external\r\n        view\r\n        virtual\r\n        returns (uint256)\r\n    {\r\n        return swapStorage.getAdminBalance(index);\r\n    }\r\n\r\n    /*** STATE MODIFYING FUNCTIONS ***/\r\n\r\n    /**\r\n     * @notice Swap two tokens using this pool\r\n     * @param tokenIndexFrom the token the user wants to swap from\r\n     * @param tokenIndexTo the token the user wants to swap to\r\n     * @param dx the amount of tokens the user wants to swap from\r\n     * @param minDy the min amount the user would like to receive, or revert.\r\n     * @param deadline latest timestamp to accept this transaction\r\n     */\r\n    function swap(\r\n        uint8 tokenIndexFrom,\r\n        uint8 tokenIndexTo,\r\n        uint256 dx,\r\n        uint256 minDy,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        payable\r\n        virtual\r\n        nonReentrant\r\n        whenNotPaused\r\n        deadlineCheck(deadline)\r\n        returns (uint256)\r\n    {\r\n        return swapStorage.swap(tokenIndexFrom, tokenIndexTo, dx, minDy);\r\n    }\r\n\r\n    /**\r\n     * @notice Add liquidity to the pool with the given amounts of tokens\r\n     * @param amounts the amounts of each token to add, in their native precision\r\n     * @param minToMint the minimum LP tokens adding this amount of liquidity\r\n     * should mint, otherwise revert. Handy for front-running mitigation\r\n     * @param deadline latest timestamp to accept this transaction\r\n     * @return amount of LP token user minted and received\r\n     */\r\n    function addLiquidity(\r\n        uint256[] calldata amounts,\r\n        uint256 minToMint,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        payable\r\n        virtual\r\n        nonReentrant\r\n        whenNotPaused\r\n        deadlineCheck(deadline)\r\n        returns (uint256)\r\n    {\r\n        return swapStorage.addLiquidity(amounts, minToMint);\r\n    }\r\n\r\n    /**\r\n     * @notice Burn LP tokens to remove liquidity from the pool. Withdraw fee that decays linearly\r\n     * over period of 4 weeks since last deposit will apply.\r\n     * @dev Liquidity can always be removed, even when the pool is paused.\r\n     * @param amount the amount of LP tokens to burn\r\n     * @param minAmounts the minimum amounts of each token in the pool\r\n     *        acceptable for this burn. Useful as a front-running mitigation\r\n     * @param deadline latest timestamp to accept this transaction\r\n     * @return amounts of tokens user received\r\n     */\r\n    function removeLiquidity(\r\n        uint256 amount,\r\n        uint256[] calldata minAmounts,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        payable\r\n        virtual\r\n        nonReentrant\r\n        deadlineCheck(deadline)\r\n        returns (uint256[] memory)\r\n    {\r\n        return swapStorage.removeLiquidity(amount, minAmounts);\r\n    }\r\n\r\n    /**\r\n     * @notice Remove liquidity from the pool all in one token. Withdraw fee that decays linearly\r\n     * over period of 4 weeks since last deposit will apply.\r\n     * @param tokenAmount the amount of the token you want to receive\r\n     * @param tokenIndex the index of the token you want to receive\r\n     * @param minAmount the minimum amount to withdraw, otherwise revert\r\n     * @param deadline latest timestamp to accept this transaction\r\n     * @return amount of chosen token user received\r\n     */\r\n    function removeLiquidityOneToken(\r\n        uint256 tokenAmount,\r\n        uint8 tokenIndex,\r\n        uint256 minAmount,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        payable\r\n        virtual\r\n        nonReentrant\r\n        whenNotPaused\r\n        deadlineCheck(deadline)\r\n        returns (uint256)\r\n    {\r\n        return\r\n            swapStorage.removeLiquidityOneToken(\r\n                tokenAmount,\r\n                tokenIndex,\r\n                minAmount\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @notice Remove liquidity from the pool, weighted differently than the\r\n     * pool's current balances. Withdraw fee that decays linearly\r\n     * over period of 4 weeks since last deposit will apply.\r\n     * @param amounts how much of each token to withdraw\r\n     * @param maxBurnAmount the max LP token provider is willing to pay to\r\n     * remove liquidity. Useful as a front-running mitigation.\r\n     * @param deadline latest timestamp to accept this transaction\r\n     * @return amount of LP tokens burned\r\n     */\r\n    function removeLiquidityImbalance(\r\n        uint256[] calldata amounts,\r\n        uint256 maxBurnAmount,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        payable\r\n        virtual\r\n        nonReentrant\r\n        whenNotPaused\r\n        deadlineCheck(deadline)\r\n        returns (uint256)\r\n    {\r\n        return swapStorage.removeLiquidityImbalance(amounts, maxBurnAmount);\r\n    }\r\n\r\n    /*** ADMIN FUNCTIONS ***/\r\n\r\n    /**\r\n     * @notice Withdraw all admin fees to the contract owner\r\n     */\r\n    function withdrawAdminFees() external payable virtual onlyOwner {\r\n        swapStorage.withdrawAdminFees(owner());\r\n    }\r\n\r\n    /**\r\n     * @notice Update the admin fee. Admin fee takes portion of the swap fee.\r\n     * @param newAdminFee new admin fee to be applied on future transactions\r\n     */\r\n    function setAdminFee(uint256 newAdminFee) external payable onlyOwner {\r\n        swapStorage.setAdminFee(newAdminFee);\r\n    }\r\n\r\n    /**\r\n     * @notice Update the swap fee to be applied on swaps\r\n     * @param newSwapFee new swap fee to be applied on future transactions\r\n     */\r\n    function setSwapFee(uint256 newSwapFee) external payable onlyOwner {\r\n        swapStorage.setSwapFee(newSwapFee);\r\n    }\r\n\r\n    /**\r\n     * @notice Start ramping up or down A parameter towards given futureA and futureTime\r\n     * Checks if the change is too rapid, and commits the new A value only when it falls under\r\n     * the limit range.\r\n     * @param futureA the new A to ramp towards\r\n     * @param futureTime timestamp when the new A should be reached\r\n     */\r\n    function rampA(uint256 futureA, uint256 futureTime)\r\n        external\r\n        payable\r\n        onlyOwner\r\n    {\r\n        swapStorage.rampA(futureA, futureTime);\r\n    }\r\n\r\n    /**\r\n     * @notice Stop ramping A immediately. Reverts if ramp A is already stopped.\r\n     */\r\n    function stopRampA() external payable onlyOwner {\r\n        swapStorage.stopRampA();\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `master`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address master) internal returns (address instance) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, master))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `master`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `master` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address master, bytes32 salt) internal returns (address instance) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, master))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address master, bytes32 salt, address deployer) internal pure returns (address predicted) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, master))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address master, bytes32 salt) internal view returns (address predicted) {\n        return predictDeterministicAddress(master, salt, address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\nimport \"../proxy/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal initializer {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal initializer {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/OwnerPausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\r\n\r\n/**\r\n * @title OwnerPausable\r\n * @notice An ownable contract allows the owner to pause and unpause the\r\n * contract without a delay.\r\n * @dev Only methods using the provided modifiers will be paused.\r\n */\r\nabstract contract OwnerPausableUpgradeable is\r\n    OwnableUpgradeable,\r\n    PausableUpgradeable\r\n{\r\n    function __OwnerPausable_init() internal initializer {\r\n        __Context_init_unchained();\r\n        __Ownable_init_unchained();\r\n        __Pausable_init_unchained();\r\n    }\r\n\r\n    /**\r\n     * @notice Pause the contract. Revert if already paused.\r\n     */\r\n    function pause() external onlyOwner {\r\n        PausableUpgradeable._pause();\r\n    }\r\n\r\n    /**\r\n     * @notice Unpause the contract. Revert if already unpaused.\r\n     */\r\n    function unpause() external onlyOwner {\r\n        PausableUpgradeable._unpause();\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./ContextUpgradeable.sol\";\nimport \"../proxy/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal initializer {\n        __Context_init_unchained();\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal initializer {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/SwapFlashLoan.sol": {
      "content": "// SPDX-License-Identifier: MIT WITH AGPL-3.0-only\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"./Swap.sol\";\r\nimport \"./interfaces/IFlashLoanReceiver.sol\";\r\n\r\n/**\r\n * @title Swap - A StableSwap implementation in solidity.\r\n * @notice This contract is responsible for custody of closely pegged assets (eg. group of stablecoins)\r\n * and automatic market making system. Users become an LP (Liquidity Provider) by depositing their tokens\r\n * in desired ratios for an exchange of the pool token that represents their share of the pool.\r\n * Users can burn pool tokens and withdraw their share of token(s).\r\n *\r\n * Each time a swap between the pooled tokens happens, a set fee incurs which effectively gets\r\n * distributed to the LPs.\r\n *\r\n * In case of emergencies, admin can pause additional deposits, swaps, or single-asset withdraws - which\r\n * stops the ratio of the tokens in the pool from changing.\r\n * Users can always withdraw their tokens via multi-asset withdraws.\r\n *\r\n * @dev Most of the logic is stored as a library `SwapUtils` for the sake of reducing contract's\r\n * deployment size.\r\n */\r\ncontract SwapFlashLoan is Swap {\r\n    // Total fee that is charged on all flashloans in BPS. Borrowers must repay the amount plus the flash loan fee.\r\n    // This fee is split between the protocol and the pool.\r\n    uint256 public flashLoanFeeBPS;\r\n    // Share of the flash loan fee that goes to the protocol in BPS. A portion of each flash loan fee is allocated\r\n    // to the protocol rather than the pool.\r\n    uint256 public protocolFeeShareBPS;\r\n    // Max BPS for limiting flash loan fee settings.\r\n    uint256 public constant MAX_BPS = 10000;\r\n\r\n    /*** EVENTS ***/\r\n    event FlashLoan(\r\n        address indexed receiver,\r\n        uint8 tokenIndex,\r\n        uint256 amount,\r\n        uint256 amountFee,\r\n        uint256 protocolFee\r\n    );\r\n\r\n    /**\r\n     * @notice Initializes this Swap contract with the given parameters.\r\n     * This will also clone a LPToken contract that represents users'\r\n     * LP positions. The owner of LPToken will be this contract - which means\r\n     * only this contract is allowed to mint/burn tokens.\r\n     *\r\n     * @param _pooledTokens an array of ERC20s this pool will accept\r\n     * @param decimals the decimals to use for each pooled token,\r\n     * eg 8 for WBTC. Cannot be larger than POOL_PRECISION_DECIMALS\r\n     * @param lpTokenName the long-form name of the token to be deployed\r\n     * @param lpTokenSymbol the short symbol for the token to be deployed\r\n     * @param _a the amplification coefficient * n * (n - 1). See the\r\n     * StableSwap paper for details\r\n     * @param _fee default swap fee to be initialized with\r\n     * @param _adminFee default adminFee to be initialized with\r\n     * @param lpTokenTargetAddress the address of an existing LPToken contract to use as a target\r\n     */\r\n    function initialize(\r\n        IERC20[] memory _pooledTokens,\r\n        uint8[] memory decimals,\r\n        string memory lpTokenName,\r\n        string memory lpTokenSymbol,\r\n        uint256 _a,\r\n        uint256 _fee,\r\n        uint256 _adminFee,\r\n        address lpTokenTargetAddress\r\n    ) public payable virtual override initializer {\r\n        Swap.initialize(\r\n            _pooledTokens,\r\n            decimals,\r\n            lpTokenName,\r\n            lpTokenSymbol,\r\n            _a,\r\n            _fee,\r\n            _adminFee,\r\n            lpTokenTargetAddress\r\n        );\r\n        flashLoanFeeBPS = 8; // 8 bps\r\n        protocolFeeShareBPS = 0; // 0 bps\r\n    }\r\n\r\n    /*** STATE MODIFYING FUNCTIONS ***/\r\n\r\n    /**\r\n     * @notice Borrow the specified token from this pool for this transaction only. This function will call\r\n     * `IFlashLoanReceiver(receiver).executeOperation` and the `receiver` must return the full amount of the token\r\n     * and the associated fee by the end of the callback transaction. If the conditions are not met, this call\r\n     * is reverted.\r\n     * @param receiver the address of the receiver of the token. This address must implement the IFlashLoanReceiver\r\n     * interface and the callback function `executeOperation`.\r\n     * @param token the protocol fee in bps to be applied on the total flash loan fee\r\n     * @param amount the total amount to borrow in this transaction\r\n     * @param params optional data to pass along to the callback function\r\n     */\r\n    function flashLoan(\r\n        address receiver,\r\n        IERC20 token,\r\n        uint256 amount,\r\n        bytes memory params\r\n    ) external payable nonReentrant {\r\n        uint8 tokenIndex = getTokenIndex(address(token));\r\n        uint256 availableLiquidityBefore = token.balanceOf(address(this));\r\n        uint256 protocolBalanceBefore = availableLiquidityBefore.sub(\r\n            swapStorage.balances[tokenIndex]\r\n        );\r\n        require(\r\n            amount > 0 && availableLiquidityBefore >= amount,\r\n            \"invalid amount\"\r\n        );\r\n\r\n        // Calculate the additional amount of tokens the pool should end up with\r\n        uint256 amountFee = amount.mul(flashLoanFeeBPS).div(10000);\r\n        // Calculate the portion of the fee that will go to the protocol\r\n        uint256 protocolFee = amountFee.mul(protocolFeeShareBPS).div(10000);\r\n        require(amountFee > 0, \"amount is small for a flashLoan\");\r\n\r\n        // Transfer the requested amount of tokens\r\n        token.safeTransfer(receiver, amount);\r\n\r\n        // Execute callback function on receiver\r\n        IFlashLoanReceiver(receiver).executeOperation(\r\n            address(this),\r\n            address(token),\r\n            amount,\r\n            amountFee,\r\n            params\r\n        );\r\n\r\n        uint256 availableLiquidityAfter = token.balanceOf(address(this));\r\n        require(\r\n            availableLiquidityAfter >= availableLiquidityBefore.add(amountFee),\r\n            \"flashLoan fee is not met\"\r\n        );\r\n\r\n        swapStorage.balances[tokenIndex] = availableLiquidityAfter\r\n            .sub(protocolBalanceBefore)\r\n            .sub(protocolFee);\r\n        emit FlashLoan(receiver, tokenIndex, amount, amountFee, protocolFee);\r\n    }\r\n\r\n    /*** ADMIN FUNCTIONS ***/\r\n\r\n    /**\r\n     * @notice Updates the flash loan fee parameters. This function can only be called by the owner.\r\n     * @param newFlashLoanFeeBPS the total fee in bps to be applied on future flash loans\r\n     * @param newProtocolFeeShareBPS the protocol fee in bps to be applied on the total flash loan fee\r\n     */\r\n    function setFlashLoanFees(\r\n        uint256 newFlashLoanFeeBPS,\r\n        uint256 newProtocolFeeShareBPS\r\n    ) external payable onlyOwner {\r\n        require(\r\n            newFlashLoanFeeBPS > 0 &&\r\n                newFlashLoanFeeBPS <= MAX_BPS &&\r\n                newProtocolFeeShareBPS <= MAX_BPS,\r\n            \"fees are not in valid range\"\r\n        );\r\n        flashLoanFeeBPS = newFlashLoanFeeBPS;\r\n        protocolFeeShareBPS = newProtocolFeeShareBPS;\r\n    }\r\n}\r\n"
    },
    "contracts/interfaces/IFlashLoanReceiver.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\n\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n * @title IFlashLoanReceiver interface\r\n * @notice Interface for the kinesis fee IFlashLoanReceiver. Modified from Aave's IFlashLoanReceiver interface.\r\n * https://github.com/aave/aave-protocol/blob/4b4545fb583fd4f400507b10f3c3114f45b8a037/contracts/flashloan/interfaces/IFlashLoanReceiver.sol\r\n * @author Aave\r\n * @dev implement this interface to develop a flashloan-compatible flashLoanReceiver contract\r\n **/\r\ninterface IFlashLoanReceiver {\r\n    function executeOperation(\r\n        address pool,\r\n        address token,\r\n        uint256 amount,\r\n        uint256 fee,\r\n        bytes calldata params\r\n    ) external;\r\n}\r\n"
    },
    "contracts/SwapFlashLoanV1.sol": {
      "content": "// SPDX-License-Identifier: MIT WITH AGPL-3.0-only\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"./SwapV1.sol\";\r\nimport \"./interfaces/IFlashLoanReceiver.sol\";\r\n\r\n/**\r\n * @title Swap - A StableSwap implementation in solidity.\r\n * @notice This contract is responsible for custody of closely pegged assets (eg. group of stablecoins)\r\n * and automatic market making system. Users become an LP (Liquidity Provider) by depositing their tokens\r\n * in desired ratios for an exchange of the pool token that represents their share of the pool.\r\n * Users can burn pool tokens and withdraw their share of token(s).\r\n *\r\n * Each time a swap between the pooled tokens happens, a set fee incurs which effectively gets\r\n * distributed to the LPs.\r\n *\r\n * In case of emergencies, admin can pause additional deposits, swaps, or single-asset withdraws - which\r\n * stops the ratio of the tokens in the pool from changing.\r\n * Users can always withdraw their tokens via multi-asset withdraws.\r\n *\r\n * @dev Most of the logic is stored as a library `SwapUtils` for the sake of reducing contract's\r\n * deployment size.\r\n */\r\ncontract SwapFlashLoanV1 is SwapV1 {\r\n    // Total fee that is charged on all flashloans in BPS. Borrowers must repay the amount plus the flash loan fee.\r\n    // This fee is split between the protocol and the pool.\r\n    uint256 public flashLoanFeeBPS;\r\n    // Share of the flash loan fee that goes to the protocol in BPS. A portion of each flash loan fee is allocated\r\n    // to the protocol rather than the pool.\r\n    uint256 public protocolFeeShareBPS;\r\n    // Max BPS for limiting flash loan fee settings.\r\n    uint256 public constant MAX_BPS = 10000;\r\n\r\n    /*** EVENTS ***/\r\n    event FlashLoan(\r\n        address indexed receiver,\r\n        uint8 tokenIndex,\r\n        uint256 amount,\r\n        uint256 amountFee,\r\n        uint256 protocolFee\r\n    );\r\n\r\n    /**\r\n     * @notice Initializes this Swap contract with the given parameters.\r\n     * This will also clone a LPToken contract that represents users'\r\n     * LP positions. The owner of LPToken will be this contract - which means\r\n     * only this contract is allowed to mint/burn tokens.\r\n     *\r\n     * @param _pooledTokens an array of ERC20s this pool will accept\r\n     * @param decimals the decimals to use for each pooled token,\r\n     * eg 8 for WBTC. Cannot be larger than POOL_PRECISION_DECIMALS\r\n     * @param lpTokenName the long-form name of the token to be deployed\r\n     * @param lpTokenSymbol the short symbol for the token to be deployed\r\n     * @param _a the amplification coefficient * n * (n - 1). See the\r\n     * StableSwap paper for details\r\n     * @param _fee default swap fee to be initialized with\r\n     * @param _adminFee default adminFee to be initialized with\r\n     * @param _withdrawFee default withdrawFee to be initialized with\r\n     * @param lpTokenTargetAddress the address of an existing LPToken contract to use as a target\r\n     */\r\n    function initialize(\r\n        IERC20[] memory _pooledTokens,\r\n        uint8[] memory decimals,\r\n        string memory lpTokenName,\r\n        string memory lpTokenSymbol,\r\n        uint256 _a,\r\n        uint256 _fee,\r\n        uint256 _adminFee,\r\n        uint256 _withdrawFee,\r\n        address lpTokenTargetAddress\r\n    ) public virtual override initializer {\r\n        SwapV1.initialize(\r\n            _pooledTokens,\r\n            decimals,\r\n            lpTokenName,\r\n            lpTokenSymbol,\r\n            _a,\r\n            _fee,\r\n            _adminFee,\r\n            _withdrawFee,\r\n            lpTokenTargetAddress\r\n        );\r\n        flashLoanFeeBPS = 8; // 8 bps\r\n        protocolFeeShareBPS = 0; // 0 bps\r\n    }\r\n\r\n    /*** STATE MODIFYING FUNCTIONS ***/\r\n\r\n    /**\r\n     * @notice Borrow the specified token from this pool for this transaction only. This function will call\r\n     * `IFlashLoanReceiver(receiver).executeOperation` and the `receiver` must return the full amount of the token\r\n     * and the associated fee by the end of the callback transaction. If the conditions are not met, this call\r\n     * is reverted.\r\n     * @param receiver the address of the receiver of the token. This address must implement the IFlashLoanReceiver\r\n     * interface and the callback function `executeOperation`.\r\n     * @param token the protocol fee in bps to be applied on the total flash loan fee\r\n     * @param amount the total amount to borrow in this transaction\r\n     * @param params optional data to pass along to the callback function\r\n     */\r\n    function flashLoan(\r\n        address receiver,\r\n        IERC20 token,\r\n        uint256 amount,\r\n        bytes memory params\r\n    ) external nonReentrant {\r\n        uint8 tokenIndex = getTokenIndex(address(token));\r\n        uint256 availableLiquidityBefore = token.balanceOf(address(this));\r\n        uint256 protocolBalanceBefore = availableLiquidityBefore.sub(\r\n            swapStorage.balances[tokenIndex]\r\n        );\r\n        require(\r\n            amount > 0 && availableLiquidityBefore >= amount,\r\n            \"invalid amount\"\r\n        );\r\n\r\n        // Calculate the additional amount of tokens the pool should end up with\r\n        uint256 amountFee = amount.mul(flashLoanFeeBPS).div(10000);\r\n        // Calculate the portion of the fee that will go to the protocol\r\n        uint256 protocolFee = amountFee.mul(protocolFeeShareBPS).div(10000);\r\n        require(amountFee > 0, \"amount is small for a flashLoan\");\r\n\r\n        // Transfer the requested amount of tokens\r\n        token.safeTransfer(receiver, amount);\r\n\r\n        // Execute callback function on receiver\r\n        IFlashLoanReceiver(receiver).executeOperation(\r\n            address(this),\r\n            address(token),\r\n            amount,\r\n            amountFee,\r\n            params\r\n        );\r\n\r\n        uint256 availableLiquidityAfter = token.balanceOf(address(this));\r\n        require(\r\n            availableLiquidityAfter >= availableLiquidityBefore.add(amountFee),\r\n            \"flashLoan fee is not met\"\r\n        );\r\n\r\n        swapStorage.balances[tokenIndex] = availableLiquidityAfter\r\n            .sub(protocolBalanceBefore)\r\n            .sub(protocolFee);\r\n        emit FlashLoan(receiver, tokenIndex, amount, amountFee, protocolFee);\r\n    }\r\n\r\n    /*** ADMIN FUNCTIONS ***/\r\n\r\n    /**\r\n     * @notice Updates the flash loan fee parameters. This function can only be called by the owner.\r\n     * @param newFlashLoanFeeBPS the total fee in bps to be applied on future flash loans\r\n     * @param newProtocolFeeShareBPS the protocol fee in bps to be applied on the total flash loan fee\r\n     */\r\n    function setFlashLoanFees(\r\n        uint256 newFlashLoanFeeBPS,\r\n        uint256 newProtocolFeeShareBPS\r\n    ) external onlyOwner {\r\n        require(\r\n            newFlashLoanFeeBPS > 0 &&\r\n                newFlashLoanFeeBPS <= MAX_BPS &&\r\n                newProtocolFeeShareBPS <= MAX_BPS,\r\n            \"fees are not in valid range\"\r\n        );\r\n        flashLoanFeeBPS = newFlashLoanFeeBPS;\r\n        protocolFeeShareBPS = newProtocolFeeShareBPS;\r\n    }\r\n}\r\n"
    },
    "contracts/SwapV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\r\nimport \"./OwnerPausableUpgradeable.sol\";\r\nimport \"./SwapUtilsV1.sol\";\r\nimport \"./AmplificationUtilsV1.sol\";\r\n\r\n/**\r\n * @title Swap - A StableSwap implementation in solidity.\r\n * @notice This contract is responsible for custody of closely pegged assets (eg. group of stablecoins)\r\n * and automatic market making system. Users become an LP (Liquidity Provider) by depositing their tokens\r\n * in desired ratios for an exchange of the pool token that represents their share of the pool.\r\n * Users can burn pool tokens and withdraw their share of token(s).\r\n *\r\n * Each time a swap between the pooled tokens happens, a set fee incurs which effectively gets\r\n * distributed to the LPs.\r\n *\r\n * In case of emergencies, admin can pause additional deposits, swaps, or single-asset withdraws - which\r\n * stops the ratio of the tokens in the pool from changing.\r\n * Users can always withdraw their tokens via multi-asset withdraws.\r\n *\r\n * @dev Most of the logic is stored as a library `SwapUtils` for the sake of reducing contract's\r\n * deployment size.\r\n */\r\ncontract SwapV1 is OwnerPausableUpgradeable, ReentrancyGuardUpgradeable {\r\n    using SafeERC20 for IERC20;\r\n    using SafeMath for uint256;\r\n    using SwapUtilsV1 for SwapUtilsV1.Swap;\r\n    using AmplificationUtilsV1 for SwapUtilsV1.Swap;\r\n\r\n    // Struct storing data responsible for automatic market maker functionalities. In order to\r\n    // access this data, this contract uses SwapUtils library. For more details, see SwapUtilsV1.sol\r\n    SwapUtilsV1.Swap public swapStorage;\r\n\r\n    // Maps token address to an index in the pool. Used to prevent duplicate tokens in the pool.\r\n    // getTokenIndex function also relies on this mapping to retrieve token index.\r\n    mapping(address => uint8) private tokenIndexes;\r\n\r\n    /*** EVENTS ***/\r\n\r\n    // events replicated from SwapUtils to make the ABI easier for dumb\r\n    // clients\r\n    event TokenSwap(\r\n        address indexed buyer,\r\n        uint256 tokensSold,\r\n        uint256 tokensBought,\r\n        uint128 soldId,\r\n        uint128 boughtId\r\n    );\r\n    event AddLiquidity(\r\n        address indexed provider,\r\n        uint256[] tokenAmounts,\r\n        uint256[] fees,\r\n        uint256 invariant,\r\n        uint256 lpTokenSupply\r\n    );\r\n    event RemoveLiquidity(\r\n        address indexed provider,\r\n        uint256[] tokenAmounts,\r\n        uint256 lpTokenSupply\r\n    );\r\n    event RemoveLiquidityOne(\r\n        address indexed provider,\r\n        uint256 lpTokenAmount,\r\n        uint256 lpTokenSupply,\r\n        uint256 boughtId,\r\n        uint256 tokensBought\r\n    );\r\n    event RemoveLiquidityImbalance(\r\n        address indexed provider,\r\n        uint256[] tokenAmounts,\r\n        uint256[] fees,\r\n        uint256 invariant,\r\n        uint256 lpTokenSupply\r\n    );\r\n    event NewAdminFee(uint256 newAdminFee);\r\n    event NewSwapFee(uint256 newSwapFee);\r\n    event NewWithdrawFee(uint256 newWithdrawFee);\r\n    event RampA(\r\n        uint256 oldA,\r\n        uint256 newA,\r\n        uint256 initialTime,\r\n        uint256 futureTime\r\n    );\r\n    event StopRampA(uint256 currentA, uint256 time);\r\n\r\n    /**\r\n     * @notice Initializes this Swap contract with the given parameters.\r\n     * This will also clone a LPToken contract that represents users'\r\n     * LP positions. The owner of LPToken will be this contract - which means\r\n     * only this contract is allowed to mint/burn tokens.\r\n     *\r\n     * @param _pooledTokens an array of ERC20s this pool will accept\r\n     * @param decimals the decimals to use for each pooled token,\r\n     * eg 8 for WBTC. Cannot be larger than POOL_PRECISION_DECIMALS\r\n     * @param lpTokenName the long-form name of the token to be deployed\r\n     * @param lpTokenSymbol the short symbol for the token to be deployed\r\n     * @param _a the amplification coefficient * n * (n - 1). See the\r\n     * StableSwap paper for details\r\n     * @param _fee default swap fee to be initialized with\r\n     * @param _adminFee default adminFee to be initialized with\r\n     * @param _withdrawFee default withdrawFee to be initialized with\r\n     * @param lpTokenTargetAddress the address of an existing LPToken contract to use as a target\r\n     */\r\n    function initialize(\r\n        IERC20[] memory _pooledTokens,\r\n        uint8[] memory decimals,\r\n        string memory lpTokenName,\r\n        string memory lpTokenSymbol,\r\n        uint256 _a,\r\n        uint256 _fee,\r\n        uint256 _adminFee,\r\n        uint256 _withdrawFee,\r\n        address lpTokenTargetAddress\r\n    ) public virtual initializer {\r\n        __OwnerPausable_init();\r\n        __ReentrancyGuard_init();\r\n        // Check _pooledTokens and precisions parameter\r\n        require(_pooledTokens.length > 1, \"_pooledTokens.length <= 1\");\r\n        require(_pooledTokens.length <= 32, \"_pooledTokens.length > 32\");\r\n        require(\r\n            _pooledTokens.length == decimals.length,\r\n            \"_pooledTokens decimals mismatch\"\r\n        );\r\n\r\n        uint256[] memory precisionMultipliers = new uint256[](decimals.length);\r\n\r\n        for (uint8 i = 0; i < _pooledTokens.length; i++) {\r\n            if (i > 0) {\r\n                // Check if index is already used. Check if 0th element is a duplicate.\r\n                require(\r\n                    tokenIndexes[address(_pooledTokens[i])] == 0 &&\r\n                        _pooledTokens[0] != _pooledTokens[i],\r\n                    \"Duplicate tokens\"\r\n                );\r\n            }\r\n            require(\r\n                address(_pooledTokens[i]) != address(0),\r\n                \"The 0 address isn't an ERC-20\"\r\n            );\r\n            require(\r\n                decimals[i] <= SwapUtilsV1.POOL_PRECISION_DECIMALS,\r\n                \"Token decimals exceeds max\"\r\n            );\r\n            precisionMultipliers[i] =\r\n                10 **\r\n                    uint256(SwapUtilsV1.POOL_PRECISION_DECIMALS).sub(\r\n                        uint256(decimals[i])\r\n                    );\r\n            tokenIndexes[address(_pooledTokens[i])] = i;\r\n        }\r\n\r\n        // Check _a, _fee, _adminFee, _withdrawFee parameters\r\n        require(_a < AmplificationUtilsV1.MAX_A, \"_a exceeds maximum\");\r\n        require(_fee < SwapUtilsV1.MAX_SWAP_FEE, \"_fee exceeds maximum\");\r\n        require(\r\n            _adminFee < SwapUtilsV1.MAX_ADMIN_FEE,\r\n            \"_adminFee exceeds maximum\"\r\n        );\r\n        require(\r\n            _withdrawFee < SwapUtilsV1.MAX_WITHDRAW_FEE,\r\n            \"_withdrawFee exceeds maximum\"\r\n        );\r\n\r\n        // Clone and initialize a LPToken contract\r\n        LPToken lpToken = LPToken(Clones.clone(lpTokenTargetAddress));\r\n        require(\r\n            lpToken.initialize(lpTokenName, lpTokenSymbol),\r\n            \"could not init lpToken clone\"\r\n        );\r\n\r\n        // Initialize swapStorage struct\r\n        swapStorage.lpToken = lpToken;\r\n        swapStorage.pooledTokens = _pooledTokens;\r\n        swapStorage.tokenPrecisionMultipliers = precisionMultipliers;\r\n        swapStorage.balances = new uint256[](_pooledTokens.length);\r\n        swapStorage.initialA = _a.mul(AmplificationUtilsV1.A_PRECISION);\r\n        swapStorage.futureA = _a.mul(AmplificationUtilsV1.A_PRECISION);\r\n        // swapStorage.initialATime = 0;\r\n        // swapStorage.futureATime = 0;\r\n        swapStorage.swapFee = _fee;\r\n        swapStorage.adminFee = _adminFee;\r\n        swapStorage.defaultWithdrawFee = _withdrawFee;\r\n    }\r\n\r\n    /*** MODIFIERS ***/\r\n\r\n    /**\r\n     * @notice Modifier to check deadline against current timestamp\r\n     * @param deadline latest timestamp to accept this transaction\r\n     */\r\n    modifier deadlineCheck(uint256 deadline) {\r\n        require(block.timestamp <= deadline, \"Deadline not met\");\r\n        _;\r\n    }\r\n\r\n    /*** VIEW FUNCTIONS ***/\r\n\r\n    /**\r\n     * @notice Return A, the amplification coefficient * n * (n - 1)\r\n     * @dev See the StableSwap paper for details\r\n     * @return A parameter\r\n     */\r\n    function getA() external view virtual returns (uint256) {\r\n        return swapStorage.getA();\r\n    }\r\n\r\n    /**\r\n     * @notice Return A in its raw precision form\r\n     * @dev See the StableSwap paper for details\r\n     * @return A parameter in its raw precision form\r\n     */\r\n    function getAPrecise() external view virtual returns (uint256) {\r\n        return swapStorage.getAPrecise();\r\n    }\r\n\r\n    /**\r\n     * @notice Return address of the pooled token at given index. Reverts if tokenIndex is out of range.\r\n     * @param index the index of the token\r\n     * @return address of the token at given index\r\n     */\r\n    function getToken(uint8 index) public view virtual returns (IERC20) {\r\n        require(index < swapStorage.pooledTokens.length, \"Out of range\");\r\n        return swapStorage.pooledTokens[index];\r\n    }\r\n\r\n    /**\r\n     * @notice Return the index of the given token address. Reverts if no matching\r\n     * token is found.\r\n     * @param tokenAddress address of the token\r\n     * @return the index of the given token address\r\n     */\r\n    function getTokenIndex(address tokenAddress)\r\n        public\r\n        view\r\n        virtual\r\n        returns (uint8)\r\n    {\r\n        uint8 index = tokenIndexes[tokenAddress];\r\n        require(\r\n            address(getToken(index)) == tokenAddress,\r\n            \"Token does not exist\"\r\n        );\r\n        return index;\r\n    }\r\n\r\n    /**\r\n     * @notice Return timestamp of last deposit of given address\r\n     * @return timestamp of the last deposit made by the given address\r\n     */\r\n    function getDepositTimestamp(address user)\r\n        external\r\n        view\r\n        virtual\r\n        returns (uint256)\r\n    {\r\n        return swapStorage.getDepositTimestamp(user);\r\n    }\r\n\r\n    /**\r\n     * @notice Return current balance of the pooled token at given index\r\n     * @param index the index of the token\r\n     * @return current balance of the pooled token at given index with token's native precision\r\n     */\r\n    function getTokenBalance(uint8 index)\r\n        external\r\n        view\r\n        virtual\r\n        returns (uint256)\r\n    {\r\n        require(index < swapStorage.pooledTokens.length, \"Index out of range\");\r\n        return swapStorage.balances[index];\r\n    }\r\n\r\n    /**\r\n     * @notice Get the virtual price, to help calculate profit\r\n     * @return the virtual price, scaled to the POOL_PRECISION_DECIMALS\r\n     */\r\n    function getVirtualPrice() external view virtual returns (uint256) {\r\n        return swapStorage.getVirtualPrice();\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate amount of tokens you receive on swap\r\n     * @param tokenIndexFrom the token the user wants to sell\r\n     * @param tokenIndexTo the token the user wants to buy\r\n     * @param dx the amount of tokens the user wants to sell. If the token charges\r\n     * a fee on transfers, use the amount that gets transferred after the fee.\r\n     * @return amount of tokens the user will receive\r\n     */\r\n    function calculateSwap(\r\n        uint8 tokenIndexFrom,\r\n        uint8 tokenIndexTo,\r\n        uint256 dx\r\n    ) external view virtual returns (uint256) {\r\n        return swapStorage.calculateSwap(tokenIndexFrom, tokenIndexTo, dx);\r\n    }\r\n\r\n    /**\r\n     * @notice A simple method to calculate prices from deposits or\r\n     * withdrawals, excluding fees but including slippage. This is\r\n     * helpful as an input into the various \"min\" parameters on calls\r\n     * to fight front-running\r\n     *\r\n     * @dev This shouldn't be used outside frontends for user estimates.\r\n     *\r\n     * @param account address that is depositing or withdrawing tokens\r\n     * @param amounts an array of token amounts to deposit or withdrawal,\r\n     * corresponding to pooledTokens. The amount should be in each\r\n     * pooled token's native precision. If a token charges a fee on transfers,\r\n     * use the amount that gets transferred after the fee.\r\n     * @param deposit whether this is a deposit or a withdrawal\r\n     * @return token amount the user will receive\r\n     */\r\n    function calculateTokenAmount(\r\n        address account,\r\n        uint256[] calldata amounts,\r\n        bool deposit\r\n    ) external view virtual returns (uint256) {\r\n        return swapStorage.calculateTokenAmount(account, amounts, deposit);\r\n    }\r\n\r\n    /**\r\n     * @notice A simple method to calculate amount of each underlying\r\n     * tokens that is returned upon burning given amount of LP tokens\r\n     * @param account the address that is withdrawing tokens\r\n     * @param amount the amount of LP tokens that would be burned on withdrawal\r\n     * @return array of token balances that the user will receive\r\n     */\r\n    function calculateRemoveLiquidity(address account, uint256 amount)\r\n        external\r\n        view\r\n        virtual\r\n        returns (uint256[] memory)\r\n    {\r\n        return swapStorage.calculateRemoveLiquidity(account, amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the amount of underlying token available to withdraw\r\n     * when withdrawing via only single token\r\n     * @param account the address that is withdrawing tokens\r\n     * @param tokenAmount the amount of LP token to burn\r\n     * @param tokenIndex index of which token will be withdrawn\r\n     * @return availableTokenAmount calculated amount of underlying token\r\n     * available to withdraw\r\n     */\r\n    function calculateRemoveLiquidityOneToken(\r\n        address account,\r\n        uint256 tokenAmount,\r\n        uint8 tokenIndex\r\n    ) external view virtual returns (uint256 availableTokenAmount) {\r\n        return\r\n            swapStorage.calculateWithdrawOneToken(\r\n                account,\r\n                tokenAmount,\r\n                tokenIndex\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the fee that is applied when the given user withdraws. The withdraw fee\r\n     * decays linearly over period of 4 weeks. For example, depositing and withdrawing right away\r\n     * will charge you the full amount of withdraw fee. But withdrawing after 4 weeks will charge you\r\n     * no additional fees.\r\n     * @dev returned value should be divided by FEE_DENOMINATOR to convert to correct decimals\r\n     * @param user address you want to calculate withdraw fee of\r\n     * @return current withdraw fee of the user\r\n     */\r\n    function calculateCurrentWithdrawFee(address user)\r\n        external\r\n        view\r\n        virtual\r\n        returns (uint256)\r\n    {\r\n        return swapStorage.calculateCurrentWithdrawFee(user);\r\n    }\r\n\r\n    /**\r\n     * @notice This function reads the accumulated amount of admin fees of the token with given index\r\n     * @param index Index of the pooled token\r\n     * @return admin's token balance in the token's precision\r\n     */\r\n    function getAdminBalance(uint256 index)\r\n        external\r\n        view\r\n        virtual\r\n        returns (uint256)\r\n    {\r\n        return swapStorage.getAdminBalance(index);\r\n    }\r\n\r\n    /*** STATE MODIFYING FUNCTIONS ***/\r\n\r\n    /**\r\n     * @notice Swap two tokens using this pool\r\n     * @param tokenIndexFrom the token the user wants to swap from\r\n     * @param tokenIndexTo the token the user wants to swap to\r\n     * @param dx the amount of tokens the user wants to swap from\r\n     * @param minDy the min amount the user would like to receive, or revert.\r\n     * @param deadline latest timestamp to accept this transaction\r\n     */\r\n    function swap(\r\n        uint8 tokenIndexFrom,\r\n        uint8 tokenIndexTo,\r\n        uint256 dx,\r\n        uint256 minDy,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        virtual\r\n        nonReentrant\r\n        whenNotPaused\r\n        deadlineCheck(deadline)\r\n        returns (uint256)\r\n    {\r\n        return swapStorage.swap(tokenIndexFrom, tokenIndexTo, dx, minDy);\r\n    }\r\n\r\n    /**\r\n     * @notice Add liquidity to the pool with the given amounts of tokens\r\n     * @param amounts the amounts of each token to add, in their native precision\r\n     * @param minToMint the minimum LP tokens adding this amount of liquidity\r\n     * should mint, otherwise revert. Handy for front-running mitigation\r\n     * @param deadline latest timestamp to accept this transaction\r\n     * @return amount of LP token user minted and received\r\n     */\r\n    function addLiquidity(\r\n        uint256[] calldata amounts,\r\n        uint256 minToMint,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        virtual\r\n        nonReentrant\r\n        whenNotPaused\r\n        deadlineCheck(deadline)\r\n        returns (uint256)\r\n    {\r\n        return swapStorage.addLiquidity(amounts, minToMint);\r\n    }\r\n\r\n    /**\r\n     * @notice Burn LP tokens to remove liquidity from the pool. Withdraw fee that decays linearly\r\n     * over period of 4 weeks since last deposit will apply.\r\n     * @dev Liquidity can always be removed, even when the pool is paused.\r\n     * @param amount the amount of LP tokens to burn\r\n     * @param minAmounts the minimum amounts of each token in the pool\r\n     *        acceptable for this burn. Useful as a front-running mitigation\r\n     * @param deadline latest timestamp to accept this transaction\r\n     * @return amounts of tokens user received\r\n     */\r\n    function removeLiquidity(\r\n        uint256 amount,\r\n        uint256[] calldata minAmounts,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        virtual\r\n        nonReentrant\r\n        deadlineCheck(deadline)\r\n        returns (uint256[] memory)\r\n    {\r\n        return swapStorage.removeLiquidity(amount, minAmounts);\r\n    }\r\n\r\n    /**\r\n     * @notice Remove liquidity from the pool all in one token. Withdraw fee that decays linearly\r\n     * over period of 4 weeks since last deposit will apply.\r\n     * @param tokenAmount the amount of the token you want to receive\r\n     * @param tokenIndex the index of the token you want to receive\r\n     * @param minAmount the minimum amount to withdraw, otherwise revert\r\n     * @param deadline latest timestamp to accept this transaction\r\n     * @return amount of chosen token user received\r\n     */\r\n    function removeLiquidityOneToken(\r\n        uint256 tokenAmount,\r\n        uint8 tokenIndex,\r\n        uint256 minAmount,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        virtual\r\n        nonReentrant\r\n        whenNotPaused\r\n        deadlineCheck(deadline)\r\n        returns (uint256)\r\n    {\r\n        return\r\n            swapStorage.removeLiquidityOneToken(\r\n                tokenAmount,\r\n                tokenIndex,\r\n                minAmount\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @notice Remove liquidity from the pool, weighted differently than the\r\n     * pool's current balances. Withdraw fee that decays linearly\r\n     * over period of 4 weeks since last deposit will apply.\r\n     * @param amounts how much of each token to withdraw\r\n     * @param maxBurnAmount the max LP token provider is willing to pay to\r\n     * remove liquidity. Useful as a front-running mitigation.\r\n     * @param deadline latest timestamp to accept this transaction\r\n     * @return amount of LP tokens burned\r\n     */\r\n    function removeLiquidityImbalance(\r\n        uint256[] calldata amounts,\r\n        uint256 maxBurnAmount,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        virtual\r\n        nonReentrant\r\n        whenNotPaused\r\n        deadlineCheck(deadline)\r\n        returns (uint256)\r\n    {\r\n        return swapStorage.removeLiquidityImbalance(amounts, maxBurnAmount);\r\n    }\r\n\r\n    /*** ADMIN FUNCTIONS ***/\r\n\r\n    /**\r\n     * @notice Updates the user withdraw fee. This function can only be called by\r\n     * the pool token. Should be used to update the withdraw fee on transfer of pool tokens.\r\n     * Transferring your pool token will reset the 4 weeks period. If the recipient is already\r\n     * holding some pool tokens, the withdraw fee will be discounted in respective amounts.\r\n     * @param recipient address of the recipient of pool token\r\n     * @param transferAmount amount of pool token to transfer\r\n     */\r\n    function updateUserWithdrawFee(address recipient, uint256 transferAmount)\r\n        external\r\n    {\r\n        require(\r\n            msg.sender == address(swapStorage.lpToken),\r\n            \"Only callable by pool token\"\r\n        );\r\n        swapStorage.updateUserWithdrawFee(recipient, transferAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraw all admin fees to the contract owner\r\n     */\r\n    function withdrawAdminFees() external onlyOwner {\r\n        swapStorage.withdrawAdminFees(owner());\r\n    }\r\n\r\n    /**\r\n     * @notice Update the admin fee. Admin fee takes portion of the swap fee.\r\n     * @param newAdminFee new admin fee to be applied on future transactions\r\n     */\r\n    function setAdminFee(uint256 newAdminFee) external onlyOwner {\r\n        swapStorage.setAdminFee(newAdminFee);\r\n    }\r\n\r\n    /**\r\n     * @notice Update the swap fee to be applied on swaps\r\n     * @param newSwapFee new swap fee to be applied on future transactions\r\n     */\r\n    function setSwapFee(uint256 newSwapFee) external onlyOwner {\r\n        swapStorage.setSwapFee(newSwapFee);\r\n    }\r\n\r\n    /**\r\n     * @notice Update the withdraw fee. This fee decays linearly over 4 weeks since\r\n     * user's last deposit.\r\n     * @param newWithdrawFee new withdraw fee to be applied on future deposits\r\n     */\r\n    function setDefaultWithdrawFee(uint256 newWithdrawFee) external onlyOwner {\r\n        swapStorage.setDefaultWithdrawFee(newWithdrawFee);\r\n    }\r\n\r\n    /**\r\n     * @notice Start ramping up or down A parameter towards given futureA and futureTime\r\n     * Checks if the change is too rapid, and commits the new A value only when it falls under\r\n     * the limit range.\r\n     * @param futureA the new A to ramp towards\r\n     * @param futureTime timestamp when the new A should be reached\r\n     */\r\n    function rampA(uint256 futureA, uint256 futureTime) external onlyOwner {\r\n        swapStorage.rampA(futureA, futureTime);\r\n    }\r\n\r\n    /**\r\n     * @notice Stop ramping A immediately. Reverts if ramp A is already stopped.\r\n     */\r\n    function stopRampA() external onlyOwner {\r\n        swapStorage.stopRampA();\r\n    }\r\n}\r\n"
    },
    "contracts/SwapUtilsV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\r\nimport \"./AmplificationUtilsV1.sol\";\r\nimport \"./LPToken.sol\";\r\nimport \"./MathUtils.sol\";\r\n\r\n/**\r\n * @title SwapUtils library\r\n * @notice A library to be used within Swap.sol. Contains functions responsible for custody and AMM functionalities.\r\n * @dev Contracts relying on this library must initialize SwapUtils.Swap struct then use this library\r\n * for SwapUtils.Swap struct. Note that this library contains both functions called by users and admins.\r\n * Admin functions should be protected within contracts using this library.\r\n */\r\nlibrary SwapUtilsV1 {\r\n    using SafeERC20 for IERC20;\r\n    using SafeMath for uint256;\r\n    using MathUtils for uint256;\r\n\r\n    /*** EVENTS ***/\r\n\r\n    event TokenSwap(\r\n        address indexed buyer,\r\n        uint256 tokensSold,\r\n        uint256 tokensBought,\r\n        uint128 soldId,\r\n        uint128 boughtId\r\n    );\r\n    event AddLiquidity(\r\n        address indexed provider,\r\n        uint256[] tokenAmounts,\r\n        uint256[] fees,\r\n        uint256 invariant,\r\n        uint256 lpTokenSupply\r\n    );\r\n    event RemoveLiquidity(\r\n        address indexed provider,\r\n        uint256[] tokenAmounts,\r\n        uint256 lpTokenSupply\r\n    );\r\n    event RemoveLiquidityOne(\r\n        address indexed provider,\r\n        uint256 lpTokenAmount,\r\n        uint256 lpTokenSupply,\r\n        uint256 boughtId,\r\n        uint256 tokensBought\r\n    );\r\n    event RemoveLiquidityImbalance(\r\n        address indexed provider,\r\n        uint256[] tokenAmounts,\r\n        uint256[] fees,\r\n        uint256 invariant,\r\n        uint256 lpTokenSupply\r\n    );\r\n    event NewAdminFee(uint256 newAdminFee);\r\n    event NewSwapFee(uint256 newSwapFee);\r\n    event NewWithdrawFee(uint256 newWithdrawFee);\r\n\r\n    struct Swap {\r\n        // variables around the ramp management of A,\r\n        // the amplification coefficient * n * (n - 1)\r\n        // see https://www.curve.fi/stableswap-paper.pdf for details\r\n        uint256 initialA;\r\n        uint256 futureA;\r\n        uint256 initialATime;\r\n        uint256 futureATime;\r\n        // fee calculation\r\n        uint256 swapFee;\r\n        uint256 adminFee;\r\n        uint256 defaultWithdrawFee;\r\n        LPToken lpToken;\r\n        // contract references for all tokens being pooled\r\n        IERC20[] pooledTokens;\r\n        // multipliers for each pooled token's precision to get to POOL_PRECISION_DECIMALS\r\n        // for example, TBTC has 18 decimals, so the multiplier should be 1. WBTC\r\n        // has 8, so the multiplier should be 10 ** 18 / 10 ** 8 => 10 ** 10\r\n        uint256[] tokenPrecisionMultipliers;\r\n        // the pool balance of each token, in the token's precision\r\n        // the contract's actual token balance might differ\r\n        uint256[] balances;\r\n        mapping(address => uint256) depositTimestamp;\r\n        mapping(address => uint256) withdrawFeeMultiplier;\r\n    }\r\n\r\n    // Struct storing variables used in calculations in the\r\n    // calculateWithdrawOneTokenDY function to avoid stack too deep errors\r\n    struct CalculateWithdrawOneTokenDYInfo {\r\n        uint256 d0;\r\n        uint256 d1;\r\n        uint256 newY;\r\n        uint256 feePerToken;\r\n        uint256 preciseA;\r\n    }\r\n\r\n    // Struct storing variables used in calculations in the\r\n    // {add,remove}Liquidity functions to avoid stack too deep errors\r\n    struct ManageLiquidityInfo {\r\n        uint256 d0;\r\n        uint256 d1;\r\n        uint256 d2;\r\n        uint256 preciseA;\r\n        LPToken lpToken;\r\n        uint256 totalSupply;\r\n        uint256[] balances;\r\n        uint256[] multipliers;\r\n    }\r\n\r\n    // the precision all pools tokens will be converted to\r\n    uint8 public constant POOL_PRECISION_DECIMALS = 18;\r\n\r\n    // the denominator used to calculate admin and LP fees. For example, an\r\n    // LP fee might be something like tradeAmount.mul(fee).div(FEE_DENOMINATOR)\r\n    uint256 private constant FEE_DENOMINATOR = 10**10;\r\n\r\n    // Max swap fee is 1% or 100bps of each swap\r\n    uint256 public constant MAX_SWAP_FEE = 10**8;\r\n\r\n    // Max adminFee is 100% of the swapFee\r\n    // adminFee does not add additional fee on top of swapFee\r\n    // Instead it takes a certain % of the swapFee. Therefore it has no impact on the\r\n    // users but only on the earnings of LPs\r\n    uint256 public constant MAX_ADMIN_FEE = 10**10;\r\n\r\n    // Max withdrawFee is 1% of the value withdrawn\r\n    // Fee will be redistributed to the LPs in the pool, rewarding\r\n    // long term providers.\r\n    uint256 public constant MAX_WITHDRAW_FEE = 10**8;\r\n\r\n    // Constant value used as max loop limit\r\n    uint256 private constant MAX_LOOP_LIMIT = 256;\r\n\r\n    // Time that it should take for the withdraw fee to fully decay to 0\r\n    uint256 public constant WITHDRAW_FEE_DECAY_TIME = 4 weeks;\r\n\r\n    /*** VIEW & PURE FUNCTIONS ***/\r\n\r\n    /**\r\n     * @notice Retrieves the timestamp of last deposit made by the given address\r\n     * @param self Swap struct to read from\r\n     * @return timestamp of last deposit\r\n     */\r\n    function getDepositTimestamp(Swap storage self, address user)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return self.depositTimestamp[user];\r\n    }\r\n\r\n    function _getAPrecise(Swap storage self) internal view returns (uint256) {\r\n        return AmplificationUtilsV1._getAPrecise(self);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the dy, the amount of selected token that user receives and\r\n     * the fee of withdrawing in one token\r\n     * @param account the address that is withdrawing\r\n     * @param tokenAmount the amount to withdraw in the pool's precision\r\n     * @param tokenIndex which token will be withdrawn\r\n     * @param self Swap struct to read from\r\n     * @return the amount of token user will receive\r\n     */\r\n    function calculateWithdrawOneToken(\r\n        Swap storage self,\r\n        address account,\r\n        uint256 tokenAmount,\r\n        uint8 tokenIndex\r\n    ) external view returns (uint256) {\r\n        (uint256 availableTokenAmount, ) = _calculateWithdrawOneToken(\r\n            self,\r\n            account,\r\n            tokenAmount,\r\n            tokenIndex,\r\n            self.lpToken.totalSupply()\r\n        );\r\n        return availableTokenAmount;\r\n    }\r\n\r\n    function _calculateWithdrawOneToken(\r\n        Swap storage self,\r\n        address account,\r\n        uint256 tokenAmount,\r\n        uint8 tokenIndex,\r\n        uint256 totalSupply\r\n    ) internal view returns (uint256, uint256) {\r\n        uint256 dy;\r\n        uint256 newY;\r\n        uint256 currentY;\r\n\r\n        (dy, newY, currentY) = calculateWithdrawOneTokenDY(\r\n            self,\r\n            tokenIndex,\r\n            tokenAmount,\r\n            totalSupply\r\n        );\r\n\r\n        // dy_0 (without fees)\r\n        // dy, dy_0 - dy\r\n\r\n        uint256 dySwapFee = currentY\r\n            .sub(newY)\r\n            .div(self.tokenPrecisionMultipliers[tokenIndex])\r\n            .sub(dy);\r\n\r\n        dy = dy\r\n            .mul(\r\n                FEE_DENOMINATOR.sub(_calculateCurrentWithdrawFee(self, account))\r\n            )\r\n            .div(FEE_DENOMINATOR);\r\n\r\n        return (dy, dySwapFee);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the dy of withdrawing in one token\r\n     * @param self Swap struct to read from\r\n     * @param tokenIndex which token will be withdrawn\r\n     * @param tokenAmount the amount to withdraw in the pools precision\r\n     * @return the d and the new y after withdrawing one token\r\n     */\r\n    function calculateWithdrawOneTokenDY(\r\n        Swap storage self,\r\n        uint8 tokenIndex,\r\n        uint256 tokenAmount,\r\n        uint256 totalSupply\r\n    )\r\n        internal\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        )\r\n    {\r\n        // Get the current D, then solve the stableswap invariant\r\n        // y_i for D - tokenAmount\r\n        uint256[] memory xp = _xp(self);\r\n\r\n        require(tokenIndex < xp.length, \"Token index out of range\");\r\n\r\n        CalculateWithdrawOneTokenDYInfo\r\n            memory v = CalculateWithdrawOneTokenDYInfo(0, 0, 0, 0, 0);\r\n        v.preciseA = _getAPrecise(self);\r\n        v.d0 = getD(xp, v.preciseA);\r\n        v.d1 = v.d0.sub(tokenAmount.mul(v.d0).div(totalSupply));\r\n\r\n        require(tokenAmount <= xp[tokenIndex], \"Withdraw exceeds available\");\r\n\r\n        v.newY = getYD(v.preciseA, tokenIndex, xp, v.d1);\r\n\r\n        uint256[] memory xpReduced = new uint256[](xp.length);\r\n\r\n        v.feePerToken = _feePerToken(self.swapFee, xp.length);\r\n        for (uint256 i = 0; i < xp.length; i++) {\r\n            uint256 xpi = xp[i];\r\n            // if i == tokenIndex, dxExpected = xp[i] * d1 / d0 - newY\r\n            // else dxExpected = xp[i] - (xp[i] * d1 / d0)\r\n            // xpReduced[i] -= dxExpected * fee / FEE_DENOMINATOR\r\n            xpReduced[i] = xpi.sub(\r\n                (\r\n                    (i == tokenIndex)\r\n                        ? xpi.mul(v.d1).div(v.d0).sub(v.newY)\r\n                        : xpi.sub(xpi.mul(v.d1).div(v.d0))\r\n                ).mul(v.feePerToken).div(FEE_DENOMINATOR)\r\n            );\r\n        }\r\n\r\n        uint256 dy = xpReduced[tokenIndex].sub(\r\n            getYD(v.preciseA, tokenIndex, xpReduced, v.d1)\r\n        );\r\n        dy = dy.sub(1).div(self.tokenPrecisionMultipliers[tokenIndex]);\r\n\r\n        return (dy, v.newY, xp[tokenIndex]);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the price of a token in the pool with given\r\n     * precision-adjusted balances and a particular D.\r\n     *\r\n     * @dev This is accomplished via solving the invariant iteratively.\r\n     * See the StableSwap paper and Curve.fi implementation for further details.\r\n     *\r\n     * x_1**2 + x1 * (sum' - (A*n**n - 1) * D / (A * n**n)) = D ** (n + 1) / (n ** (2 * n) * prod' * A)\r\n     * x_1**2 + b*x_1 = c\r\n     * x_1 = (x_1**2 + c) / (2*x_1 + b)\r\n     *\r\n     * @param a the amplification coefficient * n * (n - 1). See the StableSwap paper for details.\r\n     * @param tokenIndex Index of token we are calculating for.\r\n     * @param xp a precision-adjusted set of pool balances. Array should be\r\n     * the same cardinality as the pool.\r\n     * @param d the stableswap invariant\r\n     * @return the price of the token, in the same precision as in xp\r\n     */\r\n    function getYD(\r\n        uint256 a,\r\n        uint8 tokenIndex,\r\n        uint256[] memory xp,\r\n        uint256 d\r\n    ) internal pure returns (uint256) {\r\n        uint256 numTokens = xp.length;\r\n        require(tokenIndex < numTokens, \"Token not found\");\r\n\r\n        uint256 c = d;\r\n        uint256 s;\r\n        uint256 nA = a.mul(numTokens);\r\n\r\n        for (uint256 i = 0; i < numTokens; i++) {\r\n            if (i != tokenIndex) {\r\n                s = s.add(xp[i]);\r\n                c = c.mul(d).div(xp[i].mul(numTokens));\r\n                // If we were to protect the division loss we would have to keep the denominator separate\r\n                // and divide at the end. However this leads to overflow with large numTokens or/and D.\r\n                // c = c * D * D * D * ... overflow!\r\n            }\r\n        }\r\n        c = c.mul(d).mul(AmplificationUtilsV1.A_PRECISION).div(\r\n            nA.mul(numTokens)\r\n        );\r\n\r\n        uint256 b = s.add(d.mul(AmplificationUtilsV1.A_PRECISION).div(nA));\r\n        uint256 yPrev;\r\n        uint256 y = d;\r\n        for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {\r\n            yPrev = y;\r\n            y = y.mul(y).add(c).div(y.mul(2).add(b).sub(d));\r\n            if (y.within1(yPrev)) {\r\n                return y;\r\n            }\r\n        }\r\n        revert(\"Approximation did not converge\");\r\n    }\r\n\r\n    /**\r\n     * @notice Get D, the StableSwap invariant, based on a set of balances and a particular A.\r\n     * @param xp a precision-adjusted set of pool balances. Array should be the same cardinality\r\n     * as the pool.\r\n     * @param a the amplification coefficient * n * (n - 1) in A_PRECISION.\r\n     * See the StableSwap paper for details\r\n     * @return the invariant, at the precision of the pool\r\n     */\r\n    function getD(uint256[] memory xp, uint256 a)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 numTokens = xp.length;\r\n        uint256 s;\r\n        for (uint256 i = 0; i < numTokens; i++) {\r\n            s = s.add(xp[i]);\r\n        }\r\n        if (s == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 prevD;\r\n        uint256 d = s;\r\n        uint256 nA = a.mul(numTokens);\r\n\r\n        for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {\r\n            uint256 dP = d;\r\n            for (uint256 j = 0; j < numTokens; j++) {\r\n                dP = dP.mul(d).div(xp[j].mul(numTokens));\r\n                // If we were to protect the division loss we would have to keep the denominator separate\r\n                // and divide at the end. However this leads to overflow with large numTokens or/and D.\r\n                // dP = dP * D * D * D * ... overflow!\r\n            }\r\n            prevD = d;\r\n            d = nA\r\n                .mul(s)\r\n                .div(AmplificationUtilsV1.A_PRECISION)\r\n                .add(dP.mul(numTokens))\r\n                .mul(d)\r\n                .div(\r\n                    nA\r\n                        .sub(AmplificationUtilsV1.A_PRECISION)\r\n                        .mul(d)\r\n                        .div(AmplificationUtilsV1.A_PRECISION)\r\n                        .add(numTokens.add(1).mul(dP))\r\n                );\r\n            if (d.within1(prevD)) {\r\n                return d;\r\n            }\r\n        }\r\n\r\n        // Convergence should occur in 4 loops or less. If this is reached, there may be something wrong\r\n        // with the pool. If this were to occur repeatedly, LPs should withdraw via `removeLiquidity()`\r\n        // function which does not rely on D.\r\n        revert(\"D does not converge\");\r\n    }\r\n\r\n    /**\r\n     * @notice Given a set of balances and precision multipliers, return the\r\n     * precision-adjusted balances.\r\n     *\r\n     * @param balances an array of token balances, in their native precisions.\r\n     * These should generally correspond with pooled tokens.\r\n     *\r\n     * @param precisionMultipliers an array of multipliers, corresponding to\r\n     * the amounts in the balances array. When multiplied together they\r\n     * should yield amounts at the pool's precision.\r\n     *\r\n     * @return an array of amounts \"scaled\" to the pool's precision\r\n     */\r\n    function _xp(\r\n        uint256[] memory balances,\r\n        uint256[] memory precisionMultipliers\r\n    ) internal pure returns (uint256[] memory) {\r\n        uint256 numTokens = balances.length;\r\n        require(\r\n            numTokens == precisionMultipliers.length,\r\n            \"Balances must match multipliers\"\r\n        );\r\n        uint256[] memory xp = new uint256[](numTokens);\r\n        for (uint256 i = 0; i < numTokens; i++) {\r\n            xp[i] = balances[i].mul(precisionMultipliers[i]);\r\n        }\r\n        return xp;\r\n    }\r\n\r\n    /**\r\n     * @notice Return the precision-adjusted balances of all tokens in the pool\r\n     * @param self Swap struct to read from\r\n     * @return the pool balances \"scaled\" to the pool's precision, allowing\r\n     * them to be more easily compared.\r\n     */\r\n    function _xp(Swap storage self) internal view returns (uint256[] memory) {\r\n        return _xp(self.balances, self.tokenPrecisionMultipliers);\r\n    }\r\n\r\n    /**\r\n     * @notice Get the virtual price, to help calculate profit\r\n     * @param self Swap struct to read from\r\n     * @return the virtual price, scaled to precision of POOL_PRECISION_DECIMALS\r\n     */\r\n    function getVirtualPrice(Swap storage self)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 d = getD(_xp(self), _getAPrecise(self));\r\n        LPToken lpToken = self.lpToken;\r\n        uint256 supply = lpToken.totalSupply();\r\n        if (supply > 0) {\r\n            return d.mul(10**uint256(POOL_PRECISION_DECIMALS)).div(supply);\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the new balances of the tokens given the indexes of the token\r\n     * that is swapped from (FROM) and the token that is swapped to (TO).\r\n     * This function is used as a helper function to calculate how much TO token\r\n     * the user should receive on swap.\r\n     *\r\n     * @param preciseA precise form of amplification coefficient\r\n     * @param tokenIndexFrom index of FROM token\r\n     * @param tokenIndexTo index of TO token\r\n     * @param x the new total amount of FROM token\r\n     * @param xp balances of the tokens in the pool\r\n     * @return the amount of TO token that should remain in the pool\r\n     */\r\n    function getY(\r\n        uint256 preciseA,\r\n        uint8 tokenIndexFrom,\r\n        uint8 tokenIndexTo,\r\n        uint256 x,\r\n        uint256[] memory xp\r\n    ) internal pure returns (uint256) {\r\n        uint256 numTokens = xp.length;\r\n        require(\r\n            tokenIndexFrom != tokenIndexTo,\r\n            \"Can't compare token to itself\"\r\n        );\r\n        require(\r\n            tokenIndexFrom < numTokens && tokenIndexTo < numTokens,\r\n            \"Tokens must be in pool\"\r\n        );\r\n\r\n        uint256 d = getD(xp, preciseA);\r\n        uint256 c = d;\r\n        uint256 s;\r\n        uint256 nA = numTokens.mul(preciseA);\r\n\r\n        uint256 _x;\r\n        for (uint256 i = 0; i < numTokens; i++) {\r\n            if (i == tokenIndexFrom) {\r\n                _x = x;\r\n            } else if (i != tokenIndexTo) {\r\n                _x = xp[i];\r\n            } else {\r\n                continue;\r\n            }\r\n            s = s.add(_x);\r\n            c = c.mul(d).div(_x.mul(numTokens));\r\n            // If we were to protect the division loss we would have to keep the denominator separate\r\n            // and divide at the end. However this leads to overflow with large numTokens or/and D.\r\n            // c = c * D * D * D * ... overflow!\r\n        }\r\n        c = c.mul(d).mul(AmplificationUtilsV1.A_PRECISION).div(\r\n            nA.mul(numTokens)\r\n        );\r\n        uint256 b = s.add(d.mul(AmplificationUtilsV1.A_PRECISION).div(nA));\r\n        uint256 yPrev;\r\n        uint256 y = d;\r\n\r\n        // iterative approximation\r\n        for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {\r\n            yPrev = y;\r\n            y = y.mul(y).add(c).div(y.mul(2).add(b).sub(d));\r\n            if (y.within1(yPrev)) {\r\n                return y;\r\n            }\r\n        }\r\n        revert(\"Approximation did not converge\");\r\n    }\r\n\r\n    /**\r\n     * @notice Externally calculates a swap between two tokens.\r\n     * @param self Swap struct to read from\r\n     * @param tokenIndexFrom the token to sell\r\n     * @param tokenIndexTo the token to buy\r\n     * @param dx the number of tokens to sell. If the token charges a fee on transfers,\r\n     * use the amount that gets transferred after the fee.\r\n     * @return dy the number of tokens the user will get\r\n     */\r\n    function calculateSwap(\r\n        Swap storage self,\r\n        uint8 tokenIndexFrom,\r\n        uint8 tokenIndexTo,\r\n        uint256 dx\r\n    ) external view returns (uint256 dy) {\r\n        (dy, ) = _calculateSwap(\r\n            self,\r\n            tokenIndexFrom,\r\n            tokenIndexTo,\r\n            dx,\r\n            self.balances\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Internally calculates a swap between two tokens.\r\n     *\r\n     * @dev The caller is expected to transfer the actual amounts (dx and dy)\r\n     * using the token contracts.\r\n     *\r\n     * @param self Swap struct to read from\r\n     * @param tokenIndexFrom the token to sell\r\n     * @param tokenIndexTo the token to buy\r\n     * @param dx the number of tokens to sell. If the token charges a fee on transfers,\r\n     * use the amount that gets transferred after the fee.\r\n     * @return dy the number of tokens the user will get\r\n     * @return dyFee the associated fee\r\n     */\r\n    function _calculateSwap(\r\n        Swap storage self,\r\n        uint8 tokenIndexFrom,\r\n        uint8 tokenIndexTo,\r\n        uint256 dx,\r\n        uint256[] memory balances\r\n    ) internal view returns (uint256 dy, uint256 dyFee) {\r\n        uint256[] memory multipliers = self.tokenPrecisionMultipliers;\r\n        uint256[] memory xp = _xp(balances, multipliers);\r\n        require(\r\n            tokenIndexFrom < xp.length && tokenIndexTo < xp.length,\r\n            \"Token index out of range\"\r\n        );\r\n        uint256 x = dx.mul(multipliers[tokenIndexFrom]).add(xp[tokenIndexFrom]);\r\n        uint256 y = getY(\r\n            _getAPrecise(self),\r\n            tokenIndexFrom,\r\n            tokenIndexTo,\r\n            x,\r\n            xp\r\n        );\r\n        dy = xp[tokenIndexTo].sub(y).sub(1);\r\n        dyFee = dy.mul(self.swapFee).div(FEE_DENOMINATOR);\r\n        dy = dy.sub(dyFee).div(multipliers[tokenIndexTo]);\r\n    }\r\n\r\n    /**\r\n     * @notice A simple method to calculate amount of each underlying\r\n     * tokens that is returned upon burning given amount of\r\n     * LP tokens\r\n     *\r\n     * @param account the address that is removing liquidity. required for withdraw fee calculation\r\n     * @param amount the amount of LP tokens that would to be burned on\r\n     * withdrawal\r\n     * @return array of amounts of tokens user will receive\r\n     */\r\n    function calculateRemoveLiquidity(\r\n        Swap storage self,\r\n        address account,\r\n        uint256 amount\r\n    ) external view returns (uint256[] memory) {\r\n        return\r\n            _calculateRemoveLiquidity(\r\n                self,\r\n                self.balances,\r\n                account,\r\n                amount,\r\n                self.lpToken.totalSupply()\r\n            );\r\n    }\r\n\r\n    function _calculateRemoveLiquidity(\r\n        Swap storage self,\r\n        uint256[] memory balances,\r\n        address account,\r\n        uint256 amount,\r\n        uint256 totalSupply\r\n    ) internal view returns (uint256[] memory) {\r\n        require(amount <= totalSupply, \"Cannot exceed total supply\");\r\n\r\n        uint256 feeAdjustedAmount = amount\r\n            .mul(\r\n                FEE_DENOMINATOR.sub(_calculateCurrentWithdrawFee(self, account))\r\n            )\r\n            .div(FEE_DENOMINATOR);\r\n\r\n        uint256[] memory amounts = new uint256[](balances.length);\r\n\r\n        for (uint256 i = 0; i < balances.length; i++) {\r\n            amounts[i] = balances[i].mul(feeAdjustedAmount).div(totalSupply);\r\n        }\r\n        return amounts;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the fee that is applied when the given user withdraws.\r\n     * Withdraw fee decays linearly over WITHDRAW_FEE_DECAY_TIME.\r\n     * @param user address you want to calculate withdraw fee of\r\n     * @return current withdraw fee of the user\r\n     */\r\n    function calculateCurrentWithdrawFee(Swap storage self, address user)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _calculateCurrentWithdrawFee(self, user);\r\n    }\r\n\r\n    function _calculateCurrentWithdrawFee(Swap storage self, address user)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 endTime = self.depositTimestamp[user].add(\r\n            WITHDRAW_FEE_DECAY_TIME\r\n        );\r\n        if (endTime > block.timestamp) {\r\n            uint256 timeLeftover = endTime.sub(block.timestamp);\r\n            return\r\n                self\r\n                    .defaultWithdrawFee\r\n                    .mul(self.withdrawFeeMultiplier[user])\r\n                    .mul(timeLeftover)\r\n                    .div(WITHDRAW_FEE_DECAY_TIME)\r\n                    .div(FEE_DENOMINATOR);\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * @notice A simple method to calculate prices from deposits or\r\n     * withdrawals, excluding fees but including slippage. This is\r\n     * helpful as an input into the various \"min\" parameters on calls\r\n     * to fight front-running\r\n     *\r\n     * @dev This shouldn't be used outside frontends for user estimates.\r\n     *\r\n     * @param self Swap struct to read from\r\n     * @param account address of the account depositing or withdrawing tokens\r\n     * @param amounts an array of token amounts to deposit or withdrawal,\r\n     * corresponding to pooledTokens. The amount should be in each\r\n     * pooled token's native precision. If a token charges a fee on transfers,\r\n     * use the amount that gets transferred after the fee.\r\n     * @param deposit whether this is a deposit or a withdrawal\r\n     * @return if deposit was true, total amount of lp token that will be minted and if\r\n     * deposit was false, total amount of lp token that will be burned\r\n     */\r\n    function calculateTokenAmount(\r\n        Swap storage self,\r\n        address account,\r\n        uint256[] calldata amounts,\r\n        bool deposit\r\n    ) external view returns (uint256) {\r\n        uint256 a = _getAPrecise(self);\r\n        uint256[] memory balances = self.balances;\r\n        uint256[] memory multipliers = self.tokenPrecisionMultipliers;\r\n\r\n        uint256 d0 = getD(_xp(balances, multipliers), a);\r\n        for (uint256 i = 0; i < balances.length; i++) {\r\n            if (deposit) {\r\n                balances[i] = balances[i].add(amounts[i]);\r\n            } else {\r\n                balances[i] = balances[i].sub(\r\n                    amounts[i],\r\n                    \"Cannot withdraw more than available\"\r\n                );\r\n            }\r\n        }\r\n        uint256 d1 = getD(_xp(balances, multipliers), a);\r\n        uint256 totalSupply = self.lpToken.totalSupply();\r\n\r\n        if (deposit) {\r\n            return d1.sub(d0).mul(totalSupply).div(d0);\r\n        } else {\r\n            return\r\n                d0.sub(d1).mul(totalSupply).div(d0).mul(FEE_DENOMINATOR).div(\r\n                    FEE_DENOMINATOR.sub(\r\n                        _calculateCurrentWithdrawFee(self, account)\r\n                    )\r\n                );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice return accumulated amount of admin fees of the token with given index\r\n     * @param self Swap struct to read from\r\n     * @param index Index of the pooled token\r\n     * @return admin balance in the token's precision\r\n     */\r\n    function getAdminBalance(Swap storage self, uint256 index)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        require(index < self.pooledTokens.length, \"Token index out of range\");\r\n        return\r\n            self.pooledTokens[index].balanceOf(address(this)).sub(\r\n                self.balances[index]\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @notice internal helper function to calculate fee per token multiplier used in\r\n     * swap fee calculations\r\n     * @param swapFee swap fee for the tokens\r\n     * @param numTokens number of tokens pooled\r\n     */\r\n    function _feePerToken(uint256 swapFee, uint256 numTokens)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return swapFee.mul(numTokens).div(numTokens.sub(1).mul(4));\r\n    }\r\n\r\n    /*** STATE MODIFYING FUNCTIONS ***/\r\n\r\n    /**\r\n     * @notice swap two tokens in the pool\r\n     * @param self Swap struct to read from and write to\r\n     * @param tokenIndexFrom the token the user wants to sell\r\n     * @param tokenIndexTo the token the user wants to buy\r\n     * @param dx the amount of tokens the user wants to sell\r\n     * @param minDy the min amount the user would like to receive, or revert.\r\n     * @return amount of token user received on swap\r\n     */\r\n    function swap(\r\n        Swap storage self,\r\n        uint8 tokenIndexFrom,\r\n        uint8 tokenIndexTo,\r\n        uint256 dx,\r\n        uint256 minDy\r\n    ) external returns (uint256) {\r\n        {\r\n            IERC20 tokenFrom = self.pooledTokens[tokenIndexFrom];\r\n            require(\r\n                dx <= tokenFrom.balanceOf(msg.sender),\r\n                \"Cannot swap more than you own\"\r\n            );\r\n            // Transfer tokens first to see if a fee was charged on transfer\r\n            uint256 beforeBalance = tokenFrom.balanceOf(address(this));\r\n            tokenFrom.safeTransferFrom(msg.sender, address(this), dx);\r\n\r\n            // Use the actual transferred amount for AMM math\r\n            dx = tokenFrom.balanceOf(address(this)).sub(beforeBalance);\r\n        }\r\n\r\n        uint256 dy;\r\n        uint256 dyFee;\r\n        uint256[] memory balances = self.balances;\r\n        (dy, dyFee) = _calculateSwap(\r\n            self,\r\n            tokenIndexFrom,\r\n            tokenIndexTo,\r\n            dx,\r\n            balances\r\n        );\r\n        require(dy >= minDy, \"Swap didn't result in min tokens\");\r\n\r\n        uint256 dyAdminFee = dyFee.mul(self.adminFee).div(FEE_DENOMINATOR).div(\r\n            self.tokenPrecisionMultipliers[tokenIndexTo]\r\n        );\r\n\r\n        self.balances[tokenIndexFrom] = balances[tokenIndexFrom].add(dx);\r\n        self.balances[tokenIndexTo] = balances[tokenIndexTo].sub(dy).sub(\r\n            dyAdminFee\r\n        );\r\n\r\n        self.pooledTokens[tokenIndexTo].safeTransfer(msg.sender, dy);\r\n\r\n        emit TokenSwap(msg.sender, dx, dy, tokenIndexFrom, tokenIndexTo);\r\n\r\n        return dy;\r\n    }\r\n\r\n    /**\r\n     * @notice Add liquidity to the pool\r\n     * @param self Swap struct to read from and write to\r\n     * @param amounts the amounts of each token to add, in their native precision\r\n     * @param minToMint the minimum LP tokens adding this amount of liquidity\r\n     * should mint, otherwise revert. Handy for front-running mitigation\r\n     * allowed addresses. If the pool is not in the guarded launch phase, this parameter will be ignored.\r\n     * @return amount of LP token user received\r\n     */\r\n    function addLiquidity(\r\n        Swap storage self,\r\n        uint256[] memory amounts,\r\n        uint256 minToMint\r\n    ) external returns (uint256) {\r\n        IERC20[] memory pooledTokens = self.pooledTokens;\r\n        require(\r\n            amounts.length == pooledTokens.length,\r\n            \"Amounts must match pooled tokens\"\r\n        );\r\n\r\n        // current state\r\n        ManageLiquidityInfo memory v = ManageLiquidityInfo(\r\n            0,\r\n            0,\r\n            0,\r\n            _getAPrecise(self),\r\n            self.lpToken,\r\n            0,\r\n            self.balances,\r\n            self.tokenPrecisionMultipliers\r\n        );\r\n        v.totalSupply = v.lpToken.totalSupply();\r\n\r\n        if (v.totalSupply != 0) {\r\n            v.d0 = getD(_xp(v.balances, v.multipliers), v.preciseA);\r\n        }\r\n\r\n        uint256[] memory newBalances = new uint256[](pooledTokens.length);\r\n\r\n        for (uint256 i = 0; i < pooledTokens.length; i++) {\r\n            require(\r\n                v.totalSupply != 0 || amounts[i] > 0,\r\n                \"Must supply all tokens in pool\"\r\n            );\r\n\r\n            // Transfer tokens first to see if a fee was charged on transfer\r\n            if (amounts[i] != 0) {\r\n                uint256 beforeBalance = pooledTokens[i].balanceOf(\r\n                    address(this)\r\n                );\r\n                pooledTokens[i].safeTransferFrom(\r\n                    msg.sender,\r\n                    address(this),\r\n                    amounts[i]\r\n                );\r\n\r\n                // Update the amounts[] with actual transfer amount\r\n                amounts[i] = pooledTokens[i].balanceOf(address(this)).sub(\r\n                    beforeBalance\r\n                );\r\n            }\r\n\r\n            newBalances[i] = v.balances[i].add(amounts[i]);\r\n        }\r\n\r\n        // invariant after change\r\n        v.d1 = getD(_xp(newBalances, v.multipliers), v.preciseA);\r\n        require(v.d1 > v.d0, \"D should increase\");\r\n\r\n        // updated to reflect fees and calculate the user's LP tokens\r\n        v.d2 = v.d1;\r\n        uint256[] memory fees = new uint256[](pooledTokens.length);\r\n\r\n        if (v.totalSupply != 0) {\r\n            uint256 feePerToken = _feePerToken(\r\n                self.swapFee,\r\n                pooledTokens.length\r\n            );\r\n            for (uint256 i = 0; i < pooledTokens.length; i++) {\r\n                uint256 idealBalance = v.d1.mul(v.balances[i]).div(v.d0);\r\n                fees[i] = feePerToken\r\n                    .mul(idealBalance.difference(newBalances[i]))\r\n                    .div(FEE_DENOMINATOR);\r\n                self.balances[i] = newBalances[i].sub(\r\n                    fees[i].mul(self.adminFee).div(FEE_DENOMINATOR)\r\n                );\r\n                newBalances[i] = newBalances[i].sub(fees[i]);\r\n            }\r\n            v.d2 = getD(_xp(newBalances, v.multipliers), v.preciseA);\r\n        } else {\r\n            // the initial depositor doesn't pay fees\r\n            self.balances = newBalances;\r\n        }\r\n\r\n        uint256 toMint;\r\n        if (v.totalSupply == 0) {\r\n            toMint = v.d1;\r\n        } else {\r\n            toMint = v.d2.sub(v.d0).mul(v.totalSupply).div(v.d0);\r\n        }\r\n\r\n        require(toMint >= minToMint, \"Couldn't mint min requested\");\r\n\r\n        // mint the user's LP tokens\r\n        v.lpToken.mint(msg.sender, toMint);\r\n\r\n        emit AddLiquidity(\r\n            msg.sender,\r\n            amounts,\r\n            fees,\r\n            v.d1,\r\n            v.totalSupply.add(toMint)\r\n        );\r\n\r\n        return toMint;\r\n    }\r\n\r\n    /**\r\n     * @notice Update the withdraw fee for `user`. If the user is currently\r\n     * not providing liquidity in the pool, sets to default value. If not, recalculate\r\n     * the starting withdraw fee based on the last deposit's time & amount relative\r\n     * to the new deposit.\r\n     *\r\n     * @param self Swap struct to read from and write to\r\n     * @param user address of the user depositing tokens\r\n     * @param toMint amount of pool tokens to be minted\r\n     */\r\n    function updateUserWithdrawFee(\r\n        Swap storage self,\r\n        address user,\r\n        uint256 toMint\r\n    ) public {\r\n        // If token is transferred to address 0 (or burned), don't update the fee.\r\n        if (user == address(0)) {\r\n            return;\r\n        }\r\n        if (self.defaultWithdrawFee == 0) {\r\n            // If current fee is set to 0%, set multiplier to FEE_DENOMINATOR\r\n            self.withdrawFeeMultiplier[user] = FEE_DENOMINATOR;\r\n        } else {\r\n            // Otherwise, calculate appropriate discount based on last deposit amount\r\n            uint256 currentFee = _calculateCurrentWithdrawFee(self, user);\r\n            uint256 currentBalance = self.lpToken.balanceOf(user);\r\n\r\n            // ((currentBalance * currentFee) + (toMint * defaultWithdrawFee)) * FEE_DENOMINATOR /\r\n            // ((toMint + currentBalance) * defaultWithdrawFee)\r\n            self.withdrawFeeMultiplier[user] = currentBalance\r\n                .mul(currentFee)\r\n                .add(toMint.mul(self.defaultWithdrawFee))\r\n                .mul(FEE_DENOMINATOR)\r\n                .div(toMint.add(currentBalance).mul(self.defaultWithdrawFee));\r\n        }\r\n        self.depositTimestamp[user] = block.timestamp;\r\n    }\r\n\r\n    /**\r\n     * @notice Burn LP tokens to remove liquidity from the pool.\r\n     * @dev Liquidity can always be removed, even when the pool is paused.\r\n     * @param self Swap struct to read from and write to\r\n     * @param amount the amount of LP tokens to burn\r\n     * @param minAmounts the minimum amounts of each token in the pool\r\n     * acceptable for this burn. Useful as a front-running mitigation\r\n     * @return amounts of tokens the user received\r\n     */\r\n    function removeLiquidity(\r\n        Swap storage self,\r\n        uint256 amount,\r\n        uint256[] calldata minAmounts\r\n    ) external returns (uint256[] memory) {\r\n        LPToken lpToken = self.lpToken;\r\n        IERC20[] memory pooledTokens = self.pooledTokens;\r\n        require(amount <= lpToken.balanceOf(msg.sender), \">LP.balanceOf\");\r\n        require(\r\n            minAmounts.length == pooledTokens.length,\r\n            \"minAmounts must match poolTokens\"\r\n        );\r\n\r\n        uint256[] memory balances = self.balances;\r\n        uint256 totalSupply = lpToken.totalSupply();\r\n\r\n        uint256[] memory amounts = _calculateRemoveLiquidity(\r\n            self,\r\n            balances,\r\n            msg.sender,\r\n            amount,\r\n            totalSupply\r\n        );\r\n\r\n        for (uint256 i = 0; i < amounts.length; i++) {\r\n            require(amounts[i] >= minAmounts[i], \"amounts[i] < minAmounts[i]\");\r\n            self.balances[i] = balances[i].sub(amounts[i]);\r\n            pooledTokens[i].safeTransfer(msg.sender, amounts[i]);\r\n        }\r\n\r\n        lpToken.burnFrom(msg.sender, amount);\r\n\r\n        emit RemoveLiquidity(msg.sender, amounts, totalSupply.sub(amount));\r\n\r\n        return amounts;\r\n    }\r\n\r\n    /**\r\n     * @notice Remove liquidity from the pool all in one token.\r\n     * @param self Swap struct to read from and write to\r\n     * @param tokenAmount the amount of the lp tokens to burn\r\n     * @param tokenIndex the index of the token you want to receive\r\n     * @param minAmount the minimum amount to withdraw, otherwise revert\r\n     * @return amount chosen token that user received\r\n     */\r\n    function removeLiquidityOneToken(\r\n        Swap storage self,\r\n        uint256 tokenAmount,\r\n        uint8 tokenIndex,\r\n        uint256 minAmount\r\n    ) external returns (uint256) {\r\n        LPToken lpToken = self.lpToken;\r\n        IERC20[] memory pooledTokens = self.pooledTokens;\r\n\r\n        require(tokenAmount <= lpToken.balanceOf(msg.sender), \">LP.balanceOf\");\r\n        require(tokenIndex < pooledTokens.length, \"Token not found\");\r\n\r\n        uint256 totalSupply = lpToken.totalSupply();\r\n\r\n        (uint256 dy, uint256 dyFee) = _calculateWithdrawOneToken(\r\n            self,\r\n            msg.sender,\r\n            tokenAmount,\r\n            tokenIndex,\r\n            totalSupply\r\n        );\r\n\r\n        require(dy >= minAmount, \"dy < minAmount\");\r\n\r\n        self.balances[tokenIndex] = self.balances[tokenIndex].sub(\r\n            dy.add(dyFee.mul(self.adminFee).div(FEE_DENOMINATOR))\r\n        );\r\n        lpToken.burnFrom(msg.sender, tokenAmount);\r\n        pooledTokens[tokenIndex].safeTransfer(msg.sender, dy);\r\n\r\n        emit RemoveLiquidityOne(\r\n            msg.sender,\r\n            tokenAmount,\r\n            totalSupply,\r\n            tokenIndex,\r\n            dy\r\n        );\r\n\r\n        return dy;\r\n    }\r\n\r\n    /**\r\n     * @notice Remove liquidity from the pool, weighted differently than the\r\n     * pool's current balances.\r\n     *\r\n     * @param self Swap struct to read from and write to\r\n     * @param amounts how much of each token to withdraw\r\n     * @param maxBurnAmount the max LP token provider is willing to pay to\r\n     * remove liquidity. Useful as a front-running mitigation.\r\n     * @return actual amount of LP tokens burned in the withdrawal\r\n     */\r\n    function removeLiquidityImbalance(\r\n        Swap storage self,\r\n        uint256[] memory amounts,\r\n        uint256 maxBurnAmount\r\n    ) public returns (uint256) {\r\n        ManageLiquidityInfo memory v = ManageLiquidityInfo(\r\n            0,\r\n            0,\r\n            0,\r\n            _getAPrecise(self),\r\n            self.lpToken,\r\n            0,\r\n            self.balances,\r\n            self.tokenPrecisionMultipliers\r\n        );\r\n        v.totalSupply = v.lpToken.totalSupply();\r\n\r\n        IERC20[] memory pooledTokens = self.pooledTokens;\r\n\r\n        require(\r\n            amounts.length == pooledTokens.length,\r\n            \"Amounts should match pool tokens\"\r\n        );\r\n\r\n        require(\r\n            maxBurnAmount <= v.lpToken.balanceOf(msg.sender) &&\r\n                maxBurnAmount != 0,\r\n            \">LP.balanceOf\"\r\n        );\r\n\r\n        uint256 feePerToken = _feePerToken(self.swapFee, pooledTokens.length);\r\n        uint256[] memory fees = new uint256[](pooledTokens.length);\r\n        {\r\n            uint256[] memory balances1 = new uint256[](pooledTokens.length);\r\n            v.d0 = getD(_xp(v.balances, v.multipliers), v.preciseA);\r\n            for (uint256 i = 0; i < pooledTokens.length; i++) {\r\n                balances1[i] = v.balances[i].sub(\r\n                    amounts[i],\r\n                    \"Cannot withdraw more than available\"\r\n                );\r\n            }\r\n            v.d1 = getD(_xp(balances1, v.multipliers), v.preciseA);\r\n\r\n            for (uint256 i = 0; i < pooledTokens.length; i++) {\r\n                uint256 idealBalance = v.d1.mul(v.balances[i]).div(v.d0);\r\n                uint256 difference = idealBalance.difference(balances1[i]);\r\n                fees[i] = feePerToken.mul(difference).div(FEE_DENOMINATOR);\r\n                self.balances[i] = balances1[i].sub(\r\n                    fees[i].mul(self.adminFee).div(FEE_DENOMINATOR)\r\n                );\r\n                balances1[i] = balances1[i].sub(fees[i]);\r\n            }\r\n\r\n            v.d2 = getD(_xp(balances1, v.multipliers), v.preciseA);\r\n        }\r\n        uint256 tokenAmount = v.d0.sub(v.d2).mul(v.totalSupply).div(v.d0);\r\n        require(tokenAmount != 0, \"Burnt amount cannot be zero\");\r\n        tokenAmount = tokenAmount.add(1).mul(FEE_DENOMINATOR).div(\r\n            FEE_DENOMINATOR.sub(_calculateCurrentWithdrawFee(self, msg.sender))\r\n        );\r\n\r\n        require(tokenAmount <= maxBurnAmount, \"tokenAmount > maxBurnAmount\");\r\n\r\n        v.lpToken.burnFrom(msg.sender, tokenAmount);\r\n\r\n        for (uint256 i = 0; i < pooledTokens.length; i++) {\r\n            pooledTokens[i].safeTransfer(msg.sender, amounts[i]);\r\n        }\r\n\r\n        emit RemoveLiquidityImbalance(\r\n            msg.sender,\r\n            amounts,\r\n            fees,\r\n            v.d1,\r\n            v.totalSupply.sub(tokenAmount)\r\n        );\r\n\r\n        return tokenAmount;\r\n    }\r\n\r\n    /**\r\n     * @notice withdraw all admin fees to a given address\r\n     * @param self Swap struct to withdraw fees from\r\n     * @param to Address to send the fees to\r\n     */\r\n    function withdrawAdminFees(Swap storage self, address to) external {\r\n        IERC20[] memory pooledTokens = self.pooledTokens;\r\n        for (uint256 i = 0; i < pooledTokens.length; i++) {\r\n            IERC20 token = pooledTokens[i];\r\n            uint256 balance = token.balanceOf(address(this)).sub(\r\n                self.balances[i]\r\n            );\r\n            if (balance != 0) {\r\n                token.safeTransfer(to, balance);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the admin fee\r\n     * @dev adminFee cannot be higher than 100% of the swap fee\r\n     * @param self Swap struct to update\r\n     * @param newAdminFee new admin fee to be applied on future transactions\r\n     */\r\n    function setAdminFee(Swap storage self, uint256 newAdminFee) external {\r\n        require(newAdminFee <= MAX_ADMIN_FEE, \"Fee is too high\");\r\n        self.adminFee = newAdminFee;\r\n\r\n        emit NewAdminFee(newAdminFee);\r\n    }\r\n\r\n    /**\r\n     * @notice update the swap fee\r\n     * @dev fee cannot be higher than 1% of each swap\r\n     * @param self Swap struct to update\r\n     * @param newSwapFee new swap fee to be applied on future transactions\r\n     */\r\n    function setSwapFee(Swap storage self, uint256 newSwapFee) external {\r\n        require(newSwapFee <= MAX_SWAP_FEE, \"Fee is too high\");\r\n        self.swapFee = newSwapFee;\r\n\r\n        emit NewSwapFee(newSwapFee);\r\n    }\r\n\r\n    /**\r\n     * @notice update the default withdraw fee. This also affects deposits made in the past as well.\r\n     * @param self Swap struct to update\r\n     * @param newWithdrawFee new withdraw fee to be applied\r\n     */\r\n    function setDefaultWithdrawFee(Swap storage self, uint256 newWithdrawFee)\r\n        external\r\n    {\r\n        require(newWithdrawFee <= MAX_WITHDRAW_FEE, \"Fee is too high\");\r\n        self.defaultWithdrawFee = newWithdrawFee;\r\n\r\n        emit NewWithdrawFee(newWithdrawFee);\r\n    }\r\n}\r\n"
    },
    "contracts/AmplificationUtilsV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\r\nimport \"./SwapUtilsV1.sol\";\r\n\r\n/**\r\n * @title AmplificationUtils library\r\n * @notice A library to calculate and ramp the A parameter of a given `SwapUtils.Swap` struct.\r\n * This library assumes the struct is fully validated.\r\n */\r\nlibrary AmplificationUtilsV1 {\r\n    using SafeMath for uint256;\r\n\r\n    event RampA(\r\n        uint256 oldA,\r\n        uint256 newA,\r\n        uint256 initialTime,\r\n        uint256 futureTime\r\n    );\r\n    event StopRampA(uint256 currentA, uint256 time);\r\n\r\n    // Constant values used in ramping A calculations\r\n    uint256 public constant A_PRECISION = 100;\r\n    uint256 public constant MAX_A = 10**6;\r\n    uint256 private constant MAX_A_CHANGE = 2;\r\n    uint256 private constant MIN_RAMP_TIME = 14 days;\r\n\r\n    /**\r\n     * @notice Return A, the amplification coefficient * n * (n - 1)\r\n     * @dev See the StableSwap paper for details\r\n     * @param self Swap struct to read from\r\n     * @return A parameter\r\n     */\r\n    function getA(SwapUtilsV1.Swap storage self)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _getAPrecise(self).div(A_PRECISION);\r\n    }\r\n\r\n    /**\r\n     * @notice Return A in its raw precision\r\n     * @dev See the StableSwap paper for details\r\n     * @param self Swap struct to read from\r\n     * @return A parameter in its raw precision form\r\n     */\r\n    function getAPrecise(SwapUtilsV1.Swap storage self)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _getAPrecise(self);\r\n    }\r\n\r\n    /**\r\n     * @notice Return A in its raw precision\r\n     * @dev See the StableSwap paper for details\r\n     * @param self Swap struct to read from\r\n     * @return A parameter in its raw precision form\r\n     */\r\n    function _getAPrecise(SwapUtilsV1.Swap storage self)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 t1 = self.futureATime; // time when ramp is finished\r\n        uint256 a1 = self.futureA; // final A value when ramp is finished\r\n\r\n        if (block.timestamp < t1) {\r\n            uint256 t0 = self.initialATime; // time when ramp is started\r\n            uint256 a0 = self.initialA; // initial A value when ramp is started\r\n            if (a1 > a0) {\r\n                // a0 + (a1 - a0) * (block.timestamp - t0) / (t1 - t0)\r\n                return\r\n                    a0.add(\r\n                        a1.sub(a0).mul(block.timestamp.sub(t0)).div(t1.sub(t0))\r\n                    );\r\n            } else {\r\n                // a0 - (a0 - a1) * (block.timestamp - t0) / (t1 - t0)\r\n                return\r\n                    a0.sub(\r\n                        a0.sub(a1).mul(block.timestamp.sub(t0)).div(t1.sub(t0))\r\n                    );\r\n            }\r\n        } else {\r\n            return a1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Start ramping up or down A parameter towards given futureA_ and futureTime_\r\n     * Checks if the change is too rapid, and commits the new A value only when it falls under\r\n     * the limit range.\r\n     * @param self Swap struct to update\r\n     * @param futureA_ the new A to ramp towards\r\n     * @param futureTime_ timestamp when the new A should be reached\r\n     */\r\n    function rampA(\r\n        SwapUtilsV1.Swap storage self,\r\n        uint256 futureA_,\r\n        uint256 futureTime_\r\n    ) external {\r\n        require(\r\n            block.timestamp >= self.initialATime.add(1 days),\r\n            \"Wait 1 day before starting ramp\"\r\n        );\r\n        require(\r\n            futureTime_ >= block.timestamp.add(MIN_RAMP_TIME),\r\n            \"Insufficient ramp time\"\r\n        );\r\n        require(\r\n            futureA_ > 0 && futureA_ < MAX_A,\r\n            \"futureA_ must be > 0 and < MAX_A\"\r\n        );\r\n\r\n        uint256 initialAPrecise = _getAPrecise(self);\r\n        uint256 futureAPrecise = futureA_.mul(A_PRECISION);\r\n\r\n        if (futureAPrecise < initialAPrecise) {\r\n            require(\r\n                futureAPrecise.mul(MAX_A_CHANGE) >= initialAPrecise,\r\n                \"futureA_ is too small\"\r\n            );\r\n        } else {\r\n            require(\r\n                futureAPrecise <= initialAPrecise.mul(MAX_A_CHANGE),\r\n                \"futureA_ is too large\"\r\n            );\r\n        }\r\n\r\n        self.initialA = initialAPrecise;\r\n        self.futureA = futureAPrecise;\r\n        self.initialATime = block.timestamp;\r\n        self.futureATime = futureTime_;\r\n\r\n        emit RampA(\r\n            initialAPrecise,\r\n            futureAPrecise,\r\n            block.timestamp,\r\n            futureTime_\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Stops ramping A immediately. Once this function is called, rampA()\r\n     * cannot be called for another 24 hours\r\n     * @param self Swap struct to update\r\n     */\r\n    function stopRampA(SwapUtilsV1.Swap storage self) external {\r\n        require(self.futureATime > block.timestamp, \"Ramp is already stopped\");\r\n\r\n        uint256 currentA = _getAPrecise(self);\r\n        self.initialA = currentA;\r\n        self.futureA = currentA;\r\n        self.initialATime = block.timestamp;\r\n        self.futureATime = block.timestamp;\r\n\r\n        emit StopRampA(currentA, block.timestamp);\r\n    }\r\n}\r\n"
    },
    "contracts/meta/MetaSwapUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\r\nimport \"../LPToken.sol\";\r\nimport \"../interfaces/ISwap.sol\";\r\nimport \"../MathUtils.sol\";\r\nimport \"../SwapUtils.sol\";\r\n\r\n/**\r\n * @title MetaSwapUtils library\r\n * @notice A library to be used within MetaSwap.sol. Contains functions responsible for custody and AMM functionalities.\r\n *\r\n * MetaSwap is a modified version of Swap that allows Swap's LP token to be utilized in pooling with other tokens.\r\n * As an example, if there is a Swap pool consisting of [DAI, USDC, USDT]. Then a MetaSwap pool can be created\r\n * with [sUSD, BaseSwapLPToken] to allow trades between either the LP token or the underlying tokens and sUSD.\r\n *\r\n * @dev Contracts relying on this library must initialize SwapUtils.Swap struct then use this library\r\n * for SwapUtils.Swap struct. Note that this library contains both functions called by users and admins.\r\n * Admin functions should be protected within contracts using this library.\r\n */\r\nlibrary MetaSwapUtils {\r\n    using SafeERC20 for IERC20;\r\n    using SafeMath for uint256;\r\n    using MathUtils for uint256;\r\n    using AmplificationUtils for SwapUtils.Swap;\r\n\r\n    /*** EVENTS ***/\r\n\r\n    event TokenSwap(\r\n        address indexed buyer,\r\n        uint256 tokensSold,\r\n        uint256 tokensBought,\r\n        uint128 soldId,\r\n        uint128 boughtId\r\n    );\r\n    event TokenSwapUnderlying(\r\n        address indexed buyer,\r\n        uint256 tokensSold,\r\n        uint256 tokensBought,\r\n        uint128 soldId,\r\n        uint128 boughtId\r\n    );\r\n    event AddLiquidity(\r\n        address indexed provider,\r\n        uint256[] tokenAmounts,\r\n        uint256[] fees,\r\n        uint256 invariant,\r\n        uint256 lpTokenSupply\r\n    );\r\n    event RemoveLiquidityOne(\r\n        address indexed provider,\r\n        uint256 lpTokenAmount,\r\n        uint256 lpTokenSupply,\r\n        uint256 boughtId,\r\n        uint256 tokensBought\r\n    );\r\n    event RemoveLiquidityImbalance(\r\n        address indexed provider,\r\n        uint256[] tokenAmounts,\r\n        uint256[] fees,\r\n        uint256 invariant,\r\n        uint256 lpTokenSupply\r\n    );\r\n    event NewAdminFee(uint256 newAdminFee);\r\n    event NewSwapFee(uint256 newSwapFee);\r\n    event NewWithdrawFee(uint256 newWithdrawFee);\r\n\r\n    struct MetaSwap {\r\n        // Meta-Swap related parameters\r\n        ISwap baseSwap;\r\n        uint256 baseVirtualPrice;\r\n        uint256 baseCacheLastUpdated;\r\n        IERC20[] baseTokens;\r\n    }\r\n\r\n    // Struct storing variables used in calculations in the\r\n    // calculateWithdrawOneTokenDY function to avoid stack too deep errors\r\n    struct CalculateWithdrawOneTokenDYInfo {\r\n        uint256 d0;\r\n        uint256 d1;\r\n        uint256 newY;\r\n        uint256 feePerToken;\r\n        uint256 preciseA;\r\n        uint256 xpi;\r\n    }\r\n\r\n    // Struct storing variables used in calculation in removeLiquidityImbalance function\r\n    // to avoid stack too deep error\r\n    struct ManageLiquidityInfo {\r\n        uint256 d0;\r\n        uint256 d1;\r\n        uint256 d2;\r\n        LPToken lpToken;\r\n        uint256 totalSupply;\r\n        uint256 preciseA;\r\n        uint256 baseVirtualPrice;\r\n        uint256[] tokenPrecisionMultipliers;\r\n        uint256[] newBalances;\r\n    }\r\n\r\n    struct SwapUnderlyingInfo {\r\n        uint256 x;\r\n        uint256 dx;\r\n        uint256 dy;\r\n        uint256[] tokenPrecisionMultipliers;\r\n        uint256[] oldBalances;\r\n        IERC20[] baseTokens;\r\n        IERC20 tokenFrom;\r\n        uint8 metaIndexFrom;\r\n        IERC20 tokenTo;\r\n        uint8 metaIndexTo;\r\n        uint256 baseVirtualPrice;\r\n    }\r\n\r\n    struct CalculateSwapUnderlyingInfo {\r\n        uint256 baseVirtualPrice;\r\n        ISwap baseSwap;\r\n        uint8 baseLPTokenIndex;\r\n        uint8 baseTokensLength;\r\n        uint8 metaIndexTo;\r\n        uint256 x;\r\n        uint256 dy;\r\n    }\r\n\r\n    // the denominator used to calculate admin and LP fees. For example, an\r\n    // LP fee might be something like tradeAmount.mul(fee).div(FEE_DENOMINATOR)\r\n    uint256 private constant FEE_DENOMINATOR = 10**10;\r\n\r\n    // Cache expire time for the stored value of base Swap's virtual price\r\n    uint256 public constant BASE_CACHE_EXPIRE_TIME = 10 minutes;\r\n    uint256 public constant BASE_VIRTUAL_PRICE_PRECISION = 10**18;\r\n\r\n    /*** VIEW & PURE FUNCTIONS ***/\r\n\r\n    /**\r\n     * @notice Return the stored value of base Swap's virtual price. If\r\n     * value was updated past BASE_CACHE_EXPIRE_TIME, then read it directly\r\n     * from the base Swap contract.\r\n     * @param metaSwapStorage MetaSwap struct to read from\r\n     * @return base Swap's virtual price\r\n     */\r\n    function _getBaseVirtualPrice(MetaSwap storage metaSwapStorage)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (\r\n            block.timestamp >\r\n            metaSwapStorage.baseCacheLastUpdated + BASE_CACHE_EXPIRE_TIME\r\n        ) {\r\n            return metaSwapStorage.baseSwap.getVirtualPrice();\r\n        }\r\n        return metaSwapStorage.baseVirtualPrice;\r\n    }\r\n\r\n    function _getBaseSwapFee(ISwap baseSwap)\r\n        internal\r\n        view\r\n        returns (uint256 swapFee)\r\n    {\r\n        (, , , , swapFee, , ) = baseSwap.swapStorage();\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate how much the user would receive when withdrawing via single token\r\n     * @param self Swap struct to read from\r\n     * @param metaSwapStorage MetaSwap struct to read from\r\n     * @param tokenAmount the amount to withdraw in the pool's precision\r\n     * @param tokenIndex which token will be withdrawn\r\n     * @return dy the amount of token user will receive\r\n     */\r\n    function calculateWithdrawOneToken(\r\n        SwapUtils.Swap storage self,\r\n        MetaSwap storage metaSwapStorage,\r\n        uint256 tokenAmount,\r\n        uint8 tokenIndex\r\n    ) external view returns (uint256 dy) {\r\n        (dy, ) = _calculateWithdrawOneToken(\r\n            self,\r\n            tokenAmount,\r\n            tokenIndex,\r\n            _getBaseVirtualPrice(metaSwapStorage),\r\n            self.lpToken.totalSupply()\r\n        );\r\n    }\r\n\r\n    function _calculateWithdrawOneToken(\r\n        SwapUtils.Swap storage self,\r\n        uint256 tokenAmount,\r\n        uint8 tokenIndex,\r\n        uint256 baseVirtualPrice,\r\n        uint256 totalSupply\r\n    ) internal view returns (uint256, uint256) {\r\n        uint256 dy;\r\n        uint256 dySwapFee;\r\n\r\n        {\r\n            uint256 currentY;\r\n            uint256 newY;\r\n\r\n            // Calculate how much to withdraw\r\n            (dy, newY, currentY) = _calculateWithdrawOneTokenDY(\r\n                self,\r\n                tokenIndex,\r\n                tokenAmount,\r\n                baseVirtualPrice,\r\n                totalSupply\r\n            );\r\n\r\n            // Calculate the associated swap fee\r\n            dySwapFee = currentY\r\n                .sub(newY)\r\n                .div(self.tokenPrecisionMultipliers[tokenIndex])\r\n                .sub(dy);\r\n        }\r\n\r\n        return (dy, dySwapFee);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the dy of withdrawing in one token\r\n     * @param self Swap struct to read from\r\n     * @param tokenIndex which token will be withdrawn\r\n     * @param tokenAmount the amount to withdraw in the pools precision\r\n     * @param baseVirtualPrice the virtual price of the base swap's LP token\r\n     * @return the dy excluding swap fee, the new y after withdrawing one token, and current y\r\n     */\r\n    function _calculateWithdrawOneTokenDY(\r\n        SwapUtils.Swap storage self,\r\n        uint8 tokenIndex,\r\n        uint256 tokenAmount,\r\n        uint256 baseVirtualPrice,\r\n        uint256 totalSupply\r\n    )\r\n        internal\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        )\r\n    {\r\n        // Get the current D, then solve the stableswap invariant\r\n        // y_i for D - tokenAmount\r\n        uint256[] memory xp = _xp(self, baseVirtualPrice);\r\n        require(tokenIndex < xp.length, \"Token index out of range\");\r\n\r\n        CalculateWithdrawOneTokenDYInfo\r\n            memory v = CalculateWithdrawOneTokenDYInfo(\r\n                0,\r\n                0,\r\n                0,\r\n                0,\r\n                self._getAPrecise(),\r\n                0\r\n            );\r\n        v.d0 = SwapUtils.getD(xp, v.preciseA);\r\n        v.d1 = v.d0.sub(tokenAmount.mul(v.d0).div(totalSupply));\r\n\r\n        require(tokenAmount <= xp[tokenIndex], \"Withdraw exceeds available\");\r\n\r\n        v.newY = SwapUtils.getYD(v.preciseA, tokenIndex, xp, v.d1);\r\n\r\n        uint256[] memory xpReduced = new uint256[](xp.length);\r\n\r\n        v.feePerToken = SwapUtils._feePerToken(self.swapFee, xp.length);\r\n        for (uint256 i = 0; i < xp.length; i++) {\r\n            v.xpi = xp[i];\r\n            // if i == tokenIndex, dxExpected = xp[i] * d1 / d0 - newY\r\n            // else dxExpected = xp[i] - (xp[i] * d1 / d0)\r\n            // xpReduced[i] -= dxExpected * fee / FEE_DENOMINATOR\r\n            xpReduced[i] = v.xpi.sub(\r\n                (\r\n                    (i == tokenIndex)\r\n                        ? v.xpi.mul(v.d1).div(v.d0).sub(v.newY)\r\n                        : v.xpi.sub(v.xpi.mul(v.d1).div(v.d0))\r\n                ).mul(v.feePerToken).div(FEE_DENOMINATOR)\r\n            );\r\n        }\r\n\r\n        uint256 dy = xpReduced[tokenIndex].sub(\r\n            SwapUtils.getYD(v.preciseA, tokenIndex, xpReduced, v.d1)\r\n        );\r\n\r\n        if (tokenIndex == xp.length.sub(1)) {\r\n            dy = dy.mul(BASE_VIRTUAL_PRICE_PRECISION).div(baseVirtualPrice);\r\n            v.newY = v.newY.mul(BASE_VIRTUAL_PRICE_PRECISION).div(\r\n                baseVirtualPrice\r\n            );\r\n            xp[tokenIndex] = xp[tokenIndex]\r\n                .mul(BASE_VIRTUAL_PRICE_PRECISION)\r\n                .div(baseVirtualPrice);\r\n        }\r\n        dy = dy.sub(1).div(self.tokenPrecisionMultipliers[tokenIndex]);\r\n\r\n        return (dy, v.newY, xp[tokenIndex]);\r\n    }\r\n\r\n    /**\r\n     * @notice Given a set of balances and precision multipliers, return the\r\n     * precision-adjusted balances. The last element will also get scaled up by\r\n     * the given baseVirtualPrice.\r\n     *\r\n     * @param balances an array of token balances, in their native precisions.\r\n     * These should generally correspond with pooled tokens.\r\n     *\r\n     * @param precisionMultipliers an array of multipliers, corresponding to\r\n     * the amounts in the balances array. When multiplied together they\r\n     * should yield amounts at the pool's precision.\r\n     *\r\n     * @param baseVirtualPrice the base virtual price to scale the balance of the\r\n     * base Swap's LP token.\r\n     *\r\n     * @return an array of amounts \"scaled\" to the pool's precision\r\n     */\r\n    function _xp(\r\n        uint256[] memory balances,\r\n        uint256[] memory precisionMultipliers,\r\n        uint256 baseVirtualPrice\r\n    ) internal pure returns (uint256[] memory) {\r\n        uint256[] memory xp = SwapUtils._xp(balances, precisionMultipliers);\r\n        uint256 baseLPTokenIndex = balances.length.sub(1);\r\n        xp[baseLPTokenIndex] = xp[baseLPTokenIndex].mul(baseVirtualPrice).div(\r\n            BASE_VIRTUAL_PRICE_PRECISION\r\n        );\r\n        return xp;\r\n    }\r\n\r\n    /**\r\n     * @notice Return the precision-adjusted balances of all tokens in the pool\r\n     * @param self Swap struct to read from\r\n     * @return the pool balances \"scaled\" to the pool's precision, allowing\r\n     * them to be more easily compared.\r\n     */\r\n    function _xp(SwapUtils.Swap storage self, uint256 baseVirtualPrice)\r\n        internal\r\n        view\r\n        returns (uint256[] memory)\r\n    {\r\n        return\r\n            _xp(\r\n                self.balances,\r\n                self.tokenPrecisionMultipliers,\r\n                baseVirtualPrice\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @notice Get the virtual price, to help calculate profit\r\n     * @param self Swap struct to read from\r\n     * @param metaSwapStorage MetaSwap struct to read from\r\n     * @return the virtual price, scaled to precision of BASE_VIRTUAL_PRICE_PRECISION\r\n     */\r\n    function getVirtualPrice(\r\n        SwapUtils.Swap storage self,\r\n        MetaSwap storage metaSwapStorage\r\n    ) external view returns (uint256) {\r\n        uint256 d = SwapUtils.getD(\r\n            _xp(\r\n                self.balances,\r\n                self.tokenPrecisionMultipliers,\r\n                _getBaseVirtualPrice(metaSwapStorage)\r\n            ),\r\n            self._getAPrecise()\r\n        );\r\n        uint256 supply = self.lpToken.totalSupply();\r\n        if (supply != 0) {\r\n            return d.mul(BASE_VIRTUAL_PRICE_PRECISION).div(supply);\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * @notice Externally calculates a swap between two tokens. The SwapUtils.Swap storage and\r\n     * MetaSwap storage should be from the same MetaSwap contract.\r\n     * @param self Swap struct to read from\r\n     * @param metaSwapStorage MetaSwap struct from the same contract\r\n     * @param tokenIndexFrom the token to sell\r\n     * @param tokenIndexTo the token to buy\r\n     * @param dx the number of tokens to sell. If the token charges a fee on transfers,\r\n     * use the amount that gets transferred after the fee.\r\n     * @return dy the number of tokens the user will get\r\n     */\r\n    function calculateSwap(\r\n        SwapUtils.Swap storage self,\r\n        MetaSwap storage metaSwapStorage,\r\n        uint8 tokenIndexFrom,\r\n        uint8 tokenIndexTo,\r\n        uint256 dx\r\n    ) external view returns (uint256 dy) {\r\n        (dy, ) = _calculateSwap(\r\n            self,\r\n            tokenIndexFrom,\r\n            tokenIndexTo,\r\n            dx,\r\n            _getBaseVirtualPrice(metaSwapStorage)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Internally calculates a swap between two tokens.\r\n     *\r\n     * @dev The caller is expected to transfer the actual amounts (dx and dy)\r\n     * using the token contracts.\r\n     *\r\n     * @param self Swap struct to read from\r\n     * @param tokenIndexFrom the token to sell\r\n     * @param tokenIndexTo the token to buy\r\n     * @param dx the number of tokens to sell. If the token charges a fee on transfers,\r\n     * use the amount that gets transferred after the fee.\r\n     * @param baseVirtualPrice the virtual price of the base LP token\r\n     * @return dy the number of tokens the user will get and dyFee the associated fee\r\n     */\r\n    function _calculateSwap(\r\n        SwapUtils.Swap storage self,\r\n        uint8 tokenIndexFrom,\r\n        uint8 tokenIndexTo,\r\n        uint256 dx,\r\n        uint256 baseVirtualPrice\r\n    ) internal view returns (uint256 dy, uint256 dyFee) {\r\n        uint256[] memory xp = _xp(self, baseVirtualPrice);\r\n        require(\r\n            tokenIndexFrom < xp.length && tokenIndexTo < xp.length,\r\n            \"Token index out of range\"\r\n        );\r\n        uint256 baseLPTokenIndex = xp.length.sub(1);\r\n\r\n        uint256 x = dx.mul(self.tokenPrecisionMultipliers[tokenIndexFrom]);\r\n        if (tokenIndexFrom == baseLPTokenIndex) {\r\n            // When swapping from a base Swap token, scale up dx by its virtual price\r\n            x = x.mul(baseVirtualPrice).div(BASE_VIRTUAL_PRICE_PRECISION);\r\n        }\r\n        x = x.add(xp[tokenIndexFrom]);\r\n\r\n        uint256 y = SwapUtils.getY(\r\n            self._getAPrecise(),\r\n            tokenIndexFrom,\r\n            tokenIndexTo,\r\n            x,\r\n            xp\r\n        );\r\n        dy = xp[tokenIndexTo].sub(y).sub(1);\r\n\r\n        if (tokenIndexTo == baseLPTokenIndex) {\r\n            // When swapping to a base Swap token, scale down dy by its virtual price\r\n            dy = dy.mul(BASE_VIRTUAL_PRICE_PRECISION).div(baseVirtualPrice);\r\n        }\r\n\r\n        dyFee = dy.mul(self.swapFee).div(FEE_DENOMINATOR);\r\n        dy = dy.sub(dyFee);\r\n\r\n        dy = dy.div(self.tokenPrecisionMultipliers[tokenIndexTo]);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates the expected return amount from swapping between\r\n     * the pooled tokens and the underlying tokens of the base Swap pool.\r\n     *\r\n     * @param self Swap struct to read from\r\n     * @param metaSwapStorage MetaSwap struct from the same contract\r\n     * @param tokenIndexFrom the token to sell\r\n     * @param tokenIndexTo the token to buy\r\n     * @param dx the number of tokens to sell. If the token charges a fee on transfers,\r\n     * use the amount that gets transferred after the fee.\r\n     * @return dy the number of tokens the user will get\r\n     */\r\n    function calculateSwapUnderlying(\r\n        SwapUtils.Swap storage self,\r\n        MetaSwap storage metaSwapStorage,\r\n        uint8 tokenIndexFrom,\r\n        uint8 tokenIndexTo,\r\n        uint256 dx\r\n    ) external view returns (uint256) {\r\n        CalculateSwapUnderlyingInfo memory v = CalculateSwapUnderlyingInfo(\r\n            _getBaseVirtualPrice(metaSwapStorage),\r\n            metaSwapStorage.baseSwap,\r\n            0,\r\n            uint8(metaSwapStorage.baseTokens.length),\r\n            0,\r\n            0,\r\n            0\r\n        );\r\n\r\n        uint256[] memory xp = _xp(self, v.baseVirtualPrice);\r\n        v.baseLPTokenIndex = uint8(xp.length.sub(1));\r\n        {\r\n            uint8 maxRange = v.baseLPTokenIndex + v.baseTokensLength;\r\n            require(\r\n                tokenIndexFrom < maxRange && tokenIndexTo < maxRange,\r\n                \"Token index out of range\"\r\n            );\r\n        }\r\n\r\n        if (tokenIndexFrom < v.baseLPTokenIndex) {\r\n            // tokenFrom is from this pool\r\n            v.x = xp[tokenIndexFrom].add(\r\n                dx.mul(self.tokenPrecisionMultipliers[tokenIndexFrom])\r\n            );\r\n        } else {\r\n            // tokenFrom is from the base pool\r\n            tokenIndexFrom = tokenIndexFrom - v.baseLPTokenIndex;\r\n            if (tokenIndexTo < v.baseLPTokenIndex) {\r\n                uint256[] memory baseInputs = new uint256[](v.baseTokensLength);\r\n                baseInputs[tokenIndexFrom] = dx;\r\n                v.x = v\r\n                    .baseSwap\r\n                    .calculateTokenAmount(baseInputs, true)\r\n                    .mul(v.baseVirtualPrice)\r\n                    .div(BASE_VIRTUAL_PRICE_PRECISION);\r\n                // when adding to the base pool,you pay approx 50% of the swap fee\r\n                v.x = v\r\n                    .x\r\n                    .sub(\r\n                        v.x.mul(_getBaseSwapFee(metaSwapStorage.baseSwap)).div(\r\n                            FEE_DENOMINATOR.mul(2)\r\n                        )\r\n                    )\r\n                    .add(xp[v.baseLPTokenIndex]);\r\n            } else {\r\n                // both from and to are from the base pool\r\n                return\r\n                    v.baseSwap.calculateSwap(\r\n                        tokenIndexFrom,\r\n                        tokenIndexTo - v.baseLPTokenIndex,\r\n                        dx\r\n                    );\r\n            }\r\n            tokenIndexFrom = v.baseLPTokenIndex;\r\n        }\r\n\r\n        v.metaIndexTo = v.baseLPTokenIndex;\r\n        if (tokenIndexTo < v.baseLPTokenIndex) {\r\n            v.metaIndexTo = tokenIndexTo;\r\n        }\r\n\r\n        {\r\n            uint256 y = SwapUtils.getY(\r\n                self._getAPrecise(),\r\n                tokenIndexFrom,\r\n                v.metaIndexTo,\r\n                v.x,\r\n                xp\r\n            );\r\n            v.dy = xp[v.metaIndexTo].sub(y).sub(1);\r\n            uint256 dyFee = v.dy.mul(self.swapFee).div(FEE_DENOMINATOR);\r\n            v.dy = v.dy.sub(dyFee);\r\n        }\r\n\r\n        if (tokenIndexTo < v.baseLPTokenIndex) {\r\n            // tokenTo is from this pool\r\n            v.dy = v.dy.div(self.tokenPrecisionMultipliers[v.metaIndexTo]);\r\n        } else {\r\n            // tokenTo is from the base pool\r\n            v.dy = v.baseSwap.calculateRemoveLiquidityOneToken(\r\n                v.dy.mul(BASE_VIRTUAL_PRICE_PRECISION).div(v.baseVirtualPrice),\r\n                tokenIndexTo - v.baseLPTokenIndex\r\n            );\r\n        }\r\n\r\n        return v.dy;\r\n    }\r\n\r\n    /**\r\n     * @notice A simple method to calculate prices from deposits or\r\n     * withdrawals, excluding fees but including slippage. This is\r\n     * helpful as an input into the various \"min\" parameters on calls\r\n     * to fight front-running\r\n     *\r\n     * @dev This shouldn't be used outside frontends for user estimates.\r\n     *\r\n     * @param self Swap struct to read from\r\n     * @param metaSwapStorage MetaSwap struct to read from\r\n     * @param amounts an array of token amounts to deposit or withdrawal,\r\n     * corresponding to pooledTokens. The amount should be in each\r\n     * pooled token's native precision. If a token charges a fee on transfers,\r\n     * use the amount that gets transferred after the fee.\r\n     * @param deposit whether this is a deposit or a withdrawal\r\n     * @return if deposit was true, total amount of lp token that will be minted and if\r\n     * deposit was false, total amount of lp token that will be burned\r\n     */\r\n    function calculateTokenAmount(\r\n        SwapUtils.Swap storage self,\r\n        MetaSwap storage metaSwapStorage,\r\n        uint256[] calldata amounts,\r\n        bool deposit\r\n    ) external view returns (uint256) {\r\n        uint256 a = self._getAPrecise();\r\n        uint256 d0;\r\n        uint256 d1;\r\n        {\r\n            uint256 baseVirtualPrice = _getBaseVirtualPrice(metaSwapStorage);\r\n            uint256[] memory balances1 = self.balances;\r\n            uint256[] memory tokenPrecisionMultipliers = self\r\n                .tokenPrecisionMultipliers;\r\n            uint256 numTokens = balances1.length;\r\n            d0 = SwapUtils.getD(\r\n                _xp(balances1, tokenPrecisionMultipliers, baseVirtualPrice),\r\n                a\r\n            );\r\n            for (uint256 i = 0; i < numTokens; i++) {\r\n                if (deposit) {\r\n                    balances1[i] = balances1[i].add(amounts[i]);\r\n                } else {\r\n                    balances1[i] = balances1[i].sub(\r\n                        amounts[i],\r\n                        \"Cannot withdraw more than available\"\r\n                    );\r\n                }\r\n            }\r\n            d1 = SwapUtils.getD(\r\n                _xp(balances1, tokenPrecisionMultipliers, baseVirtualPrice),\r\n                a\r\n            );\r\n        }\r\n        uint256 totalSupply = self.lpToken.totalSupply();\r\n\r\n        if (deposit) {\r\n            return d1.sub(d0).mul(totalSupply).div(d0);\r\n        } else {\r\n            return d0.sub(d1).mul(totalSupply).div(d0);\r\n        }\r\n    }\r\n\r\n    /*** STATE MODIFYING FUNCTIONS ***/\r\n\r\n    /**\r\n     * @notice swap two tokens in the pool\r\n     * @param self Swap struct to read from and write to\r\n     * @param metaSwapStorage MetaSwap struct to read from and write to\r\n     * @param tokenIndexFrom the token the user wants to sell\r\n     * @param tokenIndexTo the token the user wants to buy\r\n     * @param dx the amount of tokens the user wants to sell\r\n     * @param minDy the min amount the user would like to receive, or revert.\r\n     * @return amount of token user received on swap\r\n     */\r\n    function swap(\r\n        SwapUtils.Swap storage self,\r\n        MetaSwap storage metaSwapStorage,\r\n        uint8 tokenIndexFrom,\r\n        uint8 tokenIndexTo,\r\n        uint256 dx,\r\n        uint256 minDy\r\n    ) external returns (uint256) {\r\n        {\r\n            uint256 pooledTokensLength = self.pooledTokens.length;\r\n            require(\r\n                tokenIndexFrom < pooledTokensLength &&\r\n                    tokenIndexTo < pooledTokensLength,\r\n                \"Token index is out of range\"\r\n            );\r\n        }\r\n\r\n        uint256 transferredDx;\r\n        {\r\n            IERC20 tokenFrom = self.pooledTokens[tokenIndexFrom];\r\n            require(\r\n                dx <= tokenFrom.balanceOf(msg.sender),\r\n                \"Cannot swap more than you own\"\r\n            );\r\n\r\n            {\r\n                // Transfer tokens first to see if a fee was charged on transfer\r\n                uint256 beforeBalance = tokenFrom.balanceOf(address(this));\r\n                tokenFrom.safeTransferFrom(msg.sender, address(this), dx);\r\n\r\n                // Use the actual transferred amount for AMM math\r\n                transferredDx = tokenFrom.balanceOf(address(this)).sub(\r\n                    beforeBalance\r\n                );\r\n            }\r\n        }\r\n\r\n        (uint256 dy, uint256 dyFee) = _calculateSwap(\r\n            self,\r\n            tokenIndexFrom,\r\n            tokenIndexTo,\r\n            transferredDx,\r\n            _updateBaseVirtualPrice(metaSwapStorage)\r\n        );\r\n        require(dy >= minDy, \"Swap didn't result in min tokens\");\r\n\r\n        uint256 dyAdminFee = dyFee.mul(self.adminFee).div(FEE_DENOMINATOR).div(\r\n            self.tokenPrecisionMultipliers[tokenIndexTo]\r\n        );\r\n\r\n        self.balances[tokenIndexFrom] = self.balances[tokenIndexFrom].add(\r\n            transferredDx\r\n        );\r\n        self.balances[tokenIndexTo] = self.balances[tokenIndexTo].sub(dy).sub(\r\n            dyAdminFee\r\n        );\r\n\r\n        self.pooledTokens[tokenIndexTo].safeTransfer(msg.sender, dy);\r\n\r\n        emit TokenSwap(\r\n            msg.sender,\r\n            transferredDx,\r\n            dy,\r\n            tokenIndexFrom,\r\n            tokenIndexTo\r\n        );\r\n\r\n        return dy;\r\n    }\r\n\r\n    /**\r\n     * @notice Swaps with the underlying tokens of the base Swap pool. For this function,\r\n     * the token indices are flattened out so that underlying tokens are represented\r\n     * in the indices.\r\n     * @dev Since this calls multiple external functions during the execution,\r\n     * it is recommended to protect any function that depends on this with reentrancy guards.\r\n     * @param self Swap struct to read from and write to\r\n     * @param metaSwapStorage MetaSwap struct to read from and write to\r\n     * @param tokenIndexFrom the token the user wants to sell\r\n     * @param tokenIndexTo the token the user wants to buy\r\n     * @param dx the amount of tokens the user wants to sell\r\n     * @param minDy the min amount the user would like to receive, or revert.\r\n     * @return amount of token user received on swap\r\n     */\r\n    function swapUnderlying(\r\n        SwapUtils.Swap storage self,\r\n        MetaSwap storage metaSwapStorage,\r\n        uint8 tokenIndexFrom,\r\n        uint8 tokenIndexTo,\r\n        uint256 dx,\r\n        uint256 minDy\r\n    ) external returns (uint256) {\r\n        SwapUnderlyingInfo memory v = SwapUnderlyingInfo(\r\n            0,\r\n            0,\r\n            0,\r\n            self.tokenPrecisionMultipliers,\r\n            self.balances,\r\n            metaSwapStorage.baseTokens,\r\n            IERC20(address(0)),\r\n            0,\r\n            IERC20(address(0)),\r\n            0,\r\n            _updateBaseVirtualPrice(metaSwapStorage)\r\n        );\r\n\r\n        uint8 baseLPTokenIndex = uint8(v.oldBalances.length.sub(1));\r\n\r\n        {\r\n            uint8 maxRange = uint8(baseLPTokenIndex + v.baseTokens.length);\r\n            require(\r\n                tokenIndexFrom < maxRange && tokenIndexTo < maxRange,\r\n                \"Token index out of range\"\r\n            );\r\n        }\r\n\r\n        ISwap baseSwap = metaSwapStorage.baseSwap;\r\n\r\n        // Find the address of the token swapping from and the index in MetaSwap's token list\r\n        if (tokenIndexFrom < baseLPTokenIndex) {\r\n            v.tokenFrom = self.pooledTokens[tokenIndexFrom];\r\n            v.metaIndexFrom = tokenIndexFrom;\r\n        } else {\r\n            v.tokenFrom = v.baseTokens[tokenIndexFrom - baseLPTokenIndex];\r\n            v.metaIndexFrom = baseLPTokenIndex;\r\n        }\r\n\r\n        // Find the address of the token swapping to and the index in MetaSwap's token list\r\n        if (tokenIndexTo < baseLPTokenIndex) {\r\n            v.tokenTo = self.pooledTokens[tokenIndexTo];\r\n            v.metaIndexTo = tokenIndexTo;\r\n        } else {\r\n            v.tokenTo = v.baseTokens[tokenIndexTo - baseLPTokenIndex];\r\n            v.metaIndexTo = baseLPTokenIndex;\r\n        }\r\n\r\n        // Check for possible fee on transfer\r\n        v.dx = v.tokenFrom.balanceOf(address(this));\r\n        v.tokenFrom.safeTransferFrom(msg.sender, address(this), dx);\r\n        v.dx = v.tokenFrom.balanceOf(address(this)).sub(v.dx); // update dx in case of fee on transfer\r\n\r\n        if (\r\n            tokenIndexFrom < baseLPTokenIndex || tokenIndexTo < baseLPTokenIndex\r\n        ) {\r\n            // Either one of the tokens belongs to the MetaSwap tokens list\r\n            uint256[] memory xp = _xp(\r\n                v.oldBalances,\r\n                v.tokenPrecisionMultipliers,\r\n                v.baseVirtualPrice\r\n            );\r\n\r\n            if (tokenIndexFrom < baseLPTokenIndex) {\r\n                // Swapping from a MetaSwap token\r\n                v.x = xp[tokenIndexFrom].add(\r\n                    dx.mul(v.tokenPrecisionMultipliers[tokenIndexFrom])\r\n                );\r\n            } else {\r\n                // Swapping from one of the tokens hosted in the base Swap\r\n                // This case requires adding the underlying token to the base Swap, then\r\n                // using the base LP token to swap to the desired token\r\n                uint256[] memory baseAmounts = new uint256[](\r\n                    v.baseTokens.length\r\n                );\r\n                baseAmounts[tokenIndexFrom - baseLPTokenIndex] = v.dx;\r\n\r\n                // Add liquidity to the base Swap contract and receive base LP token\r\n                v.dx = baseSwap.addLiquidity(baseAmounts, 0, block.timestamp);\r\n\r\n                // Calculate the value of total amount of baseLPToken we end up with\r\n                v.x = v\r\n                    .dx\r\n                    .mul(v.baseVirtualPrice)\r\n                    .div(BASE_VIRTUAL_PRICE_PRECISION)\r\n                    .add(xp[baseLPTokenIndex]);\r\n            }\r\n\r\n            // Calculate how much to withdraw in MetaSwap level and the the associated swap fee\r\n            uint256 dyFee;\r\n            {\r\n                uint256 y = SwapUtils.getY(\r\n                    self._getAPrecise(),\r\n                    v.metaIndexFrom,\r\n                    v.metaIndexTo,\r\n                    v.x,\r\n                    xp\r\n                );\r\n                v.dy = xp[v.metaIndexTo].sub(y).sub(1);\r\n                if (tokenIndexTo >= baseLPTokenIndex) {\r\n                    // When swapping to a base Swap token, scale down dy by its virtual price\r\n                    v.dy = v.dy.mul(BASE_VIRTUAL_PRICE_PRECISION).div(\r\n                        v.baseVirtualPrice\r\n                    );\r\n                }\r\n                dyFee = v.dy.mul(self.swapFee).div(FEE_DENOMINATOR);\r\n                v.dy = v.dy.sub(dyFee).div(\r\n                    v.tokenPrecisionMultipliers[v.metaIndexTo]\r\n                );\r\n            }\r\n\r\n            // Update the balances array according to the calculated input and output amount\r\n            {\r\n                uint256 dyAdminFee = dyFee.mul(self.adminFee).div(\r\n                    FEE_DENOMINATOR\r\n                );\r\n                dyAdminFee = dyAdminFee.div(\r\n                    v.tokenPrecisionMultipliers[v.metaIndexTo]\r\n                );\r\n                self.balances[v.metaIndexFrom] = v\r\n                    .oldBalances[v.metaIndexFrom]\r\n                    .add(v.dx);\r\n                self.balances[v.metaIndexTo] = v\r\n                    .oldBalances[v.metaIndexTo]\r\n                    .sub(v.dy)\r\n                    .sub(dyAdminFee);\r\n            }\r\n\r\n            if (tokenIndexTo >= baseLPTokenIndex) {\r\n                // When swapping to a token that belongs to the base Swap, burn the LP token\r\n                // and withdraw the desired token from the base pool\r\n                uint256 oldBalance = v.tokenTo.balanceOf(address(this));\r\n                baseSwap.removeLiquidityOneToken(\r\n                    v.dy,\r\n                    tokenIndexTo - baseLPTokenIndex,\r\n                    0,\r\n                    block.timestamp\r\n                );\r\n                v.dy = v.tokenTo.balanceOf(address(this)) - oldBalance;\r\n            }\r\n\r\n            // Check the amount of token to send meets minDy\r\n            require(v.dy >= minDy, \"Swap didn't result in min tokens\");\r\n        } else {\r\n            // Both tokens are from the base Swap pool\r\n            // Do a swap through the base Swap\r\n            v.dy = v.tokenTo.balanceOf(address(this));\r\n            baseSwap.swap(\r\n                tokenIndexFrom - baseLPTokenIndex,\r\n                tokenIndexTo - baseLPTokenIndex,\r\n                v.dx,\r\n                minDy,\r\n                block.timestamp\r\n            );\r\n            v.dy = v.tokenTo.balanceOf(address(this)).sub(v.dy);\r\n        }\r\n\r\n        // Send the desired token to the caller\r\n        v.tokenTo.safeTransfer(msg.sender, v.dy);\r\n\r\n        emit TokenSwapUnderlying(\r\n            msg.sender,\r\n            dx,\r\n            v.dy,\r\n            tokenIndexFrom,\r\n            tokenIndexTo\r\n        );\r\n\r\n        return v.dy;\r\n    }\r\n\r\n    /**\r\n     * @notice Add liquidity to the pool\r\n     * @param self Swap struct to read from and write to\r\n     * @param metaSwapStorage MetaSwap struct to read from and write to\r\n     * @param amounts the amounts of each token to add, in their native precision\r\n     * @param minToMint the minimum LP tokens adding this amount of liquidity\r\n     * should mint, otherwise revert. Handy for front-running mitigation\r\n     * allowed addresses. If the pool is not in the guarded launch phase, this parameter will be ignored.\r\n     * @return amount of LP token user received\r\n     */\r\n    function addLiquidity(\r\n        SwapUtils.Swap storage self,\r\n        MetaSwap storage metaSwapStorage,\r\n        uint256[] memory amounts,\r\n        uint256 minToMint\r\n    ) external returns (uint256) {\r\n        IERC20[] memory pooledTokens = self.pooledTokens;\r\n        require(\r\n            amounts.length == pooledTokens.length,\r\n            \"Amounts must match pooled tokens\"\r\n        );\r\n\r\n        uint256[] memory fees = new uint256[](pooledTokens.length);\r\n\r\n        // current state\r\n        ManageLiquidityInfo memory v = ManageLiquidityInfo(\r\n            0,\r\n            0,\r\n            0,\r\n            self.lpToken,\r\n            0,\r\n            self._getAPrecise(),\r\n            _updateBaseVirtualPrice(metaSwapStorage),\r\n            self.tokenPrecisionMultipliers,\r\n            self.balances\r\n        );\r\n        v.totalSupply = v.lpToken.totalSupply();\r\n\r\n        if (v.totalSupply != 0) {\r\n            v.d0 = SwapUtils.getD(\r\n                _xp(\r\n                    v.newBalances,\r\n                    v.tokenPrecisionMultipliers,\r\n                    v.baseVirtualPrice\r\n                ),\r\n                v.preciseA\r\n            );\r\n        }\r\n\r\n        for (uint256 i = 0; i < pooledTokens.length; i++) {\r\n            require(\r\n                v.totalSupply != 0 || amounts[i] > 0,\r\n                \"Must supply all tokens in pool\"\r\n            );\r\n\r\n            // Transfer tokens first to see if a fee was charged on transfer\r\n            if (amounts[i] != 0) {\r\n                uint256 beforeBalance = pooledTokens[i].balanceOf(\r\n                    address(this)\r\n                );\r\n                pooledTokens[i].safeTransferFrom(\r\n                    msg.sender,\r\n                    address(this),\r\n                    amounts[i]\r\n                );\r\n\r\n                // Update the amounts[] with actual transfer amount\r\n                amounts[i] = pooledTokens[i].balanceOf(address(this)).sub(\r\n                    beforeBalance\r\n                );\r\n            }\r\n\r\n            v.newBalances[i] = v.newBalances[i].add(amounts[i]);\r\n        }\r\n\r\n        // invariant after change\r\n        v.d1 = SwapUtils.getD(\r\n            _xp(v.newBalances, v.tokenPrecisionMultipliers, v.baseVirtualPrice),\r\n            v.preciseA\r\n        );\r\n        require(v.d1 > v.d0, \"D should increase\");\r\n\r\n        // updated to reflect fees and calculate the user's LP tokens\r\n        v.d2 = v.d1;\r\n        uint256 toMint;\r\n\r\n        if (v.totalSupply != 0) {\r\n            uint256 feePerToken = SwapUtils._feePerToken(\r\n                self.swapFee,\r\n                pooledTokens.length\r\n            );\r\n            for (uint256 i = 0; i < pooledTokens.length; i++) {\r\n                uint256 idealBalance = v.d1.mul(self.balances[i]).div(v.d0);\r\n                fees[i] = feePerToken\r\n                    .mul(idealBalance.difference(v.newBalances[i]))\r\n                    .div(FEE_DENOMINATOR);\r\n                self.balances[i] = v.newBalances[i].sub(\r\n                    fees[i].mul(self.adminFee).div(FEE_DENOMINATOR)\r\n                );\r\n                v.newBalances[i] = v.newBalances[i].sub(fees[i]);\r\n            }\r\n            v.d2 = SwapUtils.getD(\r\n                _xp(\r\n                    v.newBalances,\r\n                    v.tokenPrecisionMultipliers,\r\n                    v.baseVirtualPrice\r\n                ),\r\n                v.preciseA\r\n            );\r\n            toMint = v.d2.sub(v.d0).mul(v.totalSupply).div(v.d0);\r\n        } else {\r\n            // the initial depositor doesn't pay fees\r\n            self.balances = v.newBalances;\r\n            toMint = v.d1;\r\n        }\r\n\r\n        require(toMint >= minToMint, \"Couldn't mint min requested\");\r\n\r\n        // mint the user's LP tokens\r\n        self.lpToken.mint(msg.sender, toMint);\r\n\r\n        emit AddLiquidity(\r\n            msg.sender,\r\n            amounts,\r\n            fees,\r\n            v.d1,\r\n            v.totalSupply.add(toMint)\r\n        );\r\n\r\n        return toMint;\r\n    }\r\n\r\n    /**\r\n     * @notice Remove liquidity from the pool all in one token.\r\n     * @param self Swap struct to read from and write to\r\n     * @param metaSwapStorage MetaSwap struct to read from and write to\r\n     * @param tokenAmount the amount of the lp tokens to burn\r\n     * @param tokenIndex the index of the token you want to receive\r\n     * @param minAmount the minimum amount to withdraw, otherwise revert\r\n     * @return amount chosen token that user received\r\n     */\r\n    function removeLiquidityOneToken(\r\n        SwapUtils.Swap storage self,\r\n        MetaSwap storage metaSwapStorage,\r\n        uint256 tokenAmount,\r\n        uint8 tokenIndex,\r\n        uint256 minAmount\r\n    ) external returns (uint256) {\r\n        LPToken lpToken = self.lpToken;\r\n        uint256 totalSupply = lpToken.totalSupply();\r\n        uint256 numTokens = self.pooledTokens.length;\r\n        require(tokenAmount <= lpToken.balanceOf(msg.sender), \">LP.balanceOf\");\r\n        require(tokenIndex < numTokens, \"Token not found\");\r\n\r\n        uint256 dyFee;\r\n        uint256 dy;\r\n\r\n        (dy, dyFee) = _calculateWithdrawOneToken(\r\n            self,\r\n            tokenAmount,\r\n            tokenIndex,\r\n            _updateBaseVirtualPrice(metaSwapStorage),\r\n            totalSupply\r\n        );\r\n\r\n        require(dy >= minAmount, \"dy < minAmount\");\r\n\r\n        // Update balances array\r\n        self.balances[tokenIndex] = self.balances[tokenIndex].sub(\r\n            dy.add(dyFee.mul(self.adminFee).div(FEE_DENOMINATOR))\r\n        );\r\n\r\n        // Burn the associated LP token from the caller and send the desired token\r\n        lpToken.burnFrom(msg.sender, tokenAmount);\r\n        self.pooledTokens[tokenIndex].safeTransfer(msg.sender, dy);\r\n\r\n        emit RemoveLiquidityOne(\r\n            msg.sender,\r\n            tokenAmount,\r\n            totalSupply,\r\n            tokenIndex,\r\n            dy\r\n        );\r\n\r\n        return dy;\r\n    }\r\n\r\n    /**\r\n     * @notice Remove liquidity from the pool, weighted differently than the\r\n     * pool's current balances.\r\n     *\r\n     * @param self Swap struct to read from and write to\r\n     * @param metaSwapStorage MetaSwap struct to read from and write to\r\n     * @param amounts how much of each token to withdraw\r\n     * @param maxBurnAmount the max LP token provider is willing to pay to\r\n     * remove liquidity. Useful as a front-running mitigation.\r\n     * @return actual amount of LP tokens burned in the withdrawal\r\n     */\r\n    function removeLiquidityImbalance(\r\n        SwapUtils.Swap storage self,\r\n        MetaSwap storage metaSwapStorage,\r\n        uint256[] memory amounts,\r\n        uint256 maxBurnAmount\r\n    ) public returns (uint256) {\r\n        // Using this struct to avoid stack too deep error\r\n        ManageLiquidityInfo memory v = ManageLiquidityInfo(\r\n            0,\r\n            0,\r\n            0,\r\n            self.lpToken,\r\n            0,\r\n            self._getAPrecise(),\r\n            _updateBaseVirtualPrice(metaSwapStorage),\r\n            self.tokenPrecisionMultipliers,\r\n            self.balances\r\n        );\r\n        v.totalSupply = v.lpToken.totalSupply();\r\n\r\n        require(\r\n            amounts.length == v.newBalances.length,\r\n            \"Amounts should match pool tokens\"\r\n        );\r\n        require(maxBurnAmount != 0, \"Must burn more than 0\");\r\n\r\n        uint256 feePerToken = SwapUtils._feePerToken(\r\n            self.swapFee,\r\n            v.newBalances.length\r\n        );\r\n\r\n        // Calculate how much LPToken should be burned\r\n        uint256[] memory fees = new uint256[](v.newBalances.length);\r\n        {\r\n            uint256[] memory balances1 = new uint256[](v.newBalances.length);\r\n\r\n            v.d0 = SwapUtils.getD(\r\n                _xp(\r\n                    v.newBalances,\r\n                    v.tokenPrecisionMultipliers,\r\n                    v.baseVirtualPrice\r\n                ),\r\n                v.preciseA\r\n            );\r\n            for (uint256 i = 0; i < v.newBalances.length; i++) {\r\n                balances1[i] = v.newBalances[i].sub(\r\n                    amounts[i],\r\n                    \"Cannot withdraw more than available\"\r\n                );\r\n            }\r\n            v.d1 = SwapUtils.getD(\r\n                _xp(balances1, v.tokenPrecisionMultipliers, v.baseVirtualPrice),\r\n                v.preciseA\r\n            );\r\n\r\n            for (uint256 i = 0; i < v.newBalances.length; i++) {\r\n                uint256 idealBalance = v.d1.mul(v.newBalances[i]).div(v.d0);\r\n                uint256 difference = idealBalance.difference(balances1[i]);\r\n                fees[i] = feePerToken.mul(difference).div(FEE_DENOMINATOR);\r\n                self.balances[i] = balances1[i].sub(\r\n                    fees[i].mul(self.adminFee).div(FEE_DENOMINATOR)\r\n                );\r\n                balances1[i] = balances1[i].sub(fees[i]);\r\n            }\r\n\r\n            v.d2 = SwapUtils.getD(\r\n                _xp(balances1, v.tokenPrecisionMultipliers, v.baseVirtualPrice),\r\n                v.preciseA\r\n            );\r\n        }\r\n\r\n        uint256 tokenAmount = v.d0.sub(v.d2).mul(v.totalSupply).div(v.d0);\r\n        require(tokenAmount != 0, \"Burnt amount cannot be zero\");\r\n\r\n        // Scale up by withdraw fee\r\n        tokenAmount = tokenAmount.add(1);\r\n\r\n        // Check for max burn amount\r\n        require(tokenAmount <= maxBurnAmount, \"tokenAmount > maxBurnAmount\");\r\n\r\n        // Burn the calculated amount of LPToken from the caller and send the desired tokens\r\n        v.lpToken.burnFrom(msg.sender, tokenAmount);\r\n        for (uint256 i = 0; i < v.newBalances.length; i++) {\r\n            self.pooledTokens[i].safeTransfer(msg.sender, amounts[i]);\r\n        }\r\n\r\n        emit RemoveLiquidityImbalance(\r\n            msg.sender,\r\n            amounts,\r\n            fees,\r\n            v.d1,\r\n            v.totalSupply.sub(tokenAmount)\r\n        );\r\n\r\n        return tokenAmount;\r\n    }\r\n\r\n    /**\r\n     * @notice Determines if the stored value of base Swap's virtual price is expired.\r\n     * If the last update was past the BASE_CACHE_EXPIRE_TIME, then update the stored value.\r\n     *\r\n     * @param metaSwapStorage MetaSwap struct to read from and write to\r\n     * @return base Swap's virtual price\r\n     */\r\n    function _updateBaseVirtualPrice(MetaSwap storage metaSwapStorage)\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        if (\r\n            block.timestamp >\r\n            metaSwapStorage.baseCacheLastUpdated + BASE_CACHE_EXPIRE_TIME\r\n        ) {\r\n            // When the cache is expired, update it\r\n            uint256 baseVirtualPrice = ISwap(metaSwapStorage.baseSwap)\r\n                .getVirtualPrice();\r\n            metaSwapStorage.baseVirtualPrice = baseVirtualPrice;\r\n            metaSwapStorage.baseCacheLastUpdated = block.timestamp;\r\n            return baseVirtualPrice;\r\n        } else {\r\n            return metaSwapStorage.baseVirtualPrice;\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/permissionless/PermissionlessMetaSwap.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"./PermissionlessSwap.sol\";\r\nimport \"./ShareProtocolFee.sol\";\r\nimport \"../meta/MetaSwapUtils.sol\";\r\nimport \"../meta/MetaSwap.sol\";\r\n\r\n/**\r\n * @title MetaSwap - A StableSwap implementation in solidity.\r\n * @notice This contract is responsible for custody of closely pegged assets (eg. group of stablecoins)\r\n * and automatic market making system. Users become an LP (Liquidity Provider) by depositing their tokens\r\n * in desired ratios for an exchange of the pool token that represents their share of the pool.\r\n * Users can burn pool tokens and withdraw their share of token(s).\r\n *\r\n * Each time a swap between the pooled tokens happens, a set fee incurs which effectively gets\r\n * distributed to the LPs.\r\n *\r\n * In case of emergencies, admin can pause additional deposits, swaps, or single-asset withdraws - which\r\n * stops the ratio of the tokens in the pool from changing.\r\n * Users can always withdraw their tokens via multi-asset withdraws.\r\n *\r\n * MetaSwap is a modified version of Swap that allows Swap's LP token to be utilized in pooling with other tokens.\r\n * As an example, if there is a Swap pool consisting of [DAI, USDC, USDT], then a MetaSwap pool can be created\r\n * with [sUSD, BaseSwapLPToken] to allow trades between either the LP token or the underlying tokens and sUSD.\r\n * Note that when interacting with MetaSwap, users cannot deposit or withdraw via underlying tokens. In that case,\r\n * `MetaSwapDeposit.sol` can be additionally deployed to allow interacting with unwrapped representations of the tokens.\r\n *\r\n * @dev Most of the logic is stored as a library `MetaSwapUtils` for the sake of reducing contract's\r\n * deployment size.\r\n */\r\ncontract PermissionlessMetaSwap is MetaSwap, ShareProtocolFee {\r\n    using PermissionlessSwapUtils for SwapUtils.Swap;\r\n\r\n    /**\r\n     * @notice Constructor for the PermissionlessSwap contract.\r\n     * @param _masterRegistry address of the MasterRegistry contract\r\n     */\r\n    constructor(IMasterRegistry _masterRegistry)\r\n        public\r\n        ShareProtocolFee(_masterRegistry)\r\n    {}\r\n\r\n    /*** ADMIN FUNCTIONS ***/\r\n\r\n    function initializeMetaSwap(\r\n        IERC20[] memory _pooledTokens,\r\n        uint8[] memory decimals,\r\n        string memory lpTokenName,\r\n        string memory lpTokenSymbol,\r\n        uint256 _a,\r\n        uint256 _fee,\r\n        uint256 _adminFee,\r\n        address lpTokenTargetAddress,\r\n        ISwap baseSwap\r\n    ) public payable virtual override initializer {\r\n        MetaSwap.initializeMetaSwap(\r\n            _pooledTokens,\r\n            decimals,\r\n            lpTokenName,\r\n            lpTokenSymbol,\r\n            _a,\r\n            _fee,\r\n            _adminFee,\r\n            lpTokenTargetAddress,\r\n            baseSwap\r\n        );\r\n        _updateFeeCollectorCache(MASTER_REGISTRY);\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraw all admin fees to the contract owner and the fee collector\r\n     */\r\n    function withdrawAdminFees()\r\n        external\r\n        payable\r\n        virtual\r\n        override(ShareProtocolFee, Swap)\r\n    {\r\n        require(\r\n            msg.sender == owner() || msg.sender == feeCollector,\r\n            \"Caller is not authorized\"\r\n        );\r\n        PermissionlessSwapUtils.withdrawAdminFees(\r\n            swapStorage,\r\n            owner(),\r\n            feeCollector\r\n        );\r\n    }\r\n}\r\n"
    },
    "contracts/permissionless/PermissionlessSwap.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"../Swap.sol\";\r\nimport \"../interfaces/IMasterRegistry.sol\";\r\nimport \"./PermissionlessSwapUtils.sol\";\r\nimport \"./ShareProtocolFee.sol\";\r\n\r\n/**\r\n * @title Swap - A StableSwap implementation in solidity.\r\n * @notice This contract is responsible for custody of closely pegged assets (eg. group of stablecoins)\r\n * and automatic market making system. Users become an LP (Liquidity Provider) by depositing their tokens\r\n * in desired ratios for an exchange of the pool token that represents their share of the pool.\r\n * Users can burn pool tokens and withdraw their share of token(s).\r\n *\r\n * Each time a swap between the pooled tokens happens, a set fee incurs which effectively gets\r\n * distributed to the LPs. Part of this fee is given to the creator of the pool as an Admin fee,\r\n * the amount of which is set when the pool is created. kinesis will collect to 50% of these Admin fees.\r\n *\r\n * In case of emergencies, admin can pause additional deposits, swaps, or single-asset withdraws - which\r\n * stops the ratio of the tokens in the pool from changing.\r\n * Users can always withdraw their tokens via multi-asset withdraws.\r\n *\r\n * @dev Most of the logic is stored as a library `PermissionlessSwapUtils` for the sake of reducing\r\n * contract's deployment size.\r\n */\r\ncontract PermissionlessSwap is Swap, ShareProtocolFee {\r\n    using PermissionlessSwapUtils for SwapUtils.Swap;\r\n\r\n    /**\r\n     * @notice Constructor for the PermissionlessSwap contract.\r\n     * @param _masterRegistry address of the MasterRegistry contract\r\n     */\r\n    constructor(IMasterRegistry _masterRegistry)\r\n        public\r\n        ShareProtocolFee(_masterRegistry)\r\n    {}\r\n\r\n    /*** ADMIN FUNCTIONS ***/\r\n\r\n    /**\r\n     * @notice Updates cached address of the fee collector\r\n     */\r\n    function initialize(\r\n        IERC20[] memory _pooledTokens,\r\n        uint8[] memory decimals,\r\n        string memory lpTokenName,\r\n        string memory lpTokenSymbol,\r\n        uint256 _a,\r\n        uint256 _fee,\r\n        uint256 _adminFee,\r\n        address lpTokenTargetAddress\r\n    ) public payable virtual override initializer {\r\n        Swap.initialize(\r\n            _pooledTokens,\r\n            decimals,\r\n            lpTokenName,\r\n            lpTokenSymbol,\r\n            _a,\r\n            _fee,\r\n            _adminFee,\r\n            lpTokenTargetAddress\r\n        );\r\n        _updateFeeCollectorCache(MASTER_REGISTRY);\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraw all admin fees to the contract owner and the fee collector.\r\n     */\r\n    function withdrawAdminFees()\r\n        external\r\n        payable\r\n        virtual\r\n        override(Swap, ShareProtocolFee)\r\n    {\r\n        require(\r\n            msg.sender == owner() || msg.sender == feeCollector,\r\n            \"Caller is not authorized\"\r\n        );\r\n        PermissionlessSwapUtils.withdrawAdminFees(\r\n            swapStorage,\r\n            owner(),\r\n            feeCollector\r\n        );\r\n    }\r\n}\r\n"
    },
    "contracts/permissionless/ShareProtocolFee.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\nimport \"../interfaces/IMasterRegistry.sol\";\r\n\r\nabstract contract ShareProtocolFee {\r\n    IMasterRegistry public immutable MASTER_REGISTRY;\r\n    bytes32 public constant FEE_COLLECTOR_NAME =\r\n        0x466565436f6c6c6563746f720000000000000000000000000000000000000000;\r\n    address public feeCollector;\r\n\r\n    constructor(IMasterRegistry _masterRegistry) public {\r\n        MASTER_REGISTRY = _masterRegistry;\r\n        _updateFeeCollectorCache(_masterRegistry);\r\n    }\r\n\r\n    /**\r\n     * @notice Updates cached address of the fee collector\r\n     */\r\n    function updateFeeCollectorCache() public payable virtual {\r\n        _updateFeeCollectorCache(MASTER_REGISTRY);\r\n    }\r\n\r\n    function _updateFeeCollectorCache(IMasterRegistry masterRegistry)\r\n        internal\r\n        virtual\r\n    {\r\n        address _feeCollector = masterRegistry.resolveNameToLatestAddress(\r\n            FEE_COLLECTOR_NAME\r\n        );\r\n        require(_feeCollector != address(0), \"Fee collector cannot be empty\");\r\n        feeCollector = _feeCollector;\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraws admin fees to appropriate addresses\r\n     */\r\n    function withdrawAdminFees() external payable virtual;\r\n}\r\n"
    },
    "contracts/meta/MetaSwap.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"../Swap.sol\";\r\nimport \"./MetaSwapUtils.sol\";\r\n\r\n/**\r\n * @title MetaSwap - A StableSwap implementation in solidity.\r\n * @notice This contract is responsible for custody of closely pegged assets (eg. group of stablecoins)\r\n * and automatic market making system. Users become an LP (Liquidity Provider) by depositing their tokens\r\n * in desired ratios for an exchange of the pool token that represents their share of the pool.\r\n * Users can burn pool tokens and withdraw their share of token(s).\r\n *\r\n * Each time a swap between the pooled tokens happens, a set fee incurs which effectively gets\r\n * distributed to the LPs.\r\n *\r\n * In case of emergencies, admin can pause additional deposits, swaps, or single-asset withdraws - which\r\n * stops the ratio of the tokens in the pool from changing.\r\n * Users can always withdraw their tokens via multi-asset withdraws.\r\n *\r\n * MetaSwap is a modified version of Swap that allows Swap's LP token to be utilized in pooling with other tokens.\r\n * As an example, if there is a Swap pool consisting of [DAI, USDC, USDT], then a MetaSwap pool can be created\r\n * with [sUSD, BaseSwapLPToken] to allow trades between either the LP token or the underlying tokens and sUSD.\r\n * Note that when interacting with MetaSwap, users cannot deposit or withdraw via underlying tokens. In that case,\r\n * `MetaSwapDeposit.sol` can be additionally deployed to allow interacting with unwrapped representations of the tokens.\r\n *\r\n * @dev Most of the logic is stored as a library `MetaSwapUtils` for the sake of reducing contract's\r\n * deployment size.\r\n */\r\ncontract MetaSwap is Swap {\r\n    using MetaSwapUtils for SwapUtils.Swap;\r\n\r\n    MetaSwapUtils.MetaSwap public metaSwapStorage;\r\n\r\n    uint256 constant MAX_UINT256 = 2**256 - 1;\r\n\r\n    /*** EVENTS ***/\r\n\r\n    // events replicated from SwapUtils to make the ABI easier for dumb\r\n    // clients\r\n    event TokenSwapUnderlying(\r\n        address indexed buyer,\r\n        uint256 tokensSold,\r\n        uint256 tokensBought,\r\n        uint128 soldId,\r\n        uint128 boughtId\r\n    );\r\n\r\n    /**\r\n     * @notice Get the virtual price, to help calculate profit\r\n     * @return the virtual price, scaled to the POOL_PRECISION_DECIMALS\r\n     */\r\n    function getVirtualPrice()\r\n        external\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return MetaSwapUtils.getVirtualPrice(swapStorage, metaSwapStorage);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate amount of tokens you receive on swap\r\n     * @param tokenIndexFrom the token the user wants to sell\r\n     * @param tokenIndexTo the token the user wants to buy\r\n     * @param dx the amount of tokens the user wants to sell. If the token charges\r\n     * a fee on transfers, use the amount that gets transferred after the fee.\r\n     * @return amount of tokens the user will receive\r\n     */\r\n    function calculateSwap(\r\n        uint8 tokenIndexFrom,\r\n        uint8 tokenIndexTo,\r\n        uint256 dx\r\n    ) external view virtual override returns (uint256) {\r\n        return\r\n            MetaSwapUtils.calculateSwap(\r\n                swapStorage,\r\n                metaSwapStorage,\r\n                tokenIndexFrom,\r\n                tokenIndexTo,\r\n                dx\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate amount of tokens you receive on swap. For this function,\r\n     * the token indices are flattened out so that underlying tokens are represented.\r\n     * @param tokenIndexFrom the token the user wants to sell\r\n     * @param tokenIndexTo the token the user wants to buy\r\n     * @param dx the amount of tokens the user wants to sell. If the token charges\r\n     * a fee on transfers, use the amount that gets transferred after the fee.\r\n     * @return amount of tokens the user will receive\r\n     */\r\n    function calculateSwapUnderlying(\r\n        uint8 tokenIndexFrom,\r\n        uint8 tokenIndexTo,\r\n        uint256 dx\r\n    ) external view virtual returns (uint256) {\r\n        return\r\n            MetaSwapUtils.calculateSwapUnderlying(\r\n                swapStorage,\r\n                metaSwapStorage,\r\n                tokenIndexFrom,\r\n                tokenIndexTo,\r\n                dx\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @notice A simple method to calculate prices from deposits or\r\n     * withdrawals, excluding fees but including slippage. This is\r\n     * helpful as an input into the various \"min\" parameters on calls\r\n     * to fight front-running\r\n     *\r\n     * @dev This shouldn't be used outside frontends for user estimates.\r\n     *\r\n     * @param amounts an array of token amounts to deposit or withdrawal,\r\n     * corresponding to pooledTokens. The amount should be in each\r\n     * pooled token's native precision. If a token charges a fee on transfers,\r\n     * use the amount that gets transferred after the fee.\r\n     * @param deposit whether this is a deposit or a withdrawal\r\n     * @return token amount the user will receive\r\n     */\r\n    function calculateTokenAmount(uint256[] calldata amounts, bool deposit)\r\n        external\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return\r\n            MetaSwapUtils.calculateTokenAmount(\r\n                swapStorage,\r\n                metaSwapStorage,\r\n                amounts,\r\n                deposit\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the amount of underlying token available to withdraw\r\n     * when withdrawing via only single token\r\n     * @param tokenAmount the amount of LP token to burn\r\n     * @param tokenIndex index of which token will be withdrawn\r\n     * @return availableTokenAmount calculated amount of underlying token\r\n     * available to withdraw\r\n     */\r\n    function calculateRemoveLiquidityOneToken(\r\n        uint256 tokenAmount,\r\n        uint8 tokenIndex\r\n    ) external view virtual override returns (uint256) {\r\n        return\r\n            MetaSwapUtils.calculateWithdrawOneToken(\r\n                swapStorage,\r\n                metaSwapStorage,\r\n                tokenAmount,\r\n                tokenIndex\r\n            );\r\n    }\r\n\r\n    /*** STATE MODIFYING FUNCTIONS ***/\r\n\r\n    /**\r\n     * @notice This overrides Swap's initialize function to prevent initializing\r\n     * without the address of the base Swap contract.\r\n     *\r\n     * @param _pooledTokens an array of ERC20s this pool will accept\r\n     * @param decimals the decimals to use for each pooled token,\r\n     * eg 8 for WBTC. Cannot be larger than POOL_PRECISION_DECIMALS\r\n     * @param lpTokenName the long-form name of the token to be deployed\r\n     * @param lpTokenSymbol the short symbol for the token to be deployed\r\n     * @param _a the amplification coefficient * n * (n - 1). See the\r\n     * StableSwap paper for details\r\n     * @param _fee default swap fee to be initialized with\r\n     * @param _adminFee default adminFee to be initialized with\r\n     */\r\n    function initialize(\r\n        IERC20[] memory _pooledTokens,\r\n        uint8[] memory decimals,\r\n        string memory lpTokenName,\r\n        string memory lpTokenSymbol,\r\n        uint256 _a,\r\n        uint256 _fee,\r\n        uint256 _adminFee,\r\n        address lpTokenTargetAddress\r\n    ) public payable virtual override initializer {\r\n        revert(\"use initializeMetaSwap() instead\");\r\n    }\r\n\r\n    /**\r\n     * @notice Initializes this MetaSwap contract with the given parameters.\r\n     * MetaSwap uses an existing Swap pool to expand the available liquidity.\r\n     * _pooledTokens array should contain the base Swap pool's LP token as\r\n     * the last element. For example, if there is a Swap pool consisting of\r\n     * [DAI, USDC, USDT]. Then a MetaSwap pool can be created with [sUSD, BaseSwapLPToken]\r\n     * as _pooledTokens.\r\n     *\r\n     * This will also deploy the LPToken that represents users'\r\n     * LP position. The owner of LPToken will be this contract - which means\r\n     * only this contract is allowed to mint new tokens.\r\n     *\r\n     * @param _pooledTokens an array of ERC20s this pool will accept. The last\r\n     * element must be an existing Swap pool's LP token's address.\r\n     * @param decimals the decimals to use for each pooled token,\r\n     * eg 8 for WBTC. Cannot be larger than POOL_PRECISION_DECIMALS\r\n     * @param lpTokenName the long-form name of the token to be deployed\r\n     * @param lpTokenSymbol the short symbol for the token to be deployed\r\n     * @param _a the amplification coefficient * n * (n - 1). See the\r\n     * StableSwap paper for details\r\n     * @param _fee default swap fee to be initialized with\r\n     * @param _adminFee default adminFee to be initialized with\r\n     */\r\n    function initializeMetaSwap(\r\n        IERC20[] memory _pooledTokens,\r\n        uint8[] memory decimals,\r\n        string memory lpTokenName,\r\n        string memory lpTokenSymbol,\r\n        uint256 _a,\r\n        uint256 _fee,\r\n        uint256 _adminFee,\r\n        address lpTokenTargetAddress,\r\n        ISwap baseSwap\r\n    ) public payable virtual initializer {\r\n        Swap.initialize(\r\n            _pooledTokens,\r\n            decimals,\r\n            lpTokenName,\r\n            lpTokenSymbol,\r\n            _a,\r\n            _fee,\r\n            _adminFee,\r\n            lpTokenTargetAddress\r\n        );\r\n\r\n        // MetaSwap initializer\r\n        metaSwapStorage.baseSwap = baseSwap;\r\n        metaSwapStorage.baseVirtualPrice = baseSwap.getVirtualPrice();\r\n        metaSwapStorage.baseCacheLastUpdated = block.timestamp;\r\n\r\n        // Read all tokens that belong to baseSwap\r\n        {\r\n            uint8 i;\r\n            for (; i < 32; i++) {\r\n                try baseSwap.getToken(i) returns (IERC20 token) {\r\n                    metaSwapStorage.baseTokens.push(token);\r\n                    token.safeApprove(address(baseSwap), MAX_UINT256);\r\n                } catch {\r\n                    break;\r\n                }\r\n            }\r\n            require(i > 1, \"baseSwap must pool at least 2 tokens\");\r\n        }\r\n\r\n        // Check the last element of _pooledTokens is owned by baseSwap\r\n        IERC20 baseLPToken = _pooledTokens[_pooledTokens.length - 1];\r\n        require(\r\n            LPToken(address(baseLPToken)).owner() == address(baseSwap),\r\n            \"baseLPToken is not owned by baseSwap\"\r\n        );\r\n\r\n        // Pre-approve the baseLPToken to be used by baseSwap\r\n        baseLPToken.safeApprove(address(baseSwap), MAX_UINT256);\r\n    }\r\n\r\n    /**\r\n     * @notice Swap two tokens using this pool\r\n     * @param tokenIndexFrom the token the user wants to swap from\r\n     * @param tokenIndexTo the token the user wants to swap to\r\n     * @param dx the amount of tokens the user wants to swap from\r\n     * @param minDy the min amount the user would like to receive, or revert.\r\n     * @param deadline latest timestamp to accept this transaction\r\n     */\r\n    function swap(\r\n        uint8 tokenIndexFrom,\r\n        uint8 tokenIndexTo,\r\n        uint256 dx,\r\n        uint256 minDy,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        payable\r\n        virtual\r\n        override\r\n        nonReentrant\r\n        whenNotPaused\r\n        deadlineCheck(deadline)\r\n        returns (uint256)\r\n    {\r\n        return\r\n            MetaSwapUtils.swap(\r\n                swapStorage,\r\n                metaSwapStorage,\r\n                tokenIndexFrom,\r\n                tokenIndexTo,\r\n                dx,\r\n                minDy\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @notice Swap two tokens using this pool and the base pool.\r\n     * @param tokenIndexFrom the token the user wants to swap from\r\n     * @param tokenIndexTo the token the user wants to swap to\r\n     * @param dx the amount of tokens the user wants to swap from\r\n     * @param minDy the min amount the user would like to receive, or revert.\r\n     * @param deadline latest timestamp to accept this transaction\r\n     */\r\n    function swapUnderlying(\r\n        uint8 tokenIndexFrom,\r\n        uint8 tokenIndexTo,\r\n        uint256 dx,\r\n        uint256 minDy,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        virtual\r\n        nonReentrant\r\n        whenNotPaused\r\n        deadlineCheck(deadline)\r\n        returns (uint256)\r\n    {\r\n        return\r\n            MetaSwapUtils.swapUnderlying(\r\n                swapStorage,\r\n                metaSwapStorage,\r\n                tokenIndexFrom,\r\n                tokenIndexTo,\r\n                dx,\r\n                minDy\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @notice Add liquidity to the pool with the given amounts of tokens\r\n     * @param amounts the amounts of each token to add, in their native precision\r\n     * @param minToMint the minimum LP tokens adding this amount of liquidity\r\n     * should mint, otherwise revert. Handy for front-running mitigation\r\n     * @param deadline latest timestamp to accept this transaction\r\n     * @return amount of LP token user minted and received\r\n     */\r\n    function addLiquidity(\r\n        uint256[] calldata amounts,\r\n        uint256 minToMint,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        payable\r\n        virtual\r\n        override\r\n        nonReentrant\r\n        whenNotPaused\r\n        deadlineCheck(deadline)\r\n        returns (uint256)\r\n    {\r\n        return\r\n            MetaSwapUtils.addLiquidity(\r\n                swapStorage,\r\n                metaSwapStorage,\r\n                amounts,\r\n                minToMint\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @notice Remove liquidity from the pool all in one token. Withdraw fee that decays linearly\r\n     * over period of 4 weeks since last deposit will apply.\r\n     * @param tokenAmount the amount of the token you want to receive\r\n     * @param tokenIndex the index of the token you want to receive\r\n     * @param minAmount the minimum amount to withdraw, otherwise revert\r\n     * @param deadline latest timestamp to accept this transaction\r\n     * @return amount of chosen token user received\r\n     */\r\n    function removeLiquidityOneToken(\r\n        uint256 tokenAmount,\r\n        uint8 tokenIndex,\r\n        uint256 minAmount,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        payable\r\n        virtual\r\n        override\r\n        nonReentrant\r\n        whenNotPaused\r\n        deadlineCheck(deadline)\r\n        returns (uint256)\r\n    {\r\n        return\r\n            MetaSwapUtils.removeLiquidityOneToken(\r\n                swapStorage,\r\n                metaSwapStorage,\r\n                tokenAmount,\r\n                tokenIndex,\r\n                minAmount\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @notice Remove liquidity from the pool, weighted differently than the\r\n     * pool's current balances. Withdraw fee that decays linearly\r\n     * over period of 4 weeks since last deposit will apply.\r\n     * @param amounts how much of each token to withdraw\r\n     * @param maxBurnAmount the max LP token provider is willing to pay to\r\n     * remove liquidity. Useful as a front-running mitigation.\r\n     * @param deadline latest timestamp to accept this transaction\r\n     * @return amount of LP tokens burned\r\n     */\r\n    function removeLiquidityImbalance(\r\n        uint256[] calldata amounts,\r\n        uint256 maxBurnAmount,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        payable\r\n        virtual\r\n        override\r\n        nonReentrant\r\n        whenNotPaused\r\n        deadlineCheck(deadline)\r\n        returns (uint256)\r\n    {\r\n        return\r\n            MetaSwapUtils.removeLiquidityImbalance(\r\n                swapStorage,\r\n                metaSwapStorage,\r\n                amounts,\r\n                maxBurnAmount\r\n            );\r\n    }\r\n}\r\n"
    },
    "contracts/interfaces/IMasterRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\npragma experimental ABIEncoderV2;\r\n\r\ninterface IMasterRegistry {\r\n    /* Structs */\r\n\r\n    struct ReverseRegistryData {\r\n        bytes32 name;\r\n        uint256 version;\r\n    }\r\n\r\n    /* Functions */\r\n\r\n    /**\r\n     * @notice Add a new registry entry to the master list.\r\n     * @param registryName name for the registry\r\n     * @param registryAddress address of the new registry\r\n     */\r\n    function addRegistry(bytes32 registryName, address registryAddress)\r\n        external\r\n        payable;\r\n\r\n    /**\r\n     * @notice Resolves a name to the latest registry address. Reverts if no match is found.\r\n     * @param name name for the registry\r\n     * @return address address of the latest registry with the matching name\r\n     */\r\n    function resolveNameToLatestAddress(bytes32 name)\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    /**\r\n     * @notice Resolves a name and version to an address. Reverts if there is no registry with given name and version.\r\n     * @param name address of the registry you want to resolve to\r\n     * @param version version of the registry you want to resolve to\r\n     */\r\n    function resolveNameAndVersionToAddress(bytes32 name, uint256 version)\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    /**\r\n     * @notice Resolves a name to an array of all addresses. Reverts if no match is found.\r\n     * @param name name for the registry\r\n     * @return address address of the latest registry with the matching name\r\n     */\r\n    function resolveNameToAllAddresses(bytes32 name)\r\n        external\r\n        view\r\n        returns (address[] memory);\r\n\r\n    /**\r\n     * @notice Resolves an address to registry entry data.\r\n     * @param registryAddress address of a registry you want to resolve\r\n     * @return name name of the resolved registry\r\n     * @return version version of the resolved registry\r\n     * @return isLatest boolean flag of whether the given address is the latest version of the given registries with\r\n     * matching name\r\n     */\r\n    function resolveAddressToRegistryData(address registryAddress)\r\n        external\r\n        view\r\n        returns (\r\n            bytes32 name,\r\n            uint256 version,\r\n            bool isLatest\r\n        );\r\n}\r\n"
    },
    "contracts/permissionless/PermissionlessSwapUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\r\nimport \"../SwapUtils.sol\";\r\n\r\n/**\r\n * @title PermissionlessSwapUtils library\r\n * @notice A library to be used within Swap.sol. Contains functions responsible for custody and AMM functionalities.\r\n * @dev Contracts relying on this library must initialize SwapUtils.Swap struct then use this library\r\n * for SwapUtils.Swap struct. Note that this library contains both functions called by users and admins.\r\n * Admin functions should be protected within contracts using this library.\r\n */\r\nlibrary PermissionlessSwapUtils {\r\n    using SafeERC20 for IERC20;\r\n    using SafeMath for uint256;\r\n\r\n    /**\r\n     * @notice Withdraw all admin fees to two addresses evenly\r\n     * @param self Swap struct to withdraw fees from\r\n     * @param creator Address to send hald of the fees to. For the creator of the community pool.\r\n     * @param protocol Address to send the half of the fees to. For the protocol fee collection.\r\n     */\r\n    function withdrawAdminFees(\r\n        SwapUtils.Swap storage self,\r\n        address creator,\r\n        address protocol\r\n    ) internal {\r\n        IERC20[] memory pooledTokens = self.pooledTokens;\r\n        for (uint256 i = 0; i < pooledTokens.length; i++) {\r\n            IERC20 token = pooledTokens[i];\r\n            uint256 balance = token.balanceOf(address(this)).sub(\r\n                self.balances[i]\r\n            ) / 2;\r\n            if (balance != 0) {\r\n                token.safeTransfer(creator, balance);\r\n                token.safeTransfer(protocol, balance);\r\n            }\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/permissionless/PermissionlessMetaSwapFlashLoan.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"./PermissionlessMetaSwap.sol\";\r\nimport \"./FlashLoanEnabled.sol\";\r\nimport \"../interfaces/IFlashLoanReceiver.sol\";\r\n\r\n/**\r\n * @title MetaSwap - A StableSwap implementation in solidity.\r\n * @notice This contract is responsible for custody of closely pegged assets (eg. group of stablecoins)\r\n * and automatic market making system. Users become an LP (Liquidity Provider) by depositing their tokens\r\n * in desired ratios for an exchange of the pool token that represents their share of the pool.\r\n * Users can burn pool tokens and withdraw their share of token(s).\r\n *\r\n * Each time a swap between the pooled tokens happens, a set fee incurs which effectively gets\r\n * distributed to the LPs.\r\n *\r\n * In case of emergencies, admin can pause additional deposits, swaps, or single-asset withdraws - which\r\n * stops the ratio of the tokens in the pool from changing.\r\n * Users can always withdraw their tokens via multi-asset withdraws.\r\n *\r\n * MetaSwap is a modified version of Swap that allows Swap's LP token to be utilized in pooling with other tokens.\r\n * As an example, if there is a Swap pool consisting of [DAI, USDC, USDT], then a MetaSwap pool can be created\r\n * with [sUSD, BaseSwapLPToken] to allow trades between either the LP token or the underlying tokens and sUSD.\r\n * Note that when interacting with MetaSwap, users cannot deposit or withdraw via underlying tokens. In that case,\r\n * `MetaSwapDeposit.sol` can be additionally deployed to allow interacting with unwrapped representations of the tokens.\r\n *\r\n * @dev Most of the logic is stored as a library `MetaSwapUtils` for the sake of reducing contract's\r\n * deployment size.\r\n */\r\ncontract PermissionlessMetaSwapFlashLoan is\r\n    PermissionlessMetaSwap,\r\n    FlashLoanEnabled\r\n{\r\n    /**\r\n     * @notice Constructor for the PermissionlessSwapFlashLoan contract.\r\n     * @param _masterRegistry address of the MasterRegistry contract\r\n     */\r\n    constructor(IMasterRegistry _masterRegistry)\r\n        public\r\n        PermissionlessMetaSwap(_masterRegistry)\r\n    {}\r\n\r\n    /**\r\n     * @inheritdoc MetaSwap\r\n     * @dev Additionally sets flashloan fees.\r\n     */\r\n    function initializeMetaSwap(\r\n        IERC20[] memory _pooledTokens,\r\n        uint8[] memory decimals,\r\n        string memory lpTokenName,\r\n        string memory lpTokenSymbol,\r\n        uint256 _a,\r\n        uint256 _fee,\r\n        uint256 _adminFee,\r\n        address lpTokenTargetAddress,\r\n        ISwap baseSwap\r\n    ) public payable virtual override initializer {\r\n        MetaSwap.initializeMetaSwap(\r\n            _pooledTokens,\r\n            decimals,\r\n            lpTokenName,\r\n            lpTokenSymbol,\r\n            _a,\r\n            _fee,\r\n            _adminFee,\r\n            lpTokenTargetAddress,\r\n            baseSwap\r\n        );\r\n        // Set flashLoanFeeBPS to 8 and protocolFeeShareBPS to 0\r\n        _setFlashLoanFees(8, 0);\r\n        _updateFeeCollectorCache(MASTER_REGISTRY);\r\n    }\r\n\r\n    /*** STATE MODIFYING FUNCTIONS ***/\r\n\r\n    /// @inheritdoc FlashLoanEnabled\r\n    function flashLoan(\r\n        address receiver,\r\n        IERC20 token,\r\n        uint256 amount,\r\n        bytes memory params\r\n    ) external payable virtual override nonReentrant {\r\n        uint8 tokenIndex = getTokenIndex(address(token));\r\n        uint256 availableLiquidityBefore = token.balanceOf(address(this));\r\n        uint256 protocolBalanceBefore = availableLiquidityBefore.sub(\r\n            swapStorage.balances[tokenIndex]\r\n        );\r\n        require(\r\n            amount > 0 && availableLiquidityBefore >= amount,\r\n            \"invalid amount\"\r\n        );\r\n\r\n        // Calculate the additional amount of tokens the pool should end up with\r\n        uint256 amountFee = amount.mul(flashLoanFeeBPS).div(10000);\r\n        // Calculate the portion of the fee that will go to the protocol\r\n        uint256 protocolFee = amountFee.mul(protocolFeeShareBPS).div(10000);\r\n        require(amountFee > 0, \"amount is small for a flashLoan\");\r\n\r\n        // Transfer the requested amount of tokens\r\n        token.safeTransfer(receiver, amount);\r\n\r\n        // Execute callback function on receiver\r\n        IFlashLoanReceiver(receiver).executeOperation(\r\n            address(this),\r\n            address(token),\r\n            amount,\r\n            amountFee,\r\n            params\r\n        );\r\n\r\n        uint256 availableLiquidityAfter = token.balanceOf(address(this));\r\n        require(\r\n            availableLiquidityAfter >= availableLiquidityBefore.add(amountFee),\r\n            \"flashLoan fee is not met\"\r\n        );\r\n\r\n        swapStorage.balances[tokenIndex] = availableLiquidityAfter\r\n            .sub(protocolBalanceBefore)\r\n            .sub(protocolFee);\r\n        emit FlashLoan(receiver, tokenIndex, amount, amountFee, protocolFee);\r\n    }\r\n\r\n    /*** ADMIN FUNCTIONS ***/\r\n\r\n    /**\r\n     * @notice Updates the flash loan fee parameters. Only owner can call this function.\r\n     * @dev This function should be overridden for permissions.\r\n     * @param newFlashLoanFeeBPS the total fee in bps to be applied on future flash loans\r\n     * @param newProtocolFeeShareBPS the protocol fee in bps to be applied on the total flash loan fee\r\n     */\r\n    function setFlashLoanFees(\r\n        uint256 newFlashLoanFeeBPS,\r\n        uint256 newProtocolFeeShareBPS\r\n    ) external payable virtual onlyOwner {\r\n        _setFlashLoanFees(newFlashLoanFeeBPS, newProtocolFeeShareBPS);\r\n    }\r\n}\r\n"
    },
    "contracts/permissionless/FlashLoanEnabled.sol": {
      "content": "// SPDX-License-Identifier: MIT WITH AGPL-3.0-only\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"./PermissionlessSwap.sol\";\r\nimport \"../interfaces/IFlashLoanReceiver.sol\";\r\n\r\nabstract contract FlashLoanEnabled {\r\n    // Total fee that is charged on all flashloans in BPS. Borrowers must repay the amount plus the flash loan fee.\r\n    // This fee is split between the protocol and the pool.\r\n    uint256 public flashLoanFeeBPS;\r\n    // Share of the flash loan fee that goes to the protocol in BPS. A portion of each flash loan fee is allocated\r\n    // to the protocol rather than the pool.\r\n    uint256 public protocolFeeShareBPS;\r\n    // Max BPS for limiting flash loan fee settings.\r\n    uint256 public constant MAX_BPS = 10000;\r\n\r\n    /*** EVENTS ***/\r\n    event FlashLoan(\r\n        address indexed receiver,\r\n        uint8 tokenIndex,\r\n        uint256 amount,\r\n        uint256 amountFee,\r\n        uint256 protocolFee\r\n    );\r\n\r\n    /**\r\n     * @notice Borrow the specified token from this pool for this transaction only. This function will call\r\n     * `IFlashLoanReceiver(receiver).executeOperation` and the `receiver` must return the full amount of the token\r\n     * and the associated fee by the end of the callback transaction. If the conditions are not met, this call\r\n     * is reverted.\r\n     * @param receiver the address of the receiver of the token. This address must implement the IFlashLoanReceiver\r\n     * interface and the callback function `executeOperation`.\r\n     * @param token the protocol fee in bps to be applied on the total flash loan fee\r\n     * @param amount the total amount to borrow in this transaction\r\n     * @param params optional data to pass along to the callback function\r\n     */\r\n    function flashLoan(\r\n        address receiver,\r\n        IERC20 token,\r\n        uint256 amount,\r\n        bytes memory params\r\n    ) external payable virtual;\r\n\r\n    /**\r\n     * @notice Updates the flash loan fee parameters.\r\n     * @dev This function should be overridden for permissions.\r\n     * @param newFlashLoanFeeBPS the total fee in bps to be applied on future flash loans\r\n     * @param newProtocolFeeShareBPS the protocol fee in bps to be applied on the total flash loan fee\r\n     */\r\n    function _setFlashLoanFees(\r\n        uint256 newFlashLoanFeeBPS,\r\n        uint256 newProtocolFeeShareBPS\r\n    ) internal {\r\n        require(\r\n            newFlashLoanFeeBPS > 0 &&\r\n                newFlashLoanFeeBPS <= MAX_BPS &&\r\n                newProtocolFeeShareBPS <= MAX_BPS,\r\n            \"fees are not in valid range\"\r\n        );\r\n        flashLoanFeeBPS = newFlashLoanFeeBPS;\r\n        protocolFeeShareBPS = newProtocolFeeShareBPS;\r\n    }\r\n}\r\n"
    },
    "contracts/permissionless/PermissionlessSwapFlashLoan.sol": {
      "content": "// SPDX-License-Identifier: MIT WITH AGPL-3.0-only\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"./PermissionlessSwap.sol\";\r\nimport \"./FlashLoanEnabled.sol\";\r\nimport \"../interfaces/IFlashLoanReceiver.sol\";\r\n\r\n/**\r\n * @title Swap - A StableSwap implementation in solidity.\r\n * @notice This contract is responsible for custody of closely pegged assets (eg. group of stablecoins)\r\n * and automatic market making system. Users become an LP (Liquidity Provider) by depositing their tokens\r\n * in desired ratios for an exchange of the pool token that represents their share of the pool.\r\n * Users can burn pool tokens and withdraw their share of token(s).\r\n *\r\n * Each time a swap between the pooled tokens happens, a set fee incurs which effectively gets\r\n * distributed to the LPs.\r\n *\r\n * In case of emergencies, admin can pause additional deposits, swaps, or single-asset withdraws - which\r\n * stops the ratio of the tokens in the pool from changing.\r\n * Users can always withdraw their tokens via multi-asset withdraws.\r\n *\r\n * @dev Most of the logic is stored as a library `SwapUtils` for the sake of reducing contract's\r\n * deployment size.\r\n */\r\ncontract PermissionlessSwapFlashLoan is PermissionlessSwap, FlashLoanEnabled {\r\n    /**\r\n     * @notice Constructor for the PermissionlessSwapFlashLoan contract.\r\n     * @param _masterRegistry address of the MasterRegistry contract\r\n     */\r\n    constructor(IMasterRegistry _masterRegistry)\r\n        public\r\n        PermissionlessSwap(_masterRegistry)\r\n    {}\r\n\r\n    /**\r\n     * @notice Initializes this Swap contract with the given parameters.\r\n     * This will also clone a LPToken contract that represents users'\r\n     * LP positions. The owner of LPToken will be this contract - which means\r\n     * only this contract is allowed to mint/burn tokens.\r\n     *\r\n     * @param _pooledTokens an array of ERC20s this pool will accept\r\n     * @param decimals the decimals to use for each pooled token,\r\n     * eg 8 for WBTC. Cannot be larger than POOL_PRECISION_DECIMALS\r\n     * @param lpTokenName the long-form name of the token to be deployed\r\n     * @param lpTokenSymbol the short symbol for the token to be deployed\r\n     * @param _a the amplification coefficient * n * (n - 1). See the\r\n     * StableSwap paper for details\r\n     * @param _fee default swap fee to be initialized with\r\n     * @param _adminFee default adminFee to be initialized with\r\n     * @param lpTokenTargetAddress the address of an existing LPToken contract to use as a target\r\n     */\r\n    function initialize(\r\n        IERC20[] memory _pooledTokens,\r\n        uint8[] memory decimals,\r\n        string memory lpTokenName,\r\n        string memory lpTokenSymbol,\r\n        uint256 _a,\r\n        uint256 _fee,\r\n        uint256 _adminFee,\r\n        address lpTokenTargetAddress\r\n    ) public payable virtual override initializer {\r\n        Swap.initialize(\r\n            _pooledTokens,\r\n            decimals,\r\n            lpTokenName,\r\n            lpTokenSymbol,\r\n            _a,\r\n            _fee,\r\n            _adminFee,\r\n            lpTokenTargetAddress\r\n        );\r\n        // Set flashLoanFeeBPS to 8 and protocolFeeShareBPS to 0\r\n        _setFlashLoanFees(8, 0);\r\n        _updateFeeCollectorCache(MASTER_REGISTRY);\r\n    }\r\n\r\n    /*** STATE MODIFYING FUNCTIONS ***/\r\n\r\n    /// @inheritdoc FlashLoanEnabled\r\n    function flashLoan(\r\n        address receiver,\r\n        IERC20 token,\r\n        uint256 amount,\r\n        bytes memory params\r\n    ) external payable override nonReentrant {\r\n        uint8 tokenIndex = getTokenIndex(address(token));\r\n        uint256 availableLiquidityBefore = token.balanceOf(address(this));\r\n        uint256 protocolBalanceBefore = availableLiquidityBefore.sub(\r\n            swapStorage.balances[tokenIndex]\r\n        );\r\n        require(\r\n            amount > 0 && availableLiquidityBefore >= amount,\r\n            \"invalid amount\"\r\n        );\r\n\r\n        // Calculate the additional amount of tokens the pool should end up with\r\n        uint256 amountFee = amount.mul(flashLoanFeeBPS).div(10000);\r\n        // Calculate the portion of the fee that will go to the protocol\r\n        uint256 protocolFee = amountFee.mul(protocolFeeShareBPS).div(10000);\r\n        require(amountFee > 0, \"amount is small for a flashLoan\");\r\n\r\n        // Transfer the requested amount of tokens\r\n        token.safeTransfer(receiver, amount);\r\n\r\n        // Execute callback function on receiver\r\n        IFlashLoanReceiver(receiver).executeOperation(\r\n            address(this),\r\n            address(token),\r\n            amount,\r\n            amountFee,\r\n            params\r\n        );\r\n\r\n        uint256 availableLiquidityAfter = token.balanceOf(address(this));\r\n        require(\r\n            availableLiquidityAfter >= availableLiquidityBefore.add(amountFee),\r\n            \"flashLoan fee is not met\"\r\n        );\r\n\r\n        swapStorage.balances[tokenIndex] = availableLiquidityAfter\r\n            .sub(protocolBalanceBefore)\r\n            .sub(protocolFee);\r\n        emit FlashLoan(receiver, tokenIndex, amount, amountFee, protocolFee);\r\n    }\r\n\r\n    /*** ADMIN FUNCTIONS ***/\r\n\r\n    /**\r\n     * @notice Updates the flash loan fee parameters. Only owner can call this function.\r\n     * @dev This function should be overridden for permissions.\r\n     * @param newFlashLoanFeeBPS the total fee in bps to be applied on future flash loans\r\n     * @param newProtocolFeeShareBPS the protocol fee in bps to be applied on the total flash loan fee\r\n     */\r\n    function setFlashLoanFees(\r\n        uint256 newFlashLoanFeeBPS,\r\n        uint256 newProtocolFeeShareBPS\r\n    ) external payable virtual onlyOwner {\r\n        _setFlashLoanFees(newFlashLoanFeeBPS, newProtocolFeeShareBPS);\r\n    }\r\n}\r\n"
    },
    "contracts/registries/MasterRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\r\nimport \"../helper/BaseBoringBatchable.sol\";\r\nimport \"../interfaces/IMasterRegistry.sol\";\r\n\r\n/**\r\n * @title MasterRegistry\r\n * @notice This contract holds list of other registries or contracts and its historical versions.\r\n */\r\ncontract MasterRegistry is AccessControl, IMasterRegistry, BaseBoringBatchable {\r\n    /// @notice Role responsible for adding registries.\r\n    bytes32 public constant kinesis_MANAGER_ROLE =\r\n        keccak256(\"kinesis_MANAGER_ROLE\");\r\n\r\n    mapping(bytes32 => address[]) private registryMap;\r\n    mapping(address => ReverseRegistryData) private reverseRegistry;\r\n\r\n    /**\r\n     * @notice Add a new registry entry to the master list.\r\n     * @param name address of the added pool\r\n     * @param registryAddress address of the registry\r\n     * @param version version of the registry\r\n     */\r\n    event AddRegistry(\r\n        bytes32 indexed name,\r\n        address registryAddress,\r\n        uint256 version\r\n    );\r\n\r\n    constructor(address admin) public {\r\n        _setupRole(DEFAULT_ADMIN_ROLE, admin);\r\n        _setupRole(kinesis_MANAGER_ROLE, msg.sender);\r\n    }\r\n\r\n    /// @inheritdoc IMasterRegistry\r\n    function addRegistry(bytes32 registryName, address registryAddress)\r\n        external\r\n        payable\r\n        override\r\n    {\r\n        require(\r\n            hasRole(kinesis_MANAGER_ROLE, msg.sender),\r\n            \"MR: msg.sender is not allowed\"\r\n        );\r\n        require(registryName != 0, \"MR: name cannot be empty\");\r\n        require(registryAddress != address(0), \"MR: address cannot be empty\");\r\n\r\n        address[] storage registry = registryMap[registryName];\r\n        uint256 version = registry.length;\r\n        registry.push(registryAddress);\r\n        require(\r\n            reverseRegistry[registryAddress].name == 0,\r\n            \"MR: duplicate registry address\"\r\n        );\r\n        reverseRegistry[registryAddress] = ReverseRegistryData(\r\n            registryName,\r\n            version\r\n        );\r\n\r\n        emit AddRegistry(registryName, registryAddress, version);\r\n    }\r\n\r\n    /// @inheritdoc IMasterRegistry\r\n    function resolveNameToLatestAddress(bytes32 name)\r\n        external\r\n        view\r\n        override\r\n        returns (address)\r\n    {\r\n        address[] storage registry = registryMap[name];\r\n        uint256 length = registry.length;\r\n        require(length > 0, \"MR: no match found for name\");\r\n        return registry[length - 1];\r\n    }\r\n\r\n    /// @inheritdoc IMasterRegistry\r\n    function resolveNameAndVersionToAddress(bytes32 name, uint256 version)\r\n        external\r\n        view\r\n        override\r\n        returns (address)\r\n    {\r\n        address[] storage registry = registryMap[name];\r\n        require(\r\n            version < registry.length,\r\n            \"MR: no match found for name and version\"\r\n        );\r\n        return registry[version];\r\n    }\r\n\r\n    /// @inheritdoc IMasterRegistry\r\n    function resolveNameToAllAddresses(bytes32 name)\r\n        external\r\n        view\r\n        override\r\n        returns (address[] memory)\r\n    {\r\n        address[] storage registry = registryMap[name];\r\n        require(registry.length > 0, \"MR: no match found for name\");\r\n        return registry;\r\n    }\r\n\r\n    /// @inheritdoc IMasterRegistry\r\n    function resolveAddressToRegistryData(address registryAddress)\r\n        external\r\n        view\r\n        override\r\n        returns (\r\n            bytes32 name,\r\n            uint256 version,\r\n            bool isLatest\r\n        )\r\n    {\r\n        ReverseRegistryData memory data = reverseRegistry[registryAddress];\r\n        require(data.name != 0, \"MR: no match found for address\");\r\n        name = data.name;\r\n        version = data.version;\r\n        uint256 length = registryMap[name].length;\r\n        require(length > 0, \"MR: no version found for address\");\r\n        isLatest = version == length - 1;\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/EnumerableSet.sol\";\nimport \"../utils/Address.sol\";\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using Address for address;\n\n    struct RoleData {\n        EnumerableSet.AddressSet members;\n        bytes32 adminRole;\n    }\n\n    mapping (bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view returns (bool) {\n        return _roles[role].members.contains(account);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view returns (uint256) {\n        return _roles[role].members.length();\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {\n        return _roles[role].members.at(index);\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual {\n        require(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin to grant\");\n\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual {\n        require(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin to revoke\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);\n        _roles[role].adminRole = adminRole;\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (_roles[role].members.add(account)) {\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (_roles[role].members.remove(account)) {\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "contracts/helper/BaseBoringBatchable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\n// solhint-disable avoid-low-level-calls\r\n// solhint-disable no-inline-assembly\r\n\r\n// Audit on 5-Jan-2021 by Keno and BoringCrypto\r\n// WARNING!!!\r\n// Combining BoringBatchable with msg.value can cause double spending issues\r\n// https://www.paradigm.xyz/2021/08/two-rights-might-make-a-wrong/\r\n\r\ncontract BaseBoringBatchable {\r\n    /// @dev Helper function to extract a useful revert message from a failed call.\r\n    /// If the returned data is malformed or not correctly abi encoded then this call can fail itself.\r\n    function _getRevertMsg(bytes memory _returnData)\r\n        internal\r\n        pure\r\n        returns (string memory)\r\n    {\r\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\r\n        if (_returnData.length < 68) return \"Transaction reverted silently\";\r\n\r\n        assembly {\r\n            // Slice the sighash.\r\n            _returnData := add(_returnData, 0x04)\r\n        }\r\n        return abi.decode(_returnData, (string)); // All that remains is the revert string\r\n    }\r\n\r\n    /// @notice Allows batched call to self (this contract).\r\n    /// @param calls An array of inputs for each call.\r\n    /// @param revertOnFail If True then reverts after a failed call and stops doing further calls.\r\n    // F1: External is ok here because this is the batch function, adding it to a batch makes no sense\r\n    // F2: Calls in the batch may be payable, delegatecall operates in the same context, so each call in the batch has access to msg.value\r\n    // C3: The length of the loop is fully under user control, so can't be exploited\r\n    // C7: Delegatecall is only used on the same contract, so it's safe\r\n    function batch(bytes[] calldata calls, bool revertOnFail) external payable {\r\n        for (uint256 i = 0; i < calls.length; i++) {\r\n            (bool success, bytes memory result) = address(this).delegatecall(\r\n                calls[i]\r\n            );\r\n            if (!success && revertOnFail) {\r\n                revert(_getRevertMsg(result));\r\n            }\r\n        }\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/utils/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n"
    },
    "contracts/registries/PoolRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\r\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\r\nimport \"../helper/BaseBoringBatchable.sol\";\r\nimport \"../interfaces/ISwap.sol\";\r\nimport \"../interfaces/ISwapGuarded.sol\";\r\nimport \"../interfaces/IMetaSwap.sol\";\r\nimport \"../interfaces/IPoolRegistry.sol\";\r\nimport \"../meta/MetaSwapDeposit.sol\";\r\n\r\n/**\r\n * @title PoolRegistry\r\n * @notice This contract holds list of pools deployed.\r\n */\r\ncontract PoolRegistry is\r\n    AccessControl,\r\n    ReentrancyGuard,\r\n    BaseBoringBatchable,\r\n    IPoolRegistry\r\n{\r\n    using SafeMath for uint256;\r\n\r\n    /// @notice Role responsible for managing pools.\r\n    bytes32 public constant kinesis_MANAGER_ROLE =\r\n        keccak256(\"kinesis_MANAGER_ROLE\");\r\n    /// @notice Role responsible for managing community pools\r\n    bytes32 public constant COMMUNITY_MANAGER_ROLE =\r\n        keccak256(\"COMMUNITY_MANAGER_ROLE\");\r\n    /// @notice Role that represents approved owners of pools.\r\n    /// owner of each pool must have this role if the pool is to be approved.\r\n    bytes32 public constant kinesis_APPROVED_POOL_OWNER_ROLE =\r\n        keccak256(\"kinesis_APPROVED_POOL_OWNER_ROLE\");\r\n\r\n    /// @inheritdoc IPoolRegistry\r\n    mapping(address => uint256) public override poolsIndexOfPlusOne;\r\n    /// @inheritdoc IPoolRegistry\r\n    mapping(bytes32 => uint256) public override poolsIndexOfNamePlusOne;\r\n\r\n    PoolData[] private pools;\r\n    mapping(uint256 => address[]) private eligiblePairsMap;\r\n\r\n    /**\r\n     * @notice Add a new registry entry to the master list.\r\n     * @param poolAddress address of the added pool\r\n     * @param index index of the added pool in the pools list\r\n     * @param poolData added pool data\r\n     */\r\n    event AddPool(\r\n        address indexed poolAddress,\r\n        uint256 index,\r\n        PoolData poolData\r\n    );\r\n\r\n    /**\r\n     * @notice Add a new registry entry to the master list.\r\n     * @param poolAddress address of the added pool\r\n     * @param index index of the added pool in the pools list\r\n     * @param poolData added pool data\r\n     */\r\n    event AddCommunityPool(\r\n        address indexed poolAddress,\r\n        uint256 index,\r\n        PoolData poolData\r\n    );\r\n\r\n    /**\r\n     * @notice Add a new registry entry to the master list.\r\n     * @param poolAddress address of the updated pool\r\n     * @param index index of the updated pool in the pools list\r\n     * @param poolData updated pool data\r\n     */\r\n    event UpdatePool(\r\n        address indexed poolAddress,\r\n        uint256 index,\r\n        PoolData poolData\r\n    );\r\n\r\n    /**\r\n     * @notice Add a new registry entry to the master list.\r\n     * @param poolAddress address of the removed pool\r\n     * @param index index of the removed pool in the pools list\r\n     */\r\n    event RemovePool(address indexed poolAddress, uint256 index);\r\n\r\n    /**\r\n     * @notice Deploy this contract and set appropriate roles\r\n     * @param admin address who should have the DEFAULT_ADMIN_ROLE\r\n     * @dev caller of this function will be set as the owner on deployment\r\n     */\r\n    constructor(address admin, address poolOwner) public payable {\r\n        require(admin != address(0), \"admin == 0\");\r\n        _setupRole(DEFAULT_ADMIN_ROLE, admin);\r\n        _setupRole(kinesis_MANAGER_ROLE, msg.sender);\r\n        _setupRole(kinesis_APPROVED_POOL_OWNER_ROLE, poolOwner);\r\n    }\r\n\r\n    /// @inheritdoc IPoolRegistry\r\n    function addCommunityPool(PoolData memory data) external payable override {\r\n        require(\r\n            hasRole(COMMUNITY_MANAGER_ROLE, msg.sender),\r\n            \"PR: Only managers can add pools\"\r\n        );\r\n\r\n        // Check token addresses\r\n        for (uint8 i = 0; i < data.tokens.length; i++) {\r\n            for (uint8 j = 0; j < i; j++) {\r\n                eligiblePairsMap[\r\n                    uint160(address(data.tokens[i])) ^\r\n                        uint160(address(data.tokens[j]))\r\n                ].push(data.poolAddress);\r\n            }\r\n        }\r\n\r\n        // Check meta swap deposit address\r\n        if (data.metaSwapDepositAddress != address(0)) {\r\n            for (uint8 i = 0; i < data.underlyingTokens.length; i++) {\r\n                // add combinations of tokens to eligible pairs map\r\n                // i reprents the indexes of the underlying tokens of metaLPToken.\r\n                // j represents the indexes of MetaSwap level tokens that are not metaLPToken.\r\n                // Example: tokens = [sUSD, baseLPToken]\r\n                //         underlyingTokens = [sUSD, DAI, USDC, USDT]\r\n                // i represents index of [DAI, USDC, USDT] in underlyingTokens\r\n                // j represents index of [sUSD] in underlyingTokens\r\n                if (i > data.tokens.length.sub(2))\r\n                    for (uint256 j = 0; j < data.tokens.length - 1; j++) {\r\n                        eligiblePairsMap[\r\n                            uint160(address(data.underlyingTokens[i])) ^\r\n                                uint160(address(data.underlyingTokens[j]))\r\n                        ].push(data.metaSwapDepositAddress);\r\n                    }\r\n            }\r\n        }\r\n\r\n        pools.push(data);\r\n        poolsIndexOfPlusOne[data.poolAddress] = pools.length;\r\n        poolsIndexOfNamePlusOne[data.poolName] = pools.length;\r\n\r\n        emit AddCommunityPool(data.poolAddress, pools.length - 1, data);\r\n    }\r\n\r\n    /// @inheritdoc IPoolRegistry\r\n    function addPool(PoolInputData memory inputData)\r\n        external\r\n        payable\r\n        override\r\n        nonReentrant\r\n    {\r\n        require(\r\n            hasRole(kinesis_MANAGER_ROLE, msg.sender),\r\n            \"PR: Only managers can add pools\"\r\n        );\r\n        require(inputData.poolAddress != address(0), \"PR: poolAddress is 0\");\r\n        require(\r\n            poolsIndexOfPlusOne[inputData.poolAddress] == 0,\r\n            \"PR: Pool is already added\"\r\n        );\r\n\r\n        IERC20[] memory tokens = new IERC20[](8);\r\n        IERC20[] memory underlyingTokens = new IERC20[](8);\r\n\r\n        PoolData memory data = PoolData(\r\n            inputData.poolAddress,\r\n            address(0),\r\n            inputData.typeOfAsset,\r\n            inputData.poolName,\r\n            inputData.targetAddress,\r\n            tokens,\r\n            underlyingTokens,\r\n            address(0),\r\n            inputData.metaSwapDepositAddress,\r\n            inputData.iskinesisApproved,\r\n            inputData.isRemoved,\r\n            inputData.isGuarded\r\n        );\r\n\r\n        // Get lp token address\r\n        data.lpToken = inputData.isGuarded\r\n            ? _getSwapStorageGuarded(inputData.poolAddress).lpToken\r\n            : _getSwapStorage(inputData.poolAddress).lpToken;\r\n\r\n        // Check token addresses\r\n        for (uint8 i = 0; i < 8; i++) {\r\n            try ISwap(inputData.poolAddress).getToken(i) returns (\r\n                IERC20 token\r\n            ) {\r\n                require(address(token) != address(0), \"PR: token is 0\");\r\n                tokens[i] = token;\r\n                // add combinations of tokens to eligible pairs map\r\n                for (uint8 j = 0; j < i; j++) {\r\n                    eligiblePairsMap[\r\n                        uint160(address(tokens[i])) ^\r\n                            uint160(address(tokens[j]))\r\n                    ].push(inputData.poolAddress);\r\n                }\r\n            } catch {\r\n                assembly {\r\n                    mstore(tokens, sub(mload(tokens), sub(8, i)))\r\n                }\r\n                break;\r\n            }\r\n        }\r\n\r\n        // Check meta swap deposit address\r\n        if (inputData.metaSwapDepositAddress != address(0)) {\r\n            // Get base pool address\r\n            data.basePoolAddress = address(\r\n                MetaSwapDeposit(inputData.metaSwapDepositAddress).baseSwap()\r\n            );\r\n            require(\r\n                poolsIndexOfPlusOne[data.basePoolAddress] > 0,\r\n                \"PR: base pool not found\"\r\n            );\r\n\r\n            // Get underlying tokens\r\n            for (uint8 i = 0; i < 8; i++) {\r\n                try\r\n                    MetaSwapDeposit(inputData.metaSwapDepositAddress).getToken(\r\n                        i\r\n                    )\r\n                returns (IERC20 token) {\r\n                    require(address(token) != address(0), \"PR: token is 0\");\r\n                    underlyingTokens[i] = token;\r\n                    // add combinations of tokens to eligible pairs map\r\n                    // i reprents the indexes of the underlying tokens of metaLPToken.\r\n                    // j represents the indexes of MetaSwap level tokens that are not metaLPToken.\r\n                    // Example: tokens = [sUSD, baseLPToken]\r\n                    //         underlyingTokens = [sUSD, DAI, USDC, USDT]\r\n                    // i represents index of [DAI, USDC, USDT] in underlyingTokens\r\n                    // j represents index of [sUSD] in underlyingTokens\r\n                    if (i > tokens.length.sub(2))\r\n                        for (uint256 j = 0; j < tokens.length - 1; j++) {\r\n                            eligiblePairsMap[\r\n                                uint160(address(underlyingTokens[i])) ^\r\n                                    uint160(address(underlyingTokens[j]))\r\n                            ].push(inputData.metaSwapDepositAddress);\r\n                        }\r\n                } catch {\r\n                    assembly {\r\n                        mstore(\r\n                            underlyingTokens,\r\n                            sub(mload(underlyingTokens), sub(8, i))\r\n                        )\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n            require(\r\n                address(\r\n                    MetaSwapDeposit(inputData.metaSwapDepositAddress).metaSwap()\r\n                ) == inputData.poolAddress,\r\n                \"PR: metaSwap address mismatch\"\r\n            );\r\n        } else {\r\n            assembly {\r\n                mstore(underlyingTokens, sub(mload(underlyingTokens), 8))\r\n            }\r\n        }\r\n\r\n        pools.push(data);\r\n        poolsIndexOfPlusOne[data.poolAddress] = pools.length;\r\n        poolsIndexOfNamePlusOne[data.poolName] = pools.length;\r\n\r\n        emit AddPool(inputData.poolAddress, pools.length - 1, data);\r\n    }\r\n\r\n    /// @inheritdoc IPoolRegistry\r\n    function approvePool(address poolAddress)\r\n        external\r\n        payable\r\n        override\r\n        managerOnly\r\n    {\r\n        uint256 poolIndex = poolsIndexOfPlusOne[poolAddress];\r\n        require(poolIndex > 0, \"PR: Pool not found\");\r\n\r\n        PoolData storage poolData = pools[poolIndex];\r\n\r\n        require(\r\n            poolData.poolAddress == poolAddress,\r\n            \"PR: poolAddress mismatch\"\r\n        );\r\n\r\n        // Effect\r\n        poolData.iskinesisApproved = true;\r\n\r\n        // Interaction\r\n        require(\r\n            hasRole(\r\n                kinesis_APPROVED_POOL_OWNER_ROLE,\r\n                ISwap(poolAddress).owner()\r\n            ),\r\n            \"Pool is not owned by kinesis\"\r\n        );\r\n\r\n        emit UpdatePool(poolAddress, poolIndex, poolData);\r\n    }\r\n\r\n    /// @inheritdoc IPoolRegistry\r\n    function updatePool(PoolData memory poolData)\r\n        external\r\n        payable\r\n        override\r\n        managerOnly\r\n    {\r\n        uint256 poolIndex = poolsIndexOfPlusOne[poolData.poolAddress];\r\n        require(poolIndex > 0, \"PR: Pool not found\");\r\n        poolIndex -= 1;\r\n\r\n        pools[poolIndex] = poolData;\r\n\r\n        emit UpdatePool(poolData.poolAddress, poolIndex, poolData);\r\n    }\r\n\r\n    /// @inheritdoc IPoolRegistry\r\n    function removePool(address poolAddress)\r\n        external\r\n        payable\r\n        override\r\n        managerOnly\r\n    {\r\n        uint256 poolIndex = poolsIndexOfPlusOne[poolAddress];\r\n        require(poolIndex > 0, \"PR: Pool not found\");\r\n        poolIndex -= 1;\r\n\r\n        pools[poolIndex].isRemoved = true;\r\n\r\n        emit RemovePool(poolAddress, poolIndex);\r\n    }\r\n\r\n    /// @inheritdoc IPoolRegistry\r\n    function getPoolDataAtIndex(uint256 index)\r\n        external\r\n        view\r\n        override\r\n        returns (PoolData memory)\r\n    {\r\n        require(index < pools.length, \"PR: Index out of bounds\");\r\n        return pools[index];\r\n    }\r\n\r\n    /// @inheritdoc IPoolRegistry\r\n    function getPoolData(address poolAddress)\r\n        external\r\n        view\r\n        override\r\n        hasMatchingPool(poolAddress)\r\n        returns (PoolData memory)\r\n    {\r\n        return pools[poolsIndexOfPlusOne[poolAddress] - 1];\r\n    }\r\n\r\n    /// @inheritdoc IPoolRegistry\r\n    function getPoolDataByName(bytes32 poolName)\r\n        external\r\n        view\r\n        override\r\n        returns (PoolData memory)\r\n    {\r\n        uint256 index = poolsIndexOfNamePlusOne[poolName];\r\n        require(index > 0, \"PR: Pool not found\");\r\n        return pools[index - 1];\r\n    }\r\n\r\n    modifier hasMatchingPool(address poolAddress) {\r\n        require(\r\n            poolsIndexOfPlusOne[poolAddress] > 0,\r\n            \"PR: No matching pool found\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier managerOnly() {\r\n        require(\r\n            hasRole(kinesis_MANAGER_ROLE, msg.sender),\r\n            \"PR: Caller is not kinesis manager\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /// @inheritdoc IPoolRegistry\r\n    function getVirtualPrice(address poolAddress)\r\n        external\r\n        view\r\n        override\r\n        hasMatchingPool(poolAddress)\r\n        returns (uint256)\r\n    {\r\n        return ISwap(poolAddress).getVirtualPrice();\r\n    }\r\n\r\n    /// @inheritdoc IPoolRegistry\r\n    function getA(address poolAddress)\r\n        external\r\n        view\r\n        override\r\n        hasMatchingPool(poolAddress)\r\n        returns (uint256)\r\n    {\r\n        return ISwap(poolAddress).getA();\r\n    }\r\n\r\n    /// @inheritdoc IPoolRegistry\r\n    function getPaused(address poolAddress)\r\n        external\r\n        view\r\n        override\r\n        hasMatchingPool(poolAddress)\r\n        returns (bool)\r\n    {\r\n        return ISwap(poolAddress).paused();\r\n    }\r\n\r\n    /// @inheritdoc IPoolRegistry\r\n    function getSwapStorage(address poolAddress)\r\n        external\r\n        view\r\n        override\r\n        hasMatchingPool(poolAddress)\r\n        returns (SwapStorageData memory swapStorageData)\r\n    {\r\n        swapStorageData = pools[poolsIndexOfPlusOne[poolAddress] - 1].isGuarded\r\n            ? _getSwapStorageGuarded(poolAddress)\r\n            : _getSwapStorage(poolAddress);\r\n    }\r\n\r\n    function _getSwapStorage(address poolAddress)\r\n        internal\r\n        view\r\n        returns (SwapStorageData memory swapStorageData)\r\n    {\r\n        (\r\n            swapStorageData.initialA,\r\n            swapStorageData.futureA,\r\n            swapStorageData.initialATime,\r\n            swapStorageData.futureATime,\r\n            swapStorageData.swapFee,\r\n            swapStorageData.adminFee,\r\n            swapStorageData.lpToken\r\n        ) = ISwap(poolAddress).swapStorage();\r\n    }\r\n\r\n    function _getSwapStorageGuarded(address poolAddress)\r\n        internal\r\n        view\r\n        returns (SwapStorageData memory swapStorageData)\r\n    {\r\n        (\r\n            swapStorageData.initialA,\r\n            swapStorageData.futureA,\r\n            swapStorageData.initialATime,\r\n            swapStorageData.futureATime,\r\n            swapStorageData.swapFee,\r\n            swapStorageData.adminFee,\r\n            ,\r\n            swapStorageData.lpToken\r\n        ) = ISwapGuarded(poolAddress).swapStorage();\r\n    }\r\n\r\n    /// @inheritdoc IPoolRegistry\r\n    function getTokens(address poolAddress)\r\n        external\r\n        view\r\n        override\r\n        hasMatchingPool(poolAddress)\r\n        returns (IERC20[] memory tokens)\r\n    {\r\n        return pools[poolsIndexOfPlusOne[poolAddress] - 1].tokens;\r\n    }\r\n\r\n    /// @inheritdoc IPoolRegistry\r\n    function getUnderlyingTokens(address poolAddress)\r\n        external\r\n        view\r\n        override\r\n        hasMatchingPool(poolAddress)\r\n        returns (IERC20[] memory underlyingTokens)\r\n    {\r\n        return pools[poolsIndexOfPlusOne[poolAddress] - 1].underlyingTokens;\r\n    }\r\n\r\n    /// @inheritdoc IPoolRegistry\r\n    function getPoolsLength() external view override returns (uint256) {\r\n        return pools.length;\r\n    }\r\n\r\n    /// @inheritdoc IPoolRegistry\r\n    function getEligiblePools(address from, address to)\r\n        external\r\n        view\r\n        override\r\n        returns (address[] memory eligiblePools)\r\n    {\r\n        require(\r\n            from != address(0) && from != to,\r\n            \"PR: from and to cannot be the zero address\"\r\n        );\r\n        return eligiblePairsMap[uint160(from) ^ uint160(to)];\r\n    }\r\n\r\n    /// @inheritdoc IPoolRegistry\r\n    function getTokenBalances(address poolAddress)\r\n        external\r\n        view\r\n        override\r\n        hasMatchingPool(poolAddress)\r\n        returns (uint256[] memory balances)\r\n    {\r\n        return _getTokenBalances(poolAddress);\r\n    }\r\n\r\n    function _getTokenBalances(address poolAddress)\r\n        internal\r\n        view\r\n        returns (uint256[] memory balances)\r\n    {\r\n        uint256 tokensLength = pools[poolsIndexOfPlusOne[poolAddress] - 1]\r\n            .tokens\r\n            .length;\r\n        balances = new uint256[](tokensLength);\r\n        for (uint8 i = 0; i < tokensLength; i++) {\r\n            balances[i] = ISwap(poolAddress).getTokenBalance(i);\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc IPoolRegistry\r\n    function getUnderlyingTokenBalances(address poolAddress)\r\n        external\r\n        view\r\n        override\r\n        hasMatchingPool(poolAddress)\r\n        returns (uint256[] memory balances)\r\n    {\r\n        uint256 poolIndex = poolsIndexOfPlusOne[poolAddress] - 1;\r\n        address basePoolAddress = pools[poolIndex].basePoolAddress;\r\n        uint256[] memory basePoolBalances = _getTokenBalances(basePoolAddress);\r\n        uint256 underlyingTokensLength = pools[poolIndex]\r\n            .underlyingTokens\r\n            .length;\r\n        uint256 metaLPTokenIndex = underlyingTokensLength -\r\n            basePoolBalances.length;\r\n        uint256 baseLPTokenBalance = ISwap(poolAddress).getTokenBalance(\r\n            uint8(metaLPTokenIndex)\r\n        );\r\n        uint256 baseLPTokenTotalSupply = LPToken(\r\n            pools[poolsIndexOfPlusOne[basePoolAddress] - 1].lpToken\r\n        ).totalSupply();\r\n\r\n        balances = new uint256[](underlyingTokensLength);\r\n        for (uint8 i = 0; i < metaLPTokenIndex; i++) {\r\n            balances[i] = ISwap(poolAddress).getTokenBalance(i);\r\n        }\r\n        for (uint256 i = metaLPTokenIndex; i < underlyingTokensLength; i++) {\r\n            balances[i] = basePoolBalances[i - metaLPTokenIndex]\r\n                .mul(baseLPTokenBalance)\r\n                .div(baseLPTokenTotalSupply);\r\n        }\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () internal {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/interfaces/ISwapGuarded.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"./IAllowlist.sol\";\r\n\r\ninterface ISwapGuarded {\r\n    // pool data view functions\r\n    function getA() external view returns (uint256);\r\n\r\n    function getAllowlist() external view returns (IAllowlist);\r\n\r\n    function getToken(uint8 index) external view returns (IERC20);\r\n\r\n    function getTokenIndex(address tokenAddress) external view returns (uint8);\r\n\r\n    function getTokenBalance(uint8 index) external view returns (uint256);\r\n\r\n    function getVirtualPrice() external view returns (uint256);\r\n\r\n    function isGuarded() external view returns (bool);\r\n\r\n    // min return calculation functions\r\n    function calculateSwap(\r\n        uint8 tokenIndexFrom,\r\n        uint8 tokenIndexTo,\r\n        uint256 dx\r\n    ) external view returns (uint256);\r\n\r\n    function calculateTokenAmount(uint256[] calldata amounts, bool deposit)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function calculateRemoveLiquidity(uint256 amount)\r\n        external\r\n        view\r\n        returns (uint256[] memory);\r\n\r\n    function calculateRemoveLiquidityOneToken(\r\n        uint256 tokenAmount,\r\n        uint8 tokenIndex\r\n    ) external view returns (uint256 availableTokenAmount);\r\n\r\n    // state modifying functions\r\n    function swap(\r\n        uint8 tokenIndexFrom,\r\n        uint8 tokenIndexTo,\r\n        uint256 dx,\r\n        uint256 minDy,\r\n        uint256 deadline\r\n    ) external returns (uint256);\r\n\r\n    function addLiquidity(\r\n        uint256[] calldata amounts,\r\n        uint256 minToMint,\r\n        uint256 deadline,\r\n        bytes32[] calldata merkleProof\r\n    ) external returns (uint256);\r\n\r\n    function removeLiquidity(\r\n        uint256 amount,\r\n        uint256[] calldata minAmounts,\r\n        uint256 deadline\r\n    ) external returns (uint256[] memory);\r\n\r\n    function removeLiquidityOneToken(\r\n        uint256 tokenAmount,\r\n        uint8 tokenIndex,\r\n        uint256 minAmount,\r\n        uint256 deadline\r\n    ) external returns (uint256);\r\n\r\n    function removeLiquidityImbalance(\r\n        uint256[] calldata amounts,\r\n        uint256 maxBurnAmount,\r\n        uint256 deadline\r\n    ) external returns (uint256);\r\n\r\n    // withdraw fee update function\r\n    function updateUserWithdrawFee(address recipient, uint256 transferAmount)\r\n        external;\r\n\r\n    function swapStorage()\r\n        external\r\n        view\r\n        returns (\r\n            uint256 initialA,\r\n            uint256 futureA,\r\n            uint256 initialATime,\r\n            uint256 futureATime,\r\n            uint256 swapFee,\r\n            uint256 adminFee,\r\n            uint256 defaultWithdrawFee,\r\n            address lpToken\r\n        );\r\n}\r\n"
    },
    "contracts/interfaces/IMetaSwap.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"./ISwap.sol\";\r\n\r\ninterface IMetaSwap {\r\n    // pool data view functions\r\n    function getA() external view returns (uint256);\r\n\r\n    function getToken(uint8 index) external view returns (IERC20);\r\n\r\n    function getTokenIndex(address tokenAddress) external view returns (uint8);\r\n\r\n    function getTokenBalance(uint8 index) external view returns (uint256);\r\n\r\n    function getVirtualPrice() external view returns (uint256);\r\n\r\n    function isGuarded() external view returns (bool);\r\n\r\n    function metaSwapStorage()\r\n        external\r\n        view\r\n        returns (\r\n            address baseSwap,\r\n            uint256 baseVirtualPrice,\r\n            uint256 baseCacheLastUpdated\r\n        );\r\n\r\n    // min return calculation functions\r\n    function calculateSwap(\r\n        uint8 tokenIndexFrom,\r\n        uint8 tokenIndexTo,\r\n        uint256 dx\r\n    ) external view returns (uint256);\r\n\r\n    function calculateSwapUnderlying(\r\n        uint8 tokenIndexFrom,\r\n        uint8 tokenIndexTo,\r\n        uint256 dx\r\n    ) external view returns (uint256);\r\n\r\n    function calculateTokenAmount(uint256[] calldata amounts, bool deposit)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function calculateRemoveLiquidity(uint256 amount)\r\n        external\r\n        view\r\n        returns (uint256[] memory);\r\n\r\n    function calculateRemoveLiquidityOneToken(\r\n        uint256 tokenAmount,\r\n        uint8 tokenIndex\r\n    ) external view returns (uint256 availableTokenAmount);\r\n\r\n    // state modifying functions\r\n    function initialize(\r\n        IERC20[] memory _pooledTokens,\r\n        uint8[] memory decimals,\r\n        string memory lpTokenName,\r\n        string memory lpTokenSymbol,\r\n        uint256 _a,\r\n        uint256 _fee,\r\n        uint256 _adminFee,\r\n        address lpTokenTargetAddress\r\n    ) external;\r\n\r\n    function initializeMetaSwap(\r\n        IERC20[] memory _pooledTokens,\r\n        uint8[] memory decimals,\r\n        string memory lpTokenName,\r\n        string memory lpTokenSymbol,\r\n        uint256 _a,\r\n        uint256 _fee,\r\n        uint256 _adminFee,\r\n        address lpTokenTargetAddress,\r\n        ISwap baseSwap\r\n    ) external;\r\n\r\n    function swap(\r\n        uint8 tokenIndexFrom,\r\n        uint8 tokenIndexTo,\r\n        uint256 dx,\r\n        uint256 minDy,\r\n        uint256 deadline\r\n    ) external returns (uint256);\r\n\r\n    function swapUnderlying(\r\n        uint8 tokenIndexFrom,\r\n        uint8 tokenIndexTo,\r\n        uint256 dx,\r\n        uint256 minDy,\r\n        uint256 deadline\r\n    ) external returns (uint256);\r\n\r\n    function addLiquidity(\r\n        uint256[] calldata amounts,\r\n        uint256 minToMint,\r\n        uint256 deadline\r\n    ) external returns (uint256);\r\n\r\n    function removeLiquidity(\r\n        uint256 amount,\r\n        uint256[] calldata minAmounts,\r\n        uint256 deadline\r\n    ) external returns (uint256[] memory);\r\n\r\n    function removeLiquidityOneToken(\r\n        uint256 tokenAmount,\r\n        uint8 tokenIndex,\r\n        uint256 minAmount,\r\n        uint256 deadline\r\n    ) external returns (uint256);\r\n\r\n    function removeLiquidityImbalance(\r\n        uint256[] calldata amounts,\r\n        uint256 maxBurnAmount,\r\n        uint256 deadline\r\n    ) external returns (uint256);\r\n}\r\n"
    },
    "contracts/interfaces/IPoolRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\ninterface IPoolRegistry {\r\n    /* Structs */\r\n\r\n    struct PoolInputData {\r\n        address poolAddress;\r\n        uint8 typeOfAsset;\r\n        bytes32 poolName;\r\n        address targetAddress;\r\n        address metaSwapDepositAddress;\r\n        bool iskinesisApproved;\r\n        bool isRemoved;\r\n        bool isGuarded;\r\n    }\r\n\r\n    struct PoolData {\r\n        address poolAddress;\r\n        address lpToken;\r\n        uint8 typeOfAsset;\r\n        bytes32 poolName;\r\n        address targetAddress;\r\n        IERC20[] tokens;\r\n        IERC20[] underlyingTokens;\r\n        address basePoolAddress;\r\n        address metaSwapDepositAddress;\r\n        bool iskinesisApproved;\r\n        bool isRemoved;\r\n        bool isGuarded;\r\n    }\r\n\r\n    struct SwapStorageData {\r\n        uint256 initialA;\r\n        uint256 futureA;\r\n        uint256 initialATime;\r\n        uint256 futureATime;\r\n        uint256 swapFee;\r\n        uint256 adminFee;\r\n        address lpToken;\r\n    }\r\n\r\n    /* Public Variables */\r\n\r\n    /**\r\n     * @notice Returns the index + 1 of the pool address in the registry\r\n     * @param poolAddress address to look for\r\n     */\r\n    function poolsIndexOfPlusOne(address poolAddress)\r\n        external\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @notice Returns the index + 1 of the pool name in the registry\r\n     * @param poolName pool name in bytes32 format to look for\r\n     */\r\n    function poolsIndexOfNamePlusOne(bytes32 poolName)\r\n        external\r\n        returns (uint256);\r\n\r\n    /* Functions */\r\n\r\n    /**\r\n     * @notice Add a new pool to the registry\r\n     * @param inputData PoolInputData struct for the new pool\r\n     * @dev Before adding a meta pool, the user must first add the underlying base pool.\r\n     * Only Swap and MetaSwap contracts need to be added.\r\n     */\r\n    function addPool(PoolInputData memory inputData) external payable;\r\n\r\n    /**\r\n     * @notice Add a new pool to the registry\r\n     * @param data PoolInputData struct for the new pool\r\n     * @dev Before adding a meta pool, the user must first add the underlying base pool.\r\n     * Only Swap and MetaSwap contracts need to be added.\r\n     */\r\n    function addCommunityPool(PoolData memory data) external payable;\r\n\r\n    /**\r\n     * @notice Approve community deployed pools to be upgraded as kinesis owned\r\n     * @dev since array entries are difficult to remove, we modify the entry to mark it\r\n     * as a kinesis owned pool.\r\n     * @param poolAddress address of the community pool\r\n     */\r\n    function approvePool(address poolAddress) external payable;\r\n\r\n    /**\r\n     * @notice Overwrite existing entry with new PoolData\r\n     * @param poolData new PoolData struct to store\r\n     */\r\n    function updatePool(PoolData memory poolData) external payable;\r\n\r\n    /**\r\n     * @notice Remove pool from the registry\r\n     * @dev Since arrays are not easily reducable, the entry will be marked as removed.\r\n     * @param poolAddress address of the pool to remove\r\n     */\r\n    function removePool(address poolAddress) external payable;\r\n\r\n    /**\r\n     * @notice Returns PoolData for given pool address\r\n     * @param poolAddress address of the pool to read\r\n     */\r\n    function getPoolData(address poolAddress)\r\n        external\r\n        view\r\n        returns (PoolData memory);\r\n\r\n    /**\r\n     * @notice Returns PoolData at given index\r\n     * @param index index of the pool to read\r\n     */\r\n    function getPoolDataAtIndex(uint256 index)\r\n        external\r\n        view\r\n        returns (PoolData memory);\r\n\r\n    /**\r\n     * @notice Returns PoolData with given name\r\n     * @param poolName name of the pool to read\r\n     */\r\n    function getPoolDataByName(bytes32 poolName)\r\n        external\r\n        view\r\n        returns (PoolData memory);\r\n\r\n    /**\r\n     * @notice Returns virtual price of the given pool address\r\n     * @param poolAddress address of the pool to read\r\n     */\r\n    function getVirtualPrice(address poolAddress)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @notice Returns A of the given pool address\r\n     * @param poolAddress address of the pool to read\r\n     */\r\n    function getA(address poolAddress) external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Returns the paused status of the given pool address\r\n     * @param poolAddress address of the pool to read\r\n     */\r\n    function getPaused(address poolAddress) external view returns (bool);\r\n\r\n    /**\r\n     * @notice Returns the SwapStorage struct of the given pool address\r\n     * @param poolAddress address of the pool to read\r\n     */\r\n    function getSwapStorage(address poolAddress)\r\n        external\r\n        view\r\n        returns (SwapStorageData memory swapStorageData);\r\n\r\n    /**\r\n     * @notice Returns the tokens of the given pool address\r\n     * @param poolAddress address of the pool to read\r\n     */\r\n    function getTokens(address poolAddress)\r\n        external\r\n        view\r\n        returns (IERC20[] memory);\r\n\r\n    /**\r\n     * @notice Returns the underlying tokens of the given pool address. Base pools will return an empty array.\r\n     * @param poolAddress address of the pool to read\r\n     */\r\n    function getUnderlyingTokens(address poolAddress)\r\n        external\r\n        view\r\n        returns (IERC20[] memory);\r\n\r\n    /**\r\n     * @notice Returns number of entries in the registry. Includes removed pools\r\n     * in the list as well.\r\n     */\r\n    function getPoolsLength() external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Returns an array of pool addresses that can swap between from and to\r\n     * @param from address of the token to swap from\r\n     * @param to address of the token to swap to\r\n     * @return eligiblePools array of pool addresses that can swap between from and to\r\n     */\r\n    function getEligiblePools(address from, address to)\r\n        external\r\n        view\r\n        returns (address[] memory eligiblePools);\r\n\r\n    /**\r\n     * @notice Returns an array of balances of the tokens\r\n     * @param poolAddress address of the pool to look up the token balances for\r\n     * @return balances array of token balances\r\n     */\r\n    function getTokenBalances(address poolAddress)\r\n        external\r\n        view\r\n        returns (uint256[] memory balances);\r\n\r\n    /**\r\n     * @notice Returns an array of balances of the tokens\r\n     * @param poolAddress address of the pool to look up the token balances for\r\n     * @return balances array of token balances\r\n     */\r\n    function getUnderlyingTokenBalances(address poolAddress)\r\n        external\r\n        view\r\n        returns (uint256[] memory balances);\r\n}\r\n"
    },
    "contracts/meta/MetaSwapDeposit.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\r\nimport \"../LPToken.sol\";\r\nimport \"../interfaces/ISwap.sol\";\r\nimport \"../interfaces/IMetaSwap.sol\";\r\n\r\n/**\r\n * @title MetaSwapDeposit\r\n * @notice This contract flattens the LP token in a MetaSwap pool for easier user access. MetaSwap must be\r\n * deployed before this contract can be initialized successfully.\r\n *\r\n * For example, suppose there exists a base Swap pool consisting of [DAI, USDC, USDT].\r\n * Then a MetaSwap pool can be created with [sUSD, BaseSwapLPToken] to allow trades between either\r\n * the LP token or the underlying tokens and sUSD.\r\n *\r\n * MetaSwapDeposit flattens the LP token and remaps them to a single array, allowing users\r\n * to ignore the dependency on BaseSwapLPToken. Using the above example, MetaSwapDeposit can act\r\n * as a Swap containing [sUSD, DAI, USDC, USDT] tokens.\r\n */\r\ncontract MetaSwapDeposit is Initializable, ReentrancyGuardUpgradeable {\r\n    using SafeERC20 for IERC20;\r\n    using SafeMath for uint256;\r\n\r\n    ISwap public baseSwap;\r\n    IMetaSwap public metaSwap;\r\n    IERC20[] public baseTokens;\r\n    IERC20[] public metaTokens;\r\n    IERC20[] public tokens;\r\n    IERC20 public metaLPToken;\r\n\r\n    uint256 constant MAX_UINT256 = 2**256 - 1;\r\n\r\n    struct RemoveLiquidityImbalanceInfo {\r\n        ISwap baseSwap;\r\n        IMetaSwap metaSwap;\r\n        IERC20 metaLPToken;\r\n        uint8 baseLPTokenIndex;\r\n        bool withdrawFromBase;\r\n        uint256 leftoverMetaLPTokenAmount;\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the address for the base Swap contract, MetaSwap contract, and the\r\n     * MetaSwap LP token contract.\r\n     * @param _baseSwap the address of the base Swap contract\r\n     * @param _metaSwap the address of the MetaSwap contract\r\n     * @param _metaLPToken the address of the MetaSwap LP token contract\r\n     */\r\n    function initialize(\r\n        ISwap _baseSwap,\r\n        IMetaSwap _metaSwap,\r\n        IERC20 _metaLPToken\r\n    ) external initializer {\r\n        __ReentrancyGuard_init();\r\n        // Check and approve base level tokens to be deposited to the base Swap contract\r\n        {\r\n            uint8 i;\r\n            for (; i < 32; i++) {\r\n                try _baseSwap.getToken(i) returns (IERC20 token) {\r\n                    baseTokens.push(token);\r\n                    token.safeApprove(address(_baseSwap), MAX_UINT256);\r\n                    token.safeApprove(address(_metaSwap), MAX_UINT256);\r\n                } catch {\r\n                    break;\r\n                }\r\n            }\r\n            require(i > 1, \"baseSwap must have at least 2 tokens\");\r\n        }\r\n\r\n        // Check and approve meta level tokens to be deposited to the MetaSwap contract\r\n        IERC20 baseLPToken;\r\n        {\r\n            uint8 i;\r\n            for (; i < 32; i++) {\r\n                try _metaSwap.getToken(i) returns (IERC20 token) {\r\n                    baseLPToken = token;\r\n                    metaTokens.push(token);\r\n                    tokens.push(token);\r\n                    token.safeApprove(address(_metaSwap), MAX_UINT256);\r\n                } catch {\r\n                    break;\r\n                }\r\n            }\r\n            require(i > 1, \"metaSwap must have at least 2 tokens\");\r\n        }\r\n\r\n        // Flatten baseTokens and append it to tokens array\r\n        tokens[tokens.length - 1] = baseTokens[0];\r\n        for (uint8 i = 1; i < baseTokens.length; i++) {\r\n            tokens.push(baseTokens[i]);\r\n        }\r\n\r\n        // Approve base Swap LP token to be burned by the base Swap contract for withdrawing\r\n        baseLPToken.safeApprove(address(_baseSwap), MAX_UINT256);\r\n        // Approve MetaSwap LP token to be burned by the MetaSwap contract for withdrawing\r\n        _metaLPToken.safeApprove(address(_metaSwap), MAX_UINT256);\r\n\r\n        // Initialize storage variables\r\n        baseSwap = _baseSwap;\r\n        metaSwap = _metaSwap;\r\n        metaLPToken = _metaLPToken;\r\n    }\r\n\r\n    // Mutative functions\r\n\r\n    /**\r\n     * @notice Swap two underlying tokens using the meta pool and the base pool\r\n     * @param tokenIndexFrom the token the user wants to swap from\r\n     * @param tokenIndexTo the token the user wants to swap to\r\n     * @param dx the amount of tokens the user wants to swap from\r\n     * @param minDy the min amount the user would like to receive, or revert.\r\n     * @param deadline latest timestamp to accept this transaction\r\n     */\r\n    function swap(\r\n        uint8 tokenIndexFrom,\r\n        uint8 tokenIndexTo,\r\n        uint256 dx,\r\n        uint256 minDy,\r\n        uint256 deadline\r\n    ) external nonReentrant returns (uint256) {\r\n        tokens[tokenIndexFrom].safeTransferFrom(msg.sender, address(this), dx);\r\n        uint256 tokenToAmount = metaSwap.swapUnderlying(\r\n            tokenIndexFrom,\r\n            tokenIndexTo,\r\n            dx,\r\n            minDy,\r\n            deadline\r\n        );\r\n        tokens[tokenIndexTo].safeTransfer(msg.sender, tokenToAmount);\r\n        return tokenToAmount;\r\n    }\r\n\r\n    /**\r\n     * @notice Add liquidity to the pool with the given amounts of tokens\r\n     * @param amounts the amounts of each token to add, in their native precision\r\n     * @param minToMint the minimum LP tokens adding this amount of liquidity\r\n     * should mint, otherwise revert. Handy for front-running mitigation\r\n     * @param deadline latest timestamp to accept this transaction\r\n     * @return amount of LP token user minted and received\r\n     */\r\n    function addLiquidity(\r\n        uint256[] calldata amounts,\r\n        uint256 minToMint,\r\n        uint256 deadline\r\n    ) external nonReentrant returns (uint256) {\r\n        // Read to memory to save on gas\r\n        IERC20[] memory memBaseTokens = baseTokens;\r\n        IERC20[] memory memMetaTokens = metaTokens;\r\n        uint256 baseLPTokenIndex = memMetaTokens.length - 1;\r\n\r\n        require(amounts.length == memBaseTokens.length + baseLPTokenIndex);\r\n\r\n        uint256 baseLPTokenAmount;\r\n        {\r\n            // Transfer base tokens from the caller and deposit to the base Swap pool\r\n            uint256[] memory baseAmounts = new uint256[](memBaseTokens.length);\r\n            bool shouldDepositBaseTokens;\r\n            for (uint8 i = 0; i < memBaseTokens.length; i++) {\r\n                IERC20 token = memBaseTokens[i];\r\n                uint256 depositAmount = amounts[baseLPTokenIndex + i];\r\n                if (depositAmount > 0) {\r\n                    token.safeTransferFrom(\r\n                        msg.sender,\r\n                        address(this),\r\n                        depositAmount\r\n                    );\r\n                    baseAmounts[i] = token.balanceOf(address(this)); // account for any fees on transfer\r\n                    // if there are any base Swap level tokens, flag it for deposits\r\n                    shouldDepositBaseTokens = true;\r\n                }\r\n            }\r\n            if (shouldDepositBaseTokens) {\r\n                // Deposit any base Swap level tokens and receive baseLPToken\r\n                baseLPTokenAmount = baseSwap.addLiquidity(\r\n                    baseAmounts,\r\n                    0,\r\n                    deadline\r\n                );\r\n            }\r\n        }\r\n\r\n        uint256 metaLPTokenAmount;\r\n        {\r\n            // Transfer remaining meta level tokens from the caller\r\n            uint256[] memory metaAmounts = new uint256[](metaTokens.length);\r\n            for (uint8 i = 0; i < baseLPTokenIndex; i++) {\r\n                IERC20 token = memMetaTokens[i];\r\n                uint256 depositAmount = amounts[i];\r\n                if (depositAmount > 0) {\r\n                    token.safeTransferFrom(\r\n                        msg.sender,\r\n                        address(this),\r\n                        depositAmount\r\n                    );\r\n                    metaAmounts[i] = token.balanceOf(address(this)); // account for any fees on transfer\r\n                }\r\n            }\r\n            // Update the baseLPToken amount that will be deposited\r\n            metaAmounts[baseLPTokenIndex] = baseLPTokenAmount;\r\n\r\n            // Deposit the meta level tokens and the baseLPToken\r\n            metaLPTokenAmount = metaSwap.addLiquidity(\r\n                metaAmounts,\r\n                minToMint,\r\n                deadline\r\n            );\r\n        }\r\n\r\n        // Transfer the meta lp token to the caller\r\n        metaLPToken.safeTransfer(msg.sender, metaLPTokenAmount);\r\n\r\n        return metaLPTokenAmount;\r\n    }\r\n\r\n    /**\r\n     * @notice Burn LP tokens to remove liquidity from the pool. Withdraw fee that decays linearly\r\n     * over period of 4 weeks since last deposit will apply.\r\n     * @dev Liquidity can always be removed, even when the pool is paused.\r\n     * @param amount the amount of LP tokens to burn\r\n     * @param minAmounts the minimum amounts of each token in the pool\r\n     *        acceptable for this burn. Useful as a front-running mitigation\r\n     * @param deadline latest timestamp to accept this transaction\r\n     * @return amounts of tokens user received\r\n     */\r\n    function removeLiquidity(\r\n        uint256 amount,\r\n        uint256[] calldata minAmounts,\r\n        uint256 deadline\r\n    ) external nonReentrant returns (uint256[] memory) {\r\n        IERC20[] memory memBaseTokens = baseTokens;\r\n        IERC20[] memory memMetaTokens = metaTokens;\r\n        uint256[] memory totalRemovedAmounts;\r\n\r\n        {\r\n            uint256 numOfAllTokens = memBaseTokens.length +\r\n                memMetaTokens.length -\r\n                1;\r\n            require(minAmounts.length == numOfAllTokens, \"out of range\");\r\n            totalRemovedAmounts = new uint256[](numOfAllTokens);\r\n        }\r\n\r\n        // Transfer meta lp token from the caller to this\r\n        metaLPToken.safeTransferFrom(msg.sender, address(this), amount);\r\n\r\n        uint256 baseLPTokenAmount;\r\n        {\r\n            // Remove liquidity from the MetaSwap pool\r\n            uint256[] memory removedAmounts;\r\n            uint256 baseLPTokenIndex = memMetaTokens.length - 1;\r\n            {\r\n                uint256[] memory metaMinAmounts = new uint256[](\r\n                    memMetaTokens.length\r\n                );\r\n                for (uint8 i = 0; i < baseLPTokenIndex; i++) {\r\n                    metaMinAmounts[i] = minAmounts[i];\r\n                }\r\n                removedAmounts = metaSwap.removeLiquidity(\r\n                    amount,\r\n                    metaMinAmounts,\r\n                    deadline\r\n                );\r\n            }\r\n\r\n            // Send the meta level tokens to the caller\r\n            for (uint8 i = 0; i < baseLPTokenIndex; i++) {\r\n                totalRemovedAmounts[i] = removedAmounts[i];\r\n                memMetaTokens[i].safeTransfer(msg.sender, removedAmounts[i]);\r\n            }\r\n            baseLPTokenAmount = removedAmounts[baseLPTokenIndex];\r\n\r\n            // Remove liquidity from the base Swap pool\r\n            {\r\n                uint256[] memory baseMinAmounts = new uint256[](\r\n                    memBaseTokens.length\r\n                );\r\n                for (uint8 i = 0; i < baseLPTokenIndex; i++) {\r\n                    baseMinAmounts[i] = minAmounts[baseLPTokenIndex + i];\r\n                }\r\n                removedAmounts = baseSwap.removeLiquidity(\r\n                    baseLPTokenAmount,\r\n                    baseMinAmounts,\r\n                    deadline\r\n                );\r\n            }\r\n\r\n            // Send the base level tokens to the caller\r\n            for (uint8 i = 0; i < memBaseTokens.length; i++) {\r\n                totalRemovedAmounts[baseLPTokenIndex + i] = removedAmounts[i];\r\n                memBaseTokens[i].safeTransfer(msg.sender, removedAmounts[i]);\r\n            }\r\n        }\r\n\r\n        return totalRemovedAmounts;\r\n    }\r\n\r\n    /**\r\n     * @notice Remove liquidity from the pool all in one token. Withdraw fee that decays linearly\r\n     * over period of 4 weeks since last deposit will apply.\r\n     * @param tokenAmount the amount of the token you want to receive\r\n     * @param tokenIndex the index of the token you want to receive\r\n     * @param minAmount the minimum amount to withdraw, otherwise revert\r\n     * @param deadline latest timestamp to accept this transaction\r\n     * @return amount of chosen token user received\r\n     */\r\n    function removeLiquidityOneToken(\r\n        uint256 tokenAmount,\r\n        uint8 tokenIndex,\r\n        uint256 minAmount,\r\n        uint256 deadline\r\n    ) external nonReentrant returns (uint256) {\r\n        uint8 baseLPTokenIndex = uint8(metaTokens.length - 1);\r\n        uint8 baseTokensLength = uint8(baseTokens.length);\r\n\r\n        // Transfer metaLPToken from the caller\r\n        metaLPToken.safeTransferFrom(msg.sender, address(this), tokenAmount);\r\n\r\n        IERC20 token;\r\n        if (tokenIndex < baseLPTokenIndex) {\r\n            // When the desired token is meta level token, we can just call `removeLiquidityOneToken` directly\r\n            metaSwap.removeLiquidityOneToken(\r\n                tokenAmount,\r\n                tokenIndex,\r\n                minAmount,\r\n                deadline\r\n            );\r\n            token = metaTokens[tokenIndex];\r\n        } else if (tokenIndex < baseLPTokenIndex + baseTokensLength) {\r\n            // When the desired token is a base level token, we need to first withdraw via baseLPToken, then withdraw\r\n            // the desired token from the base Swap contract.\r\n            uint256 removedBaseLPTokenAmount = metaSwap.removeLiquidityOneToken(\r\n                tokenAmount,\r\n                baseLPTokenIndex,\r\n                0,\r\n                deadline\r\n            );\r\n\r\n            baseSwap.removeLiquidityOneToken(\r\n                removedBaseLPTokenAmount,\r\n                tokenIndex - baseLPTokenIndex,\r\n                minAmount,\r\n                deadline\r\n            );\r\n            token = baseTokens[tokenIndex - baseLPTokenIndex];\r\n        } else {\r\n            revert(\"out of range\");\r\n        }\r\n\r\n        uint256 amountWithdrawn = token.balanceOf(address(this));\r\n        token.safeTransfer(msg.sender, amountWithdrawn);\r\n        return amountWithdrawn;\r\n    }\r\n\r\n    /**\r\n     * @notice Remove liquidity from the pool, weighted differently than the\r\n     * pool's current balances. Withdraw fee that decays linearly\r\n     * over period of 4 weeks since last deposit will apply.\r\n     * @param amounts how much of each token to withdraw\r\n     * @param maxBurnAmount the max LP token provider is willing to pay to\r\n     * remove liquidity. Useful as a front-running mitigation.\r\n     * @param deadline latest timestamp to accept this transaction\r\n     * @return amount of LP tokens burned\r\n     */\r\n    function removeLiquidityImbalance(\r\n        uint256[] calldata amounts,\r\n        uint256 maxBurnAmount,\r\n        uint256 deadline\r\n    ) external nonReentrant returns (uint256) {\r\n        IERC20[] memory memBaseTokens = baseTokens;\r\n        IERC20[] memory memMetaTokens = metaTokens;\r\n        uint256[] memory metaAmounts = new uint256[](memMetaTokens.length);\r\n        uint256[] memory baseAmounts = new uint256[](memBaseTokens.length);\r\n\r\n        require(\r\n            amounts.length == memBaseTokens.length + memMetaTokens.length - 1,\r\n            \"out of range\"\r\n        );\r\n\r\n        RemoveLiquidityImbalanceInfo memory v = RemoveLiquidityImbalanceInfo(\r\n            baseSwap,\r\n            metaSwap,\r\n            metaLPToken,\r\n            uint8(metaAmounts.length - 1),\r\n            false,\r\n            0\r\n        );\r\n\r\n        for (uint8 i = 0; i < v.baseLPTokenIndex; i++) {\r\n            metaAmounts[i] = amounts[i];\r\n        }\r\n\r\n        for (uint8 i = 0; i < baseAmounts.length; i++) {\r\n            baseAmounts[i] = amounts[v.baseLPTokenIndex + i];\r\n            if (baseAmounts[i] > 0) {\r\n                v.withdrawFromBase = true;\r\n            }\r\n        }\r\n\r\n        // Calculate how much base LP token we need to get the desired amount of underlying tokens\r\n        if (v.withdrawFromBase) {\r\n            metaAmounts[v.baseLPTokenIndex] = v\r\n                .baseSwap\r\n                .calculateTokenAmount(baseAmounts, false)\r\n                .mul(10005)\r\n                .div(10000);\r\n        }\r\n\r\n        // Transfer MetaSwap LP token from the caller to this contract\r\n        v.metaLPToken.safeTransferFrom(\r\n            msg.sender,\r\n            address(this),\r\n            maxBurnAmount\r\n        );\r\n\r\n        // Withdraw the paired meta level tokens and the base LP token from the MetaSwap pool\r\n        uint256 burnedMetaLPTokenAmount = v.metaSwap.removeLiquidityImbalance(\r\n            metaAmounts,\r\n            maxBurnAmount,\r\n            deadline\r\n        );\r\n        v.leftoverMetaLPTokenAmount = maxBurnAmount.sub(\r\n            burnedMetaLPTokenAmount\r\n        );\r\n\r\n        // If underlying tokens are desired, withdraw them from the base Swap pool\r\n        if (v.withdrawFromBase) {\r\n            v.baseSwap.removeLiquidityImbalance(\r\n                baseAmounts,\r\n                metaAmounts[v.baseLPTokenIndex],\r\n                deadline\r\n            );\r\n\r\n            // Base Swap may require LESS base LP token than the amount we have\r\n            // In that case, deposit it to the MetaSwap pool.\r\n            uint256[] memory leftovers = new uint256[](metaAmounts.length);\r\n            IERC20 baseLPToken = memMetaTokens[v.baseLPTokenIndex];\r\n            uint256 leftoverBaseLPTokenAmount = baseLPToken.balanceOf(\r\n                address(this)\r\n            );\r\n            if (leftoverBaseLPTokenAmount > 0) {\r\n                leftovers[v.baseLPTokenIndex] = leftoverBaseLPTokenAmount;\r\n                v.leftoverMetaLPTokenAmount = v.leftoverMetaLPTokenAmount.add(\r\n                    v.metaSwap.addLiquidity(leftovers, 0, deadline)\r\n                );\r\n            }\r\n        }\r\n\r\n        // Transfer all withdrawn tokens to the caller\r\n        for (uint8 i = 0; i < amounts.length; i++) {\r\n            IERC20 token;\r\n            if (i < v.baseLPTokenIndex) {\r\n                token = memMetaTokens[i];\r\n            } else {\r\n                token = memBaseTokens[i - v.baseLPTokenIndex];\r\n            }\r\n            if (amounts[i] > 0) {\r\n                token.safeTransfer(msg.sender, amounts[i]);\r\n            }\r\n        }\r\n\r\n        // If there were any extra meta lp token, transfer them back to the caller as well\r\n        if (v.leftoverMetaLPTokenAmount > 0) {\r\n            v.metaLPToken.safeTransfer(msg.sender, v.leftoverMetaLPTokenAmount);\r\n        }\r\n\r\n        return maxBurnAmount - v.leftoverMetaLPTokenAmount;\r\n    }\r\n\r\n    // VIEW FUNCTIONS\r\n\r\n    /**\r\n     * @notice A simple method to calculate prices from deposits or\r\n     * withdrawals, excluding fees but including slippage. This is\r\n     * helpful as an input into the various \"min\" parameters on calls\r\n     * to fight front-running. When withdrawing from the base pool in imbalanced\r\n     * fashion, the recommended slippage setting is 0.2% or higher.\r\n     *\r\n     * @dev This shouldn't be used outside frontends for user estimates.\r\n     *\r\n     * @param amounts an array of token amounts to deposit or withdrawal,\r\n     * corresponding to pooledTokens. The amount should be in each\r\n     * pooled token's native precision. If a token charges a fee on transfers,\r\n     * use the amount that gets transferred after the fee.\r\n     * @param deposit whether this is a deposit or a withdrawal\r\n     * @return token amount the user will receive\r\n     */\r\n    function calculateTokenAmount(uint256[] calldata amounts, bool deposit)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256[] memory metaAmounts = new uint256[](metaTokens.length);\r\n        uint256[] memory baseAmounts = new uint256[](baseTokens.length);\r\n        uint256 baseLPTokenIndex = metaAmounts.length - 1;\r\n\r\n        for (uint8 i = 0; i < baseLPTokenIndex; i++) {\r\n            metaAmounts[i] = amounts[i];\r\n        }\r\n\r\n        for (uint8 i = 0; i < baseAmounts.length; i++) {\r\n            baseAmounts[i] = amounts[baseLPTokenIndex + i];\r\n        }\r\n\r\n        uint256 baseLPTokenAmount = baseSwap.calculateTokenAmount(\r\n            baseAmounts,\r\n            deposit\r\n        );\r\n        metaAmounts[baseLPTokenIndex] = baseLPTokenAmount;\r\n\r\n        return metaSwap.calculateTokenAmount(metaAmounts, deposit);\r\n    }\r\n\r\n    /**\r\n     * @notice A simple method to calculate amount of each underlying\r\n     * tokens that is returned upon burning given amount of LP tokens\r\n     * @param amount the amount of LP tokens that would be burned on withdrawal\r\n     * @return array of token balances that the user will receive\r\n     */\r\n    function calculateRemoveLiquidity(uint256 amount)\r\n        external\r\n        view\r\n        returns (uint256[] memory)\r\n    {\r\n        uint256[] memory metaAmounts = metaSwap.calculateRemoveLiquidity(\r\n            amount\r\n        );\r\n        uint8 baseLPTokenIndex = uint8(metaAmounts.length - 1);\r\n        uint256[] memory baseAmounts = baseSwap.calculateRemoveLiquidity(\r\n            metaAmounts[baseLPTokenIndex]\r\n        );\r\n\r\n        uint256[] memory totalAmounts = new uint256[](\r\n            baseLPTokenIndex + baseAmounts.length\r\n        );\r\n        for (uint8 i = 0; i < baseLPTokenIndex; i++) {\r\n            totalAmounts[i] = metaAmounts[i];\r\n        }\r\n        for (uint8 i = 0; i < baseAmounts.length; i++) {\r\n            totalAmounts[baseLPTokenIndex + i] = baseAmounts[i];\r\n        }\r\n\r\n        return totalAmounts;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the amount of underlying token available to withdraw\r\n     * when withdrawing via only single token\r\n     * @param tokenAmount the amount of LP token to burn\r\n     * @param tokenIndex index of which token will be withdrawn\r\n     * @return availableTokenAmount calculated amount of underlying token\r\n     * available to withdraw\r\n     */\r\n    function calculateRemoveLiquidityOneToken(\r\n        uint256 tokenAmount,\r\n        uint8 tokenIndex\r\n    ) external view returns (uint256) {\r\n        uint8 baseLPTokenIndex = uint8(metaTokens.length - 1);\r\n\r\n        if (tokenIndex < baseLPTokenIndex) {\r\n            return\r\n                metaSwap.calculateRemoveLiquidityOneToken(\r\n                    tokenAmount,\r\n                    tokenIndex\r\n                );\r\n        } else {\r\n            uint256 baseLPTokenAmount = metaSwap\r\n                .calculateRemoveLiquidityOneToken(\r\n                    tokenAmount,\r\n                    baseLPTokenIndex\r\n                );\r\n            return\r\n                baseSwap.calculateRemoveLiquidityOneToken(\r\n                    baseLPTokenAmount,\r\n                    tokenIndex - baseLPTokenIndex\r\n                );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the address of the pooled token at given index. Reverts if tokenIndex is out of range.\r\n     * This is a flattened representation of the pooled tokens.\r\n     * @param index the index of the token\r\n     * @return address of the token at given index\r\n     */\r\n    function getToken(uint8 index) external view returns (IERC20) {\r\n        require(index < tokens.length, \"index out of range\");\r\n        return tokens[index];\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate amount of tokens you receive on swap\r\n     * @param tokenIndexFrom the token the user wants to sell\r\n     * @param tokenIndexTo the token the user wants to buy\r\n     * @param dx the amount of tokens the user wants to sell. If the token charges\r\n     * a fee on transfers, use the amount that gets transferred after the fee.\r\n     * @return amount of tokens the user will receive\r\n     */\r\n    function calculateSwap(\r\n        uint8 tokenIndexFrom,\r\n        uint8 tokenIndexTo,\r\n        uint256 dx\r\n    ) external view returns (uint256) {\r\n        return\r\n            metaSwap.calculateSwapUnderlying(tokenIndexFrom, tokenIndexTo, dx);\r\n    }\r\n}\r\n"
    },
    "contracts/SwapDeployer.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\r\nimport \"./interfaces/ISwap.sol\";\r\nimport \"./interfaces/IMetaSwap.sol\";\r\n\r\ncontract SwapDeployer is Ownable {\r\n    event NewSwapPool(\r\n        address indexed deployer,\r\n        address swapAddress,\r\n        IERC20[] pooledTokens\r\n    );\r\n    event NewClone(address indexed target, address cloneAddress);\r\n\r\n    constructor() public Ownable() {}\r\n\r\n    function clone(address target) external returns (address) {\r\n        address newClone = _clone(target);\r\n        emit NewClone(target, newClone);\r\n\r\n        return newClone;\r\n    }\r\n\r\n    function _clone(address target) internal returns (address) {\r\n        return Clones.clone(target);\r\n    }\r\n\r\n    function deploy(\r\n        address swapAddress,\r\n        IERC20[] memory _pooledTokens,\r\n        uint8[] memory decimals,\r\n        string memory lpTokenName,\r\n        string memory lpTokenSymbol,\r\n        uint256 _a,\r\n        uint256 _fee,\r\n        uint256 _adminFee,\r\n        address lpTokenTargetAddress\r\n    ) external returns (address) {\r\n        address swapClone = _clone(swapAddress);\r\n        ISwap(swapClone).initialize(\r\n            _pooledTokens,\r\n            decimals,\r\n            lpTokenName,\r\n            lpTokenSymbol,\r\n            _a,\r\n            _fee,\r\n            _adminFee,\r\n            lpTokenTargetAddress\r\n        );\r\n        Ownable(swapClone).transferOwnership(owner());\r\n        emit NewSwapPool(msg.sender, swapClone, _pooledTokens);\r\n        return swapClone;\r\n    }\r\n\r\n    function deployMetaSwap(\r\n        address metaSwapAddress,\r\n        IERC20[] memory _pooledTokens,\r\n        uint8[] memory decimals,\r\n        string memory lpTokenName,\r\n        string memory lpTokenSymbol,\r\n        uint256 _a,\r\n        uint256 _fee,\r\n        uint256 _adminFee,\r\n        address lpTokenTargetAddress,\r\n        ISwap baseSwap\r\n    ) external returns (address) {\r\n        address metaSwapClone = _clone(metaSwapAddress);\r\n        IMetaSwap(metaSwapClone).initializeMetaSwap(\r\n            _pooledTokens,\r\n            decimals,\r\n            lpTokenName,\r\n            lpTokenSymbol,\r\n            _a,\r\n            _fee,\r\n            _adminFee,\r\n            lpTokenTargetAddress,\r\n            baseSwap\r\n        );\r\n        Ownable(metaSwapClone).transferOwnership(owner());\r\n        emit NewSwapPool(msg.sender, metaSwapClone, _pooledTokens);\r\n        return metaSwapClone;\r\n    }\r\n}\r\n"
    },
    "contracts/VirtualSwap/SynthSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"synthetix/contracts/interfaces/ISynthetix.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\r\nimport \"../interfaces/ISwap.sol\";\r\n\r\n/**\r\n * @title SynthSwapper\r\n * @notice Replacement of Virtual Synths in favor of gas savings. Allows swapping synths via the Synthetix protocol\r\n * or kinesis's pools. The `Bridge.sol` contract will deploy minimal clones of this contract upon initiating\r\n * any cross-asset swaps.\r\n */\r\ncontract SynthSwapper is Initializable {\r\n    using SafeERC20 for IERC20;\r\n\r\n    address payable owner;\r\n    // SYNTHETIX points to `ProxyERC20` (0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F).\r\n    // This contract is a proxy of `Synthetix` and is used to exchange synths.\r\n    ISynthetix public constant SYNTHETIX =\r\n        ISynthetix(0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F);\r\n    // \"kinesis\" in bytes32 form\r\n    bytes32 public constant TRACKING =\r\n        0x534144444c450000000000000000000000000000000000000000000000000000;\r\n\r\n    /**\r\n     * @notice Initializes the contract when deploying this directly. This prevents\r\n     * others from calling initialize() on the target contract and setting themself as the owner.\r\n     */\r\n    constructor() public {\r\n        initialize();\r\n    }\r\n\r\n    /**\r\n     * @notice This modifier checks if the caller is the owner\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"is not owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the `owner` as the caller of this function\r\n     */\r\n    function initialize() public initializer {\r\n        require(owner == address(0), \"owner already set\");\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @notice Swaps the synth to another synth via the Synthetix protocol.\r\n     * @param sourceKey currency key of the source synth\r\n     * @param synthAmount amount of the synth to swap\r\n     * @param destKey currency key of the destination synth\r\n     * @return amount of the destination synth received\r\n     */\r\n    function swapSynth(\r\n        bytes32 sourceKey,\r\n        uint256 synthAmount,\r\n        bytes32 destKey\r\n    ) external onlyOwner returns (uint256) {\r\n        return\r\n            SYNTHETIX.exchangeWithTracking(\r\n                sourceKey,\r\n                synthAmount,\r\n                destKey,\r\n                msg.sender,\r\n                TRACKING\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @notice Approves the given `tokenFrom` and swaps it to another token via the given `swap` pool.\r\n     * @param swap the address of a pool to swap through\r\n     * @param tokenFrom the address of the stored synth\r\n     * @param tokenFromIndex the index of the token to swap from\r\n     * @param tokenToIndex the token the user wants to swap to\r\n     * @param tokenFromAmount the amount of the token to swap\r\n     * @param minAmount the min amount the user would like to receive, or revert.\r\n     * @param deadline latest timestamp to accept this transaction\r\n     * @param recipient the address of the recipient\r\n     */\r\n    function swapSynthToToken(\r\n        ISwap swap,\r\n        IERC20 tokenFrom,\r\n        uint8 tokenFromIndex,\r\n        uint8 tokenToIndex,\r\n        uint256 tokenFromAmount,\r\n        uint256 minAmount,\r\n        uint256 deadline,\r\n        address recipient\r\n    ) external onlyOwner returns (IERC20, uint256) {\r\n        tokenFrom.approve(address(swap), tokenFromAmount);\r\n        swap.swap(\r\n            tokenFromIndex,\r\n            tokenToIndex,\r\n            tokenFromAmount,\r\n            minAmount,\r\n            deadline\r\n        );\r\n        IERC20 tokenTo = swap.getToken(tokenToIndex);\r\n        uint256 balance = tokenTo.balanceOf(address(this));\r\n        tokenTo.safeTransfer(recipient, balance);\r\n        return (tokenTo, balance);\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraws the given amount of `token` to the `recipient`.\r\n     * @param token the address of the token to withdraw\r\n     * @param recipient the address of the account to receive the token\r\n     * @param withdrawAmount the amount of the token to withdraw\r\n     * @param shouldDestroy whether this contract should be destroyed after this call\r\n     */\r\n    function withdraw(\r\n        IERC20 token,\r\n        address recipient,\r\n        uint256 withdrawAmount,\r\n        bool shouldDestroy\r\n    ) external onlyOwner {\r\n        token.safeTransfer(recipient, withdrawAmount);\r\n        if (shouldDestroy) {\r\n            _destroy();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Destroys this contract. Only owner can call this function.\r\n     */\r\n    function destroy() external onlyOwner {\r\n        _destroy();\r\n    }\r\n\r\n    function _destroy() internal {\r\n        selfdestruct(msg.sender);\r\n    }\r\n}\r\n"
    },
    "synthetix/contracts/interfaces/ISynthetix.sol": {
      "content": "pragma solidity >=0.4.24;\n\nimport \"./ISynth.sol\";\nimport \"./IVirtualSynth.sol\";\n\n// https://docs.synthetix.io/contracts/source/interfaces/isynthetix\ninterface ISynthetix {\n    // Views\n    function anySynthOrSNXRateIsInvalid() external view returns (bool anyRateInvalid);\n\n    function availableCurrencyKeys() external view returns (bytes32[] memory);\n\n    function availableSynthCount() external view returns (uint);\n\n    function availableSynths(uint index) external view returns (ISynth);\n\n    function collateral(address account) external view returns (uint);\n\n    function collateralisationRatio(address issuer) external view returns (uint);\n\n    function debtBalanceOf(address issuer, bytes32 currencyKey) external view returns (uint);\n\n    function isWaitingPeriod(bytes32 currencyKey) external view returns (bool);\n\n    function maxIssuableSynths(address issuer) external view returns (uint maxIssuable);\n\n    function remainingIssuableSynths(address issuer)\n        external\n        view\n        returns (\n            uint maxIssuable,\n            uint alreadyIssued,\n            uint totalSystemDebt\n        );\n\n    function synths(bytes32 currencyKey) external view returns (ISynth);\n\n    function synthsByAddress(address synthAddress) external view returns (bytes32);\n\n    function totalIssuedSynths(bytes32 currencyKey) external view returns (uint);\n\n    function totalIssuedSynthsExcludeOtherCollateral(bytes32 currencyKey) external view returns (uint);\n\n    function transferableSynthetix(address account) external view returns (uint transferable);\n\n    // Mutative Functions\n    function burnSynths(uint amount) external;\n\n    function burnSynthsOnBehalf(address burnForAddress, uint amount) external;\n\n    function burnSynthsToTarget() external;\n\n    function burnSynthsToTargetOnBehalf(address burnForAddress) external;\n\n    function exchange(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey\n    ) external returns (uint amountReceived);\n\n    function exchangeOnBehalf(\n        address exchangeForAddress,\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey\n    ) external returns (uint amountReceived);\n\n    function exchangeWithTracking(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        address rewardAddress,\n        bytes32 trackingCode\n    ) external returns (uint amountReceived);\n\n    function exchangeWithTrackingForInitiator(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        address rewardAddress,\n        bytes32 trackingCode\n    ) external returns (uint amountReceived);\n\n    function exchangeOnBehalfWithTracking(\n        address exchangeForAddress,\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        address rewardAddress,\n        bytes32 trackingCode\n    ) external returns (uint amountReceived);\n\n    function exchangeWithVirtual(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        bytes32 trackingCode\n    ) external returns (uint amountReceived, IVirtualSynth vSynth);\n\n    function exchangeAtomically(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        bytes32 trackingCode\n    ) external returns (uint amountReceived);\n\n    function issueMaxSynths() external;\n\n    function issueMaxSynthsOnBehalf(address issueForAddress) external;\n\n    function issueSynths(uint amount) external;\n\n    function issueSynthsOnBehalf(address issueForAddress, uint amount) external;\n\n    function mint() external returns (bool);\n\n    function settle(bytes32 currencyKey)\n        external\n        returns (\n            uint reclaimed,\n            uint refunded,\n            uint numEntries\n        );\n\n    // Liquidations\n    function liquidateDelinquentAccount(address account, uint susdAmount) external returns (bool);\n\n    // Restricted Functions\n\n    function mintSecondary(address account, uint amount) external;\n\n    function mintSecondaryRewards(uint amount) external;\n\n    function burnSecondary(address account, uint amount) external;\n}\n"
    },
    "synthetix/contracts/interfaces/ISynth.sol": {
      "content": "pragma solidity >=0.4.24;\n\n// https://docs.synthetix.io/contracts/source/interfaces/isynth\ninterface ISynth {\n    // Views\n    function currencyKey() external view returns (bytes32);\n\n    function transferableSynths(address account) external view returns (uint);\n\n    // Mutative functions\n    function transferAndSettle(address to, uint value) external returns (bool);\n\n    function transferFromAndSettle(\n        address from,\n        address to,\n        uint value\n    ) external returns (bool);\n\n    // Restricted: used internally to Synthetix\n    function burn(address account, uint amount) external;\n\n    function issue(address account, uint amount) external;\n}\n"
    },
    "synthetix/contracts/interfaces/IVirtualSynth.sol": {
      "content": "pragma solidity >=0.4.24;\n\nimport \"./ISynth.sol\";\n\ninterface IVirtualSynth {\n    // Views\n    function balanceOfUnderlying(address account) external view returns (uint);\n\n    function rate() external view returns (uint);\n\n    function readyToSettle() external view returns (bool);\n\n    function secsLeftInWaitingPeriod() external view returns (uint);\n\n    function settled() external view returns (bool);\n\n    function synth() external view returns (ISynth);\n\n    // Mutative functions\n    function settle(address account) external;\n}\n"
    },
    "contracts/LPTokenV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20BurnableUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport \"./interfaces/ISwapV1.sol\";\r\n\r\n/**\r\n * @title Liquidity Provider Token\r\n * @notice This token is an ERC20 detailed token with added capability to be minted by the owner.\r\n * It is used to represent user's shares when providing liquidity to swap contracts.\r\n * @dev Only Swap contracts should initialize and own LPToken contracts.\r\n */\r\ncontract LPTokenV1 is ERC20BurnableUpgradeable, OwnableUpgradeable {\r\n    using SafeMathUpgradeable for uint256;\r\n\r\n    /**\r\n     * @notice Initializes this LPToken contract with the given name and symbol\r\n     * @dev The caller of this function will become the owner. A Swap contract should call this\r\n     * in its initializer function.\r\n     * @param name name of this token\r\n     * @param symbol symbol of this token\r\n     */\r\n    function initialize(string memory name, string memory symbol)\r\n        external\r\n        initializer\r\n        returns (bool)\r\n    {\r\n        __Context_init_unchained();\r\n        __ERC20_init_unchained(name, symbol);\r\n        __Ownable_init_unchained();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Mints the given amount of LPToken to the recipient.\r\n     * @dev only owner can call this mint function\r\n     * @param recipient address of account to receive the tokens\r\n     * @param amount amount of tokens to mint\r\n     */\r\n    function mint(address recipient, uint256 amount) external onlyOwner {\r\n        require(amount != 0, \"LPToken: cannot mint 0\");\r\n        _mint(recipient, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Overrides ERC20._beforeTokenTransfer() which get called on every transfers including\r\n     * minting and burning. This ensures that Swap.updateUserWithdrawFees are called everytime.\r\n     * This assumes the owner is set to a Swap contract's address.\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual override(ERC20Upgradeable) {\r\n        super._beforeTokenTransfer(from, to, amount);\r\n        require(to != address(this), \"LPToken: cannot send to itself\");\r\n        ISwapV1(owner()).updateUserWithdrawFee(to, amount);\r\n    }\r\n}\r\n"
    },
    "contracts/interfaces/ISwapV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"./IAllowlist.sol\";\r\n\r\ninterface ISwapV1 {\r\n    // pool data view functions\r\n    function getA() external view returns (uint256);\r\n\r\n    function getAllowlist() external view returns (IAllowlist);\r\n\r\n    function getToken(uint8 index) external view returns (IERC20);\r\n\r\n    function getTokenIndex(address tokenAddress) external view returns (uint8);\r\n\r\n    function getTokenBalance(uint8 index) external view returns (uint256);\r\n\r\n    function getVirtualPrice() external view returns (uint256);\r\n\r\n    function isGuarded() external view returns (bool);\r\n\r\n    // min return calculation functions\r\n    function calculateSwap(\r\n        uint8 tokenIndexFrom,\r\n        uint8 tokenIndexTo,\r\n        uint256 dx\r\n    ) external view returns (uint256);\r\n\r\n    function calculateTokenAmount(\r\n        address account,\r\n        uint256[] calldata amounts,\r\n        bool deposit\r\n    ) external view returns (uint256);\r\n\r\n    function calculateRemoveLiquidity(address account, uint256 amount)\r\n        external\r\n        view\r\n        returns (uint256[] memory);\r\n\r\n    function calculateRemoveLiquidityOneToken(\r\n        address account,\r\n        uint256 tokenAmount,\r\n        uint8 tokenIndex\r\n    ) external view returns (uint256 availableTokenAmount);\r\n\r\n    // state modifying functions\r\n    function initialize(\r\n        IERC20[] memory pooledTokens,\r\n        uint8[] memory decimals,\r\n        string memory lpTokenName,\r\n        string memory lpTokenSymbol,\r\n        uint256 a,\r\n        uint256 fee,\r\n        uint256 adminFee,\r\n        uint256 withdrawFee,\r\n        address lpTokenTargetAddress\r\n    ) external;\r\n\r\n    function swap(\r\n        uint8 tokenIndexFrom,\r\n        uint8 tokenIndexTo,\r\n        uint256 dx,\r\n        uint256 minDy,\r\n        uint256 deadline\r\n    ) external returns (uint256);\r\n\r\n    function addLiquidity(\r\n        uint256[] calldata amounts,\r\n        uint256 minToMint,\r\n        uint256 deadline\r\n    ) external returns (uint256);\r\n\r\n    function removeLiquidity(\r\n        uint256 amount,\r\n        uint256[] calldata minAmounts,\r\n        uint256 deadline\r\n    ) external returns (uint256[] memory);\r\n\r\n    function removeLiquidityOneToken(\r\n        uint256 tokenAmount,\r\n        uint8 tokenIndex,\r\n        uint256 minAmount,\r\n        uint256 deadline\r\n    ) external returns (uint256);\r\n\r\n    function removeLiquidityImbalance(\r\n        uint256[] calldata amounts,\r\n        uint256 maxBurnAmount,\r\n        uint256 deadline\r\n    ) external returns (uint256);\r\n\r\n    // withdraw fee update function\r\n    function updateUserWithdrawFee(address recipient, uint256 transferAmount)\r\n        external;\r\n}\r\n"
    },
    "contracts/SwapDeployerV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\r\nimport \"./interfaces/ISwapV1.sol\";\r\n\r\ncontract SwapDeployerV1 is Ownable {\r\n    event NewSwapPool(\r\n        address indexed deployer,\r\n        address swapAddress,\r\n        IERC20[] pooledTokens\r\n    );\r\n\r\n    constructor() public Ownable() {}\r\n\r\n    function deploy(\r\n        address swapAddress,\r\n        IERC20[] memory _pooledTokens,\r\n        uint8[] memory decimals,\r\n        string memory lpTokenName,\r\n        string memory lpTokenSymbol,\r\n        uint256 _a,\r\n        uint256 _fee,\r\n        uint256 _adminFee,\r\n        uint256 _withdrawFee,\r\n        address lpTokenTargetAddress\r\n    ) external returns (address) {\r\n        address swapClone = Clones.clone(swapAddress);\r\n        ISwapV1(swapClone).initialize(\r\n            _pooledTokens,\r\n            decimals,\r\n            lpTokenName,\r\n            lpTokenSymbol,\r\n            _a,\r\n            _fee,\r\n            _adminFee,\r\n            _withdrawFee,\r\n            lpTokenTargetAddress\r\n        );\r\n        Ownable(swapClone).transferOwnership(owner());\r\n        emit NewSwapPool(msg.sender, swapClone, _pooledTokens);\r\n        return swapClone;\r\n    }\r\n}\r\n"
    },
    "contracts/VirtualSwap/Bridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\r\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\r\nimport \"synthetix/contracts/interfaces/IAddressResolver.sol\";\r\nimport \"synthetix/contracts/interfaces/IExchanger.sol\";\r\nimport \"synthetix/contracts/interfaces/IExchangeRates.sol\";\r\nimport \"../interfaces/ISwap.sol\";\r\nimport \"./SynthSwapper.sol\";\r\n\r\ncontract Proxy {\r\n    address public target;\r\n}\r\n\r\ncontract Target {\r\n    address public proxy;\r\n}\r\n\r\n/**\r\n * @title Bridge\r\n * @notice This contract is responsible for cross-asset swaps using the Synthetix protocol as the bridging exchange.\r\n * There are three types of supported cross-asset swaps, tokenToSynth, synthToToken, and tokenToToken.\r\n *\r\n * 1) tokenToSynth\r\n * Swaps a supported token in a kinesis pool to any synthetic asset (e.g. tBTC -> sAAVE).\r\n *\r\n * 2) synthToToken\r\n * Swaps any synthetic asset to a suported token in a kinesis pool (e.g. sDEFI -> USDC).\r\n *\r\n * 3) tokenToToken\r\n * Swaps a supported token in a kinesis pool to one in another pool (e.g. renBTC -> DAI).\r\n *\r\n * Due to the settlement periods of synthetic assets, the users must wait until the trades can be completed.\r\n * Users will receive an ERC721 token that represents pending cross-asset swap. Once the waiting period is over,\r\n * the trades can be settled and completed by calling the `completeToSynth` or the `completeToToken` function.\r\n * In the cases of pending `synthToToken` or `tokenToToken` swaps, the owners of the pending swaps can also choose\r\n * to withdraw the bridging synthetic assets instead of completing the swap.\r\n */\r\ncontract Bridge is ERC721 {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    event SynthIndex(\r\n        address indexed swap,\r\n        uint8 synthIndex,\r\n        bytes32 currencyKey,\r\n        address synthAddress\r\n    );\r\n    event TokenToSynth(\r\n        address indexed requester,\r\n        uint256 indexed itemId,\r\n        ISwap swapPool,\r\n        uint8 tokenFromIndex,\r\n        uint256 tokenFromInAmount,\r\n        bytes32 synthToKey\r\n    );\r\n    event SynthToToken(\r\n        address indexed requester,\r\n        uint256 indexed itemId,\r\n        ISwap swapPool,\r\n        bytes32 synthFromKey,\r\n        uint256 synthFromInAmount,\r\n        uint8 tokenToIndex\r\n    );\r\n    event TokenToToken(\r\n        address indexed requester,\r\n        uint256 indexed itemId,\r\n        ISwap[2] swapPools,\r\n        uint8 tokenFromIndex,\r\n        uint256 tokenFromAmount,\r\n        uint8 tokenToIndex\r\n    );\r\n    event Settle(\r\n        address indexed requester,\r\n        uint256 indexed itemId,\r\n        IERC20 settleFrom,\r\n        uint256 settleFromAmount,\r\n        IERC20 settleTo,\r\n        uint256 settleToAmount,\r\n        bool isFinal\r\n    );\r\n    event Withdraw(\r\n        address indexed requester,\r\n        uint256 indexed itemId,\r\n        IERC20 synth,\r\n        uint256 synthAmount,\r\n        bool isFinal\r\n    );\r\n\r\n    // The addresses for all Synthetix contracts can be found in the below URL.\r\n    // https://docs.synthetix.io/addresses/#mainnet-contracts\r\n    //\r\n    // Since the Synthetix protocol is upgradable, we must use the proxy pairs of each contract such that\r\n    // the composability is not broken after the protocol upgrade.\r\n    //\r\n    // SYNTHETIX_RESOLVER points to `ReadProxyAddressResolver` (0x4E3b31eB0E5CB73641EE1E65E7dCEFe520bA3ef2).\r\n    // This contract is a read proxy of `AddressResolver` which is responsible for storing the addresses of the contracts\r\n    // used by the Synthetix protocol.\r\n    IAddressResolver public constant SYNTHETIX_RESOLVER =\r\n        IAddressResolver(0x4E3b31eB0E5CB73641EE1E65E7dCEFe520bA3ef2);\r\n\r\n    // EXCHANGER points to `Exchanger`. There is no proxy pair for this contract so we need to update this variable\r\n    // when the protocol is upgraded. This contract is used to settle synths held by SynthSwapper.\r\n    IExchanger public exchanger;\r\n\r\n    // CONSTANTS\r\n\r\n    // Available types of cross-asset swaps\r\n    enum PendingSwapType {\r\n        Null,\r\n        TokenToSynth,\r\n        SynthToToken,\r\n        TokenToToken\r\n    }\r\n\r\n    uint256 public constant MAX_UINT256 = 2**256 - 1;\r\n    uint8 public constant MAX_UINT8 = 2**8 - 1;\r\n    bytes32 public constant EXCHANGE_RATES_NAME = \"ExchangeRates\";\r\n    bytes32 public constant EXCHANGER_NAME = \"Exchanger\";\r\n    address public immutable SYNTH_SWAPPER_MASTER;\r\n\r\n    // MAPPINGS FOR STORING PENDING SETTLEMENTS\r\n    // The below two mappings never share the same key.\r\n    mapping(uint256 => PendingToSynthSwap) public pendingToSynthSwaps;\r\n    mapping(uint256 => PendingToTokenSwap) public pendingToTokenSwaps;\r\n    uint256 public pendingSwapsLength;\r\n    mapping(uint256 => PendingSwapType) private pendingSwapType;\r\n\r\n    // MAPPINGS FOR STORING SYNTH INFO\r\n    mapping(address => SwapContractInfo) private swapContracts;\r\n\r\n    // Structs holding information about pending settlements\r\n    struct PendingToSynthSwap {\r\n        SynthSwapper swapper;\r\n        bytes32 synthKey;\r\n    }\r\n\r\n    struct PendingToTokenSwap {\r\n        SynthSwapper swapper;\r\n        bytes32 synthKey;\r\n        ISwap swap;\r\n        uint8 tokenToIndex;\r\n    }\r\n\r\n    struct SwapContractInfo {\r\n        // index of the supported synth + 1\r\n        uint8 synthIndexPlusOne;\r\n        // address of the supported synth\r\n        address synthAddress;\r\n        // bytes32 key of the supported synth\r\n        bytes32 synthKey;\r\n        // array of tokens supported by the contract\r\n        IERC20[] tokens;\r\n    }\r\n\r\n    /**\r\n     * @notice Deploys this contract and initializes the master version of the SynthSwapper contract. The address to\r\n     * the Synthetix protocol's Exchanger contract is also set on deployment.\r\n     */\r\n    constructor(address synthSwapperAddress)\r\n        public\r\n        ERC721(\"kinesis Cross-Asset Swap\", \"kinesisSynthSwap\")\r\n    {\r\n        SYNTH_SWAPPER_MASTER = synthSwapperAddress;\r\n        updateExchangerCache();\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the address of the proxy contract targeting the synthetic asset with the given `synthKey`.\r\n     * @param synthKey the currency key of the synth\r\n     * @return address of the proxy contract\r\n     */\r\n    function getProxyAddressFromTargetSynthKey(bytes32 synthKey)\r\n        public\r\n        view\r\n        returns (IERC20)\r\n    {\r\n        return IERC20(Target(SYNTHETIX_RESOLVER.getSynth(synthKey)).proxy());\r\n    }\r\n\r\n    /**\r\n     * @notice Returns various information of a pending swap represented by the given `itemId`. Information includes\r\n     * the type of the pending swap, the number of seconds left until it can be settled, the address and the balance\r\n     * of the synth this swap currently holds, and the address of the destination token.\r\n     * @param itemId ID of the pending swap\r\n     * @return swapType the type of the pending virtual swap,\r\n     * secsLeft number of seconds left until this swap can be settled,\r\n     * synth address of the synth this swap uses,\r\n     * synthBalance amount of the synth this swap holds,\r\n     * tokenTo the address of the destination token\r\n     */\r\n    function getPendingSwapInfo(uint256 itemId)\r\n        external\r\n        view\r\n        returns (\r\n            PendingSwapType swapType,\r\n            uint256 secsLeft,\r\n            address synth,\r\n            uint256 synthBalance,\r\n            address tokenTo\r\n        )\r\n    {\r\n        swapType = pendingSwapType[itemId];\r\n        require(swapType != PendingSwapType.Null, \"invalid itemId\");\r\n\r\n        SynthSwapper synthSwapper;\r\n        bytes32 synthKey;\r\n\r\n        if (swapType == PendingSwapType.TokenToSynth) {\r\n            synthSwapper = pendingToSynthSwaps[itemId].swapper;\r\n            synthKey = pendingToSynthSwaps[itemId].synthKey;\r\n            synth = address(getProxyAddressFromTargetSynthKey(synthKey));\r\n            tokenTo = synth;\r\n        } else {\r\n            PendingToTokenSwap memory pendingToTokenSwap = pendingToTokenSwaps[\r\n                itemId\r\n            ];\r\n            synthSwapper = pendingToTokenSwap.swapper;\r\n            synthKey = pendingToTokenSwap.synthKey;\r\n            synth = address(getProxyAddressFromTargetSynthKey(synthKey));\r\n            tokenTo = address(\r\n                swapContracts[address(pendingToTokenSwap.swap)].tokens[\r\n                    pendingToTokenSwap.tokenToIndex\r\n                ]\r\n            );\r\n        }\r\n\r\n        secsLeft = exchanger.maxSecsLeftInWaitingPeriod(\r\n            address(synthSwapper),\r\n            synthKey\r\n        );\r\n        synthBalance = IERC20(synth).balanceOf(address(synthSwapper));\r\n    }\r\n\r\n    // Settles the synth only.\r\n    function _settle(address synthOwner, bytes32 synthKey) internal {\r\n        // Settle synth\r\n        exchanger.settle(synthOwner, synthKey);\r\n    }\r\n\r\n    /**\r\n     * @notice Settles and withdraws the synthetic asset without swapping it to a token in a kinesis pool. Only the owner\r\n     * of the ERC721 token of `itemId` can call this function. Reverts if the given `itemId` does not represent a\r\n     * `synthToToken` or a `tokenToToken` swap.\r\n     * @param itemId ID of the pending swap\r\n     * @param amount the amount of the synth to withdraw\r\n     */\r\n    function withdraw(uint256 itemId, uint256 amount) external {\r\n        address nftOwner = ownerOf(itemId);\r\n        require(nftOwner == msg.sender, \"not owner\");\r\n        require(\r\n            pendingSwapType[itemId] > PendingSwapType.TokenToSynth,\r\n            \"invalid itemId\"\r\n        );\r\n        PendingToTokenSwap memory pendingToTokenSwap = pendingToTokenSwaps[\r\n            itemId\r\n        ];\r\n        _settle(\r\n            address(pendingToTokenSwap.swapper),\r\n            pendingToTokenSwap.synthKey\r\n        );\r\n\r\n        IERC20 synth = getProxyAddressFromTargetSynthKey(\r\n            pendingToTokenSwap.synthKey\r\n        );\r\n        bool shouldDestroy;\r\n\r\n        if (amount >= synth.balanceOf(address(pendingToTokenSwap.swapper))) {\r\n            _burn(itemId);\r\n            delete pendingToTokenSwaps[itemId];\r\n            delete pendingSwapType[itemId];\r\n            shouldDestroy = true;\r\n        }\r\n\r\n        pendingToTokenSwap.swapper.withdraw(\r\n            synth,\r\n            nftOwner,\r\n            amount,\r\n            shouldDestroy\r\n        );\r\n        emit Withdraw(msg.sender, itemId, synth, amount, shouldDestroy);\r\n    }\r\n\r\n    /**\r\n     * @notice Completes the pending `tokenToSynth` swap by settling and withdrawing the synthetic asset.\r\n     * Reverts if the given `itemId` does not represent a `tokenToSynth` swap.\r\n     * @param itemId ERC721 token ID representing a pending `tokenToSynth` swap\r\n     */\r\n    function completeToSynth(uint256 itemId) external {\r\n        address nftOwner = ownerOf(itemId);\r\n        require(nftOwner == msg.sender, \"not owner\");\r\n        require(\r\n            pendingSwapType[itemId] == PendingSwapType.TokenToSynth,\r\n            \"invalid itemId\"\r\n        );\r\n\r\n        PendingToSynthSwap memory pendingToSynthSwap = pendingToSynthSwaps[\r\n            itemId\r\n        ];\r\n        _settle(\r\n            address(pendingToSynthSwap.swapper),\r\n            pendingToSynthSwap.synthKey\r\n        );\r\n\r\n        IERC20 synth = getProxyAddressFromTargetSynthKey(\r\n            pendingToSynthSwap.synthKey\r\n        );\r\n\r\n        // Burn the corresponding ERC721 token and delete storage for gas\r\n        _burn(itemId);\r\n        delete pendingToTokenSwaps[itemId];\r\n        delete pendingSwapType[itemId];\r\n\r\n        // After settlement, withdraw the synth and send it to the recipient\r\n        uint256 synthBalance = synth.balanceOf(\r\n            address(pendingToSynthSwap.swapper)\r\n        );\r\n        pendingToSynthSwap.swapper.withdraw(\r\n            synth,\r\n            nftOwner,\r\n            synthBalance,\r\n            true\r\n        );\r\n\r\n        emit Settle(\r\n            msg.sender,\r\n            itemId,\r\n            synth,\r\n            synthBalance,\r\n            synth,\r\n            synthBalance,\r\n            true\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates the expected amount of the token to receive on calling `completeToToken()` with\r\n     * the given `swapAmount`.\r\n     * @param itemId ERC721 token ID representing a pending `SynthToToken` or `TokenToToken` swap\r\n     * @param swapAmount the amount of bridging synth to swap from\r\n     * @return expected amount of the token the user will receive\r\n     */\r\n    function calcCompleteToToken(uint256 itemId, uint256 swapAmount)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        require(\r\n            pendingSwapType[itemId] > PendingSwapType.TokenToSynth,\r\n            \"invalid itemId\"\r\n        );\r\n\r\n        PendingToTokenSwap memory pendingToTokenSwap = pendingToTokenSwaps[\r\n            itemId\r\n        ];\r\n        return\r\n            pendingToTokenSwap.swap.calculateSwap(\r\n                getSynthIndex(pendingToTokenSwap.swap),\r\n                pendingToTokenSwap.tokenToIndex,\r\n                swapAmount\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @notice Completes the pending `SynthToToken` or `TokenToToken` swap by settling the bridging synth and swapping\r\n     * it to the desired token. Only the owners of the pending swaps can call this function.\r\n     * @param itemId ERC721 token ID representing a pending `SynthToToken` or `TokenToToken` swap\r\n     * @param swapAmount the amount of bridging synth to swap from\r\n     * @param minAmount the minimum amount of the token to receive - reverts if this amount is not reached\r\n     * @param deadline the timestamp representing the deadline for this transaction - reverts if deadline is not met\r\n     */\r\n    function completeToToken(\r\n        uint256 itemId,\r\n        uint256 swapAmount,\r\n        uint256 minAmount,\r\n        uint256 deadline\r\n    ) external {\r\n        require(swapAmount != 0, \"amount must be greater than 0\");\r\n        address nftOwner = ownerOf(itemId);\r\n        require(msg.sender == nftOwner, \"must own itemId\");\r\n        require(\r\n            pendingSwapType[itemId] > PendingSwapType.TokenToSynth,\r\n            \"invalid itemId\"\r\n        );\r\n\r\n        PendingToTokenSwap memory pendingToTokenSwap = pendingToTokenSwaps[\r\n            itemId\r\n        ];\r\n\r\n        _settle(\r\n            address(pendingToTokenSwap.swapper),\r\n            pendingToTokenSwap.synthKey\r\n        );\r\n        IERC20 synth = getProxyAddressFromTargetSynthKey(\r\n            pendingToTokenSwap.synthKey\r\n        );\r\n        bool shouldDestroyClone;\r\n\r\n        if (\r\n            swapAmount >= synth.balanceOf(address(pendingToTokenSwap.swapper))\r\n        ) {\r\n            _burn(itemId);\r\n            delete pendingToTokenSwaps[itemId];\r\n            delete pendingSwapType[itemId];\r\n            shouldDestroyClone = true;\r\n        }\r\n\r\n        // Try swapping the synth to the desired token via the stored swap pool contract\r\n        // If the external call succeeds, send the token to the owner of token with itemId.\r\n        (IERC20 tokenTo, uint256 amountOut) = pendingToTokenSwap\r\n            .swapper\r\n            .swapSynthToToken(\r\n                pendingToTokenSwap.swap,\r\n                synth,\r\n                getSynthIndex(pendingToTokenSwap.swap),\r\n                pendingToTokenSwap.tokenToIndex,\r\n                swapAmount,\r\n                minAmount,\r\n                deadline,\r\n                nftOwner\r\n            );\r\n\r\n        if (shouldDestroyClone) {\r\n            pendingToTokenSwap.swapper.destroy();\r\n        }\r\n\r\n        emit Settle(\r\n            msg.sender,\r\n            itemId,\r\n            synth,\r\n            swapAmount,\r\n            tokenTo,\r\n            amountOut,\r\n            shouldDestroyClone\r\n        );\r\n    }\r\n\r\n    // Add the given pending synth settlement struct to the list\r\n    function _addToPendingSynthSwapList(\r\n        PendingToSynthSwap memory pendingToSynthSwap\r\n    ) internal returns (uint256) {\r\n        require(\r\n            pendingSwapsLength < MAX_UINT256,\r\n            \"pendingSwapsLength reached max size\"\r\n        );\r\n        pendingToSynthSwaps[pendingSwapsLength] = pendingToSynthSwap;\r\n        return pendingSwapsLength++;\r\n    }\r\n\r\n    // Add the given pending synth to token settlement struct to the list\r\n    function _addToPendingSynthToTokenSwapList(\r\n        PendingToTokenSwap memory pendingToTokenSwap\r\n    ) internal returns (uint256) {\r\n        require(\r\n            pendingSwapsLength < MAX_UINT256,\r\n            \"pendingSwapsLength reached max size\"\r\n        );\r\n        pendingToTokenSwaps[pendingSwapsLength] = pendingToTokenSwap;\r\n        return pendingSwapsLength++;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates the expected amount of the desired synthetic asset the caller will receive after completing\r\n     * a `TokenToSynth` swap with the given parameters. This calculation does not consider the settlement periods.\r\n     * @param swap the address of a kinesis pool to use to swap the given token to a bridging synth\r\n     * @param tokenFromIndex the index of the token to swap from\r\n     * @param synthOutKey the currency key of the desired synthetic asset\r\n     * @param tokenInAmount the amount of the token to swap form\r\n     * @return the expected amount of the desired synth\r\n     */\r\n    function calcTokenToSynth(\r\n        ISwap swap,\r\n        uint8 tokenFromIndex,\r\n        bytes32 synthOutKey,\r\n        uint256 tokenInAmount\r\n    ) external view returns (uint256) {\r\n        uint8 mediumSynthIndex = getSynthIndex(swap);\r\n        uint256 expectedMediumSynthAmount = swap.calculateSwap(\r\n            tokenFromIndex,\r\n            mediumSynthIndex,\r\n            tokenInAmount\r\n        );\r\n        bytes32 mediumSynthKey = getSynthKey(swap);\r\n\r\n        IExchangeRates exchangeRates = IExchangeRates(\r\n            SYNTHETIX_RESOLVER.getAddress(EXCHANGE_RATES_NAME)\r\n        );\r\n        return\r\n            exchangeRates.effectiveValue(\r\n                mediumSynthKey,\r\n                expectedMediumSynthAmount,\r\n                synthOutKey\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @notice Initiates a cross-asset swap from a token supported in the `swap` pool to any synthetic asset.\r\n     * The caller will receive an ERC721 token representing their ownership of the pending cross-asset swap.\r\n     * @param swap the address of a kinesis pool to use to swap the given token to a bridging synth\r\n     * @param tokenFromIndex the index of the token to swap from\r\n     * @param synthOutKey the currency key of the desired synthetic asset\r\n     * @param tokenInAmount the amount of the token to swap form\r\n     * @param minAmount the amount of the token to swap form\r\n     * @return ID of the ERC721 token sent to the caller\r\n     */\r\n    function tokenToSynth(\r\n        ISwap swap,\r\n        uint8 tokenFromIndex,\r\n        bytes32 synthOutKey,\r\n        uint256 tokenInAmount,\r\n        uint256 minAmount\r\n    ) external returns (uint256) {\r\n        require(tokenInAmount != 0, \"amount must be greater than 0\");\r\n        // Create a SynthSwapper clone\r\n        SynthSwapper synthSwapper = SynthSwapper(\r\n            Clones.clone(SYNTH_SWAPPER_MASTER)\r\n        );\r\n        synthSwapper.initialize();\r\n\r\n        // Add the synthswapper to the pending settlement list\r\n        uint256 itemId = _addToPendingSynthSwapList(\r\n            PendingToSynthSwap(synthSwapper, synthOutKey)\r\n        );\r\n        pendingSwapType[itemId] = PendingSwapType.TokenToSynth;\r\n\r\n        // Mint an ERC721 token that represents ownership of the pending synth settlement to msg.sender\r\n        _mint(msg.sender, itemId);\r\n\r\n        // Transfer token from msg.sender\r\n        IERC20 tokenFrom = swapContracts[address(swap)].tokens[tokenFromIndex]; // revert when token not found in swap pool\r\n        tokenFrom.safeTransferFrom(msg.sender, address(this), tokenInAmount);\r\n        tokenInAmount = tokenFrom.balanceOf(address(this));\r\n\r\n        // Swap the synth to the medium synth\r\n        uint256 mediumSynthAmount = swap.swap(\r\n            tokenFromIndex,\r\n            getSynthIndex(swap),\r\n            tokenInAmount,\r\n            0,\r\n            block.timestamp\r\n        );\r\n\r\n        // Swap synths via Synthetix network\r\n        IERC20(getSynthAddress(swap)).safeTransfer(\r\n            address(synthSwapper),\r\n            mediumSynthAmount\r\n        );\r\n        require(\r\n            synthSwapper.swapSynth(\r\n                getSynthKey(swap),\r\n                mediumSynthAmount,\r\n                synthOutKey\r\n            ) >= minAmount,\r\n            \"minAmount not reached\"\r\n        );\r\n\r\n        // Emit TokenToSynth event with relevant data\r\n        emit TokenToSynth(\r\n            msg.sender,\r\n            itemId,\r\n            swap,\r\n            tokenFromIndex,\r\n            tokenInAmount,\r\n            synthOutKey\r\n        );\r\n\r\n        return (itemId);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates the expected amount of the desired token the caller will receive after completing\r\n     * a `SynthToToken` swap with the given parameters. This calculation does not consider the settlement periods or\r\n     * any potential changes of the `swap` pool composition.\r\n     * @param swap the address of a kinesis pool to use to swap the given token to a bridging synth\r\n     * @param synthInKey the currency key of the synth to swap from\r\n     * @param tokenToIndex the index of the token to swap to\r\n     * @param synthInAmount the amount of the synth to swap form\r\n     * @return the expected amount of the bridging synth and the expected amount of the desired token\r\n     */\r\n    function calcSynthToToken(\r\n        ISwap swap,\r\n        bytes32 synthInKey,\r\n        uint8 tokenToIndex,\r\n        uint256 synthInAmount\r\n    ) external view returns (uint256, uint256) {\r\n        IExchangeRates exchangeRates = IExchangeRates(\r\n            SYNTHETIX_RESOLVER.getAddress(EXCHANGE_RATES_NAME)\r\n        );\r\n\r\n        uint8 mediumSynthIndex = getSynthIndex(swap);\r\n        bytes32 mediumSynthKey = getSynthKey(swap);\r\n        require(synthInKey != mediumSynthKey, \"use normal swap\");\r\n\r\n        uint256 expectedMediumSynthAmount = exchangeRates.effectiveValue(\r\n            synthInKey,\r\n            synthInAmount,\r\n            mediumSynthKey\r\n        );\r\n\r\n        return (\r\n            expectedMediumSynthAmount,\r\n            swap.calculateSwap(\r\n                mediumSynthIndex,\r\n                tokenToIndex,\r\n                expectedMediumSynthAmount\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Initiates a cross-asset swap from a synthetic asset to a supported token. The caller will receive\r\n     * an ERC721 token representing their ownership of the pending cross-asset swap.\r\n     * @param swap the address of a kinesis pool to use to swap the given token to a bridging synth\r\n     * @param synthInKey the currency key of the synth to swap from\r\n     * @param tokenToIndex the index of the token to swap to\r\n     * @param synthInAmount the amount of the synth to swap form\r\n     * @param minMediumSynthAmount the minimum amount of the bridging synth at pre-settlement stage\r\n     * @return the ID of the ERC721 token sent to the caller\r\n     */\r\n    function synthToToken(\r\n        ISwap swap,\r\n        bytes32 synthInKey,\r\n        uint8 tokenToIndex,\r\n        uint256 synthInAmount,\r\n        uint256 minMediumSynthAmount\r\n    ) external returns (uint256) {\r\n        require(synthInAmount != 0, \"amount must be greater than 0\");\r\n        bytes32 mediumSynthKey = getSynthKey(swap);\r\n        require(\r\n            synthInKey != mediumSynthKey,\r\n            \"synth is supported via normal swap\"\r\n        );\r\n\r\n        // Create a SynthSwapper clone\r\n        SynthSwapper synthSwapper = SynthSwapper(\r\n            Clones.clone(SYNTH_SWAPPER_MASTER)\r\n        );\r\n        synthSwapper.initialize();\r\n\r\n        // Add the synthswapper to the pending synth to token settlement list\r\n        uint256 itemId = _addToPendingSynthToTokenSwapList(\r\n            PendingToTokenSwap(synthSwapper, mediumSynthKey, swap, tokenToIndex)\r\n        );\r\n        pendingSwapType[itemId] = PendingSwapType.SynthToToken;\r\n\r\n        // Mint an ERC721 token that represents ownership of the pending synth to token settlement to msg.sender\r\n        _mint(msg.sender, itemId);\r\n\r\n        // Receive synth from the user and swap it to another synth\r\n        IERC20 synthFrom = getProxyAddressFromTargetSynthKey(synthInKey);\r\n        synthFrom.safeTransferFrom(msg.sender, address(this), synthInAmount);\r\n        synthFrom.safeTransfer(address(synthSwapper), synthInAmount);\r\n        require(\r\n            synthSwapper.swapSynth(synthInKey, synthInAmount, mediumSynthKey) >=\r\n                minMediumSynthAmount,\r\n            \"minMediumSynthAmount not reached\"\r\n        );\r\n\r\n        // Emit SynthToToken event with relevant data\r\n        emit SynthToToken(\r\n            msg.sender,\r\n            itemId,\r\n            swap,\r\n            synthInKey,\r\n            synthInAmount,\r\n            tokenToIndex\r\n        );\r\n\r\n        return (itemId);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates the expected amount of the desired token the caller will receive after completing\r\n     * a `TokenToToken` swap with the given parameters. This calculation does not consider the settlement periods or\r\n     * any potential changes of the pool compositions.\r\n     * @param swaps the addresses of the two kinesis pools used to do the cross-asset swap\r\n     * @param tokenFromIndex the index of the token in the first `swaps` pool to swap from\r\n     * @param tokenToIndex the index of the token in the second `swaps` pool to swap to\r\n     * @param tokenFromAmount the amount of the token to swap from\r\n     * @return the expected amount of bridging synth at pre-settlement stage and the expected amount of the desired\r\n     * token\r\n     */\r\n    function calcTokenToToken(\r\n        ISwap[2] calldata swaps,\r\n        uint8 tokenFromIndex,\r\n        uint8 tokenToIndex,\r\n        uint256 tokenFromAmount\r\n    ) external view returns (uint256, uint256) {\r\n        IExchangeRates exchangeRates = IExchangeRates(\r\n            SYNTHETIX_RESOLVER.getAddress(EXCHANGE_RATES_NAME)\r\n        );\r\n\r\n        uint256 firstSynthAmount = swaps[0].calculateSwap(\r\n            tokenFromIndex,\r\n            getSynthIndex(swaps[0]),\r\n            tokenFromAmount\r\n        );\r\n\r\n        uint256 mediumSynthAmount = exchangeRates.effectiveValue(\r\n            getSynthKey(swaps[0]),\r\n            firstSynthAmount,\r\n            getSynthKey(swaps[1])\r\n        );\r\n\r\n        return (\r\n            mediumSynthAmount,\r\n            swaps[1].calculateSwap(\r\n                getSynthIndex(swaps[1]),\r\n                tokenToIndex,\r\n                mediumSynthAmount\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Initiates a cross-asset swap from a token in one kinesis pool to one in another. The caller will receive\r\n     * an ERC721 token representing their ownership of the pending cross-asset swap.\r\n     * @param swaps the addresses of the two kinesis pools used to do the cross-asset swap\r\n     * @param tokenFromIndex the index of the token in the first `swaps` pool to swap from\r\n     * @param tokenToIndex the index of the token in the second `swaps` pool to swap to\r\n     * @param tokenFromAmount the amount of the token to swap from\r\n     * @param minMediumSynthAmount the minimum amount of the bridging synth at pre-settlement stage\r\n     * @return the ID of the ERC721 token sent to the caller\r\n     */\r\n    function tokenToToken(\r\n        ISwap[2] calldata swaps,\r\n        uint8 tokenFromIndex,\r\n        uint8 tokenToIndex,\r\n        uint256 tokenFromAmount,\r\n        uint256 minMediumSynthAmount\r\n    ) external returns (uint256) {\r\n        // Create a SynthSwapper clone\r\n        require(tokenFromAmount != 0, \"amount must be greater than 0\");\r\n        SynthSwapper synthSwapper = SynthSwapper(\r\n            Clones.clone(SYNTH_SWAPPER_MASTER)\r\n        );\r\n        synthSwapper.initialize();\r\n        bytes32 mediumSynthKey = getSynthKey(swaps[1]);\r\n\r\n        // Add the synthswapper to the pending synth to token settlement list\r\n        uint256 itemId = _addToPendingSynthToTokenSwapList(\r\n            PendingToTokenSwap(\r\n                synthSwapper,\r\n                mediumSynthKey,\r\n                swaps[1],\r\n                tokenToIndex\r\n            )\r\n        );\r\n        pendingSwapType[itemId] = PendingSwapType.TokenToToken;\r\n\r\n        // Mint an ERC721 token that represents ownership of the pending swap to msg.sender\r\n        _mint(msg.sender, itemId);\r\n\r\n        // Receive token from the user\r\n        ISwap swap = swaps[0];\r\n        {\r\n            IERC20 tokenFrom = swapContracts[address(swap)].tokens[\r\n                tokenFromIndex\r\n            ];\r\n            tokenFrom.safeTransferFrom(\r\n                msg.sender,\r\n                address(this),\r\n                tokenFromAmount\r\n            );\r\n        }\r\n\r\n        uint256 firstSynthAmount = swap.swap(\r\n            tokenFromIndex,\r\n            getSynthIndex(swap),\r\n            tokenFromAmount,\r\n            0,\r\n            block.timestamp\r\n        );\r\n\r\n        // Swap the synth to another synth\r\n        IERC20(getSynthAddress(swap)).safeTransfer(\r\n            address(synthSwapper),\r\n            firstSynthAmount\r\n        );\r\n        require(\r\n            synthSwapper.swapSynth(\r\n                getSynthKey(swap),\r\n                firstSynthAmount,\r\n                mediumSynthKey\r\n            ) >= minMediumSynthAmount,\r\n            \"minMediumSynthAmount not reached\"\r\n        );\r\n\r\n        // Emit TokenToToken event with relevant data\r\n        emit TokenToToken(\r\n            msg.sender,\r\n            itemId,\r\n            swaps,\r\n            tokenFromIndex,\r\n            tokenFromAmount,\r\n            tokenToIndex\r\n        );\r\n\r\n        return (itemId);\r\n    }\r\n\r\n    /**\r\n     * @notice Registers the index and the address of the supported synth from the given `swap` pool. The matching currency key must\r\n     * be supplied for a successful registration.\r\n     * @param swap the address of the pool that contains the synth\r\n     * @param synthIndex the index of the supported synth in the given `swap` pool\r\n     * @param currencyKey the currency key of the synth in bytes32 form\r\n     */\r\n    function setSynthIndex(\r\n        ISwap swap,\r\n        uint8 synthIndex,\r\n        bytes32 currencyKey\r\n    ) external {\r\n        require(synthIndex < MAX_UINT8, \"index is too large\");\r\n        SwapContractInfo storage swapContractInfo = swapContracts[\r\n            address(swap)\r\n        ];\r\n        // Check if the pool has already been added\r\n        require(swapContractInfo.synthIndexPlusOne == 0, \"Pool already added\");\r\n        // Ensure the synth with the same currency key exists at the given `synthIndex`\r\n        IERC20 synth = swap.getToken(synthIndex);\r\n        require(\r\n            ISynth(Proxy(address(synth)).target()).currencyKey() == currencyKey,\r\n            \"currencyKey does not match\"\r\n        );\r\n        swapContractInfo.synthIndexPlusOne = synthIndex + 1;\r\n        swapContractInfo.synthAddress = address(synth);\r\n        swapContractInfo.synthKey = currencyKey;\r\n        swapContractInfo.tokens = new IERC20[](0);\r\n\r\n        for (uint8 i = 0; i < MAX_UINT8; i++) {\r\n            IERC20 token;\r\n            if (i == synthIndex) {\r\n                token = synth;\r\n            } else {\r\n                try swap.getToken(i) returns (IERC20 token_) {\r\n                    token = token_;\r\n                } catch {\r\n                    break;\r\n                }\r\n            }\r\n            swapContractInfo.tokens.push(token);\r\n            token.safeApprove(address(swap), MAX_UINT256);\r\n        }\r\n\r\n        emit SynthIndex(address(swap), synthIndex, currencyKey, address(synth));\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the index of the supported synth in the given `swap` pool. Reverts if the `swap` pool\r\n     * is not registered.\r\n     * @param swap the address of the pool that contains the synth\r\n     * @return the index of the supported synth\r\n     */\r\n    function getSynthIndex(ISwap swap) public view returns (uint8) {\r\n        uint8 synthIndexPlusOne = swapContracts[address(swap)]\r\n            .synthIndexPlusOne;\r\n        require(synthIndexPlusOne > 0, \"synth index not found for given pool\");\r\n        return synthIndexPlusOne - 1;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the address of the supported synth in the given `swap` pool. Reverts if the `swap` pool\r\n     * is not registered.\r\n     * @param swap the address of the pool that contains the synth\r\n     * @return the address of the supported synth\r\n     */\r\n    function getSynthAddress(ISwap swap) public view returns (address) {\r\n        address synthAddress = swapContracts[address(swap)].synthAddress;\r\n        require(\r\n            synthAddress != address(0),\r\n            \"synth addr not found for given pool\"\r\n        );\r\n        return synthAddress;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the currency key of the supported synth in the given `swap` pool. Reverts if the `swap` pool\r\n     * is not registered.\r\n     * @param swap the address of the pool that contains the synth\r\n     * @return the currency key of the supported synth\r\n     */\r\n    function getSynthKey(ISwap swap) public view returns (bytes32) {\r\n        bytes32 synthKey = swapContracts[address(swap)].synthKey;\r\n        require(synthKey != 0x0, \"synth key not found for given pool\");\r\n        return synthKey;\r\n    }\r\n\r\n    /**\r\n     * @notice Updates the stored address of the `EXCHANGER` contract. When the Synthetix team upgrades their protocol,\r\n     * a new Exchanger contract is deployed. This function manually updates the stored address.\r\n     */\r\n    function updateExchangerCache() public {\r\n        exchanger = IExchanger(SYNTHETIX_RESOLVER.getAddress(EXCHANGER_NAME));\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/Context.sol\";\nimport \"./IERC721.sol\";\nimport \"./IERC721Metadata.sol\";\nimport \"./IERC721Enumerable.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"../../introspection/ERC165.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/EnumerableSet.sol\";\nimport \"../../utils/EnumerableMap.sol\";\nimport \"../../utils/Strings.sol\";\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic implementation\n * @dev see https://eips.ethereum.org/EIPS/eip-721\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata, IERC721Enumerable {\n    using SafeMath for uint256;\n    using Address for address;\n    using EnumerableSet for EnumerableSet.UintSet;\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n    using Strings for uint256;\n\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n\n    // Mapping from holder address to their (enumerable) set of owned tokens\n    mapping (address => EnumerableSet.UintSet) private _holderTokens;\n\n    // Enumerable mapping from token ids to their owners\n    EnumerableMap.UintToAddressMap private _tokenOwners;\n\n    // Mapping from token ID to approved address\n    mapping (uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Optional mapping for token URIs\n    mapping (uint256 => string) private _tokenURIs;\n\n    // Base URI\n    string private _baseURI;\n\n    /*\n     *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231\n     *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e\n     *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3\n     *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde\n     *\n     *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\n     *        0xa22cb465 ^ 0xe985e9c5 ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n\n    /*\n     *     bytes4(keccak256('name()')) == 0x06fdde03\n     *     bytes4(keccak256('symbol()')) == 0x95d89b41\n     *     bytes4(keccak256('tokenURI(uint256)')) == 0xc87b56dd\n     *\n     *     => 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\n\n    /*\n     *     bytes4(keccak256('totalSupply()')) == 0x18160ddd\n     *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) == 0x2f745c59\n     *     bytes4(keccak256('tokenByIndex(uint256)')) == 0x4f6ccce7\n     *\n     *     => 0x18160ddd ^ 0x2f745c59 ^ 0x4f6ccce7 == 0x780e9d63\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor (string memory name_, string memory symbol_) public {\n        _name = name_;\n        _symbol = symbol_;\n\n        // register the supported interfaces to conform to ERC721 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721);\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\n        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _holderTokens[owner].length();\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        return _tokenOwners.get(tokenId, \"ERC721: owner query for nonexistent token\");\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory _tokenURI = _tokenURIs[tokenId];\n        string memory base = baseURI();\n\n        // If there is no base URI, return the token URI.\n        if (bytes(base).length == 0) {\n            return _tokenURI;\n        }\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\n        if (bytes(_tokenURI).length > 0) {\n            return string(abi.encodePacked(base, _tokenURI));\n        }\n        // If there is a baseURI but no tokenURI, concatenate the tokenID to the baseURI.\n        return string(abi.encodePacked(base, tokenId.toString()));\n    }\n\n    /**\n    * @dev Returns the base URI set via {_setBaseURI}. This will be\n    * automatically added as a prefix in {tokenURI} to each token's URI, or\n    * to the token ID if no specific URI is set for that token ID.\n    */\n    function baseURI() public view virtual returns (string memory) {\n        return _baseURI;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        return _holderTokens[owner].at(index);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        // _tokenOwners are indexed by tokenIds, so .length() returns the number of tokenIds\n        return _tokenOwners.length();\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        (uint256 tokenId, ) = _tokenOwners.at(index);\n        return tokenId;\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(_msgSender() == owner || ERC721.isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(operator != _msgSender(), \"ERC721: approve to caller\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _tokenOwners.contains(tokenId);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || ERC721.isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     d*\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {\n        _mint(to, tokenId);\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _holderTokens[to].add(tokenId);\n\n        _tokenOwners.set(tokenId, to);\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId); // internal owner\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        // Clear metadata (if any)\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n\n        _holderTokens[owner].remove(tokenId);\n\n        _tokenOwners.remove(tokenId);\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\"); // internal owner\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _holderTokens[from].remove(tokenId);\n        _holderTokens[to].add(tokenId);\n\n        _tokenOwners.set(tokenId, to);\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n        require(_exists(tokenId), \"ERC721Metadata: URI set of nonexistent token\");\n        _tokenURIs[tokenId] = _tokenURI;\n    }\n\n    /**\n     * @dev Internal function to set the base URI for all token IDs. It is\n     * automatically added as a prefix to the value returned in {tokenURI},\n     * or to the token ID if {tokenURI} is empty.\n     */\n    function _setBaseURI(string memory baseURI_) internal virtual {\n        _baseURI = baseURI_;\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n        private returns (bool)\n    {\n        if (!to.isContract()) {\n            return true;\n        }\n        bytes memory returndata = to.functionCall(abi.encodeWithSelector(\n            IERC721Receiver(to).onERC721Received.selector,\n            _msgSender(),\n            from,\n            tokenId,\n            _data\n        ), \"ERC721: transfer to non ERC721Receiver implementer\");\n        bytes4 retval = abi.decode(returndata, (bytes4));\n        return (retval == _ERC721_RECEIVED);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId); // internal owner\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual { }\n}\n"
    },
    "synthetix/contracts/interfaces/IAddressResolver.sol": {
      "content": "pragma solidity >=0.4.24;\n\n// https://docs.synthetix.io/contracts/source/interfaces/iaddressresolver\ninterface IAddressResolver {\n    function getAddress(bytes32 name) external view returns (address);\n\n    function getSynth(bytes32 key) external view returns (address);\n\n    function requireAndGetAddress(bytes32 name, string calldata reason) external view returns (address);\n}\n"
    },
    "synthetix/contracts/interfaces/IExchanger.sol": {
      "content": "pragma solidity >=0.4.24;\n\nimport \"./IVirtualSynth.sol\";\n\n// https://docs.synthetix.io/contracts/source/interfaces/iexchanger\ninterface IExchanger {\n    // Views\n    function calculateAmountAfterSettlement(\n        address from,\n        bytes32 currencyKey,\n        uint amount,\n        uint refunded\n    ) external view returns (uint amountAfterSettlement);\n\n    function isSynthRateInvalid(bytes32 currencyKey) external view returns (bool);\n\n    function maxSecsLeftInWaitingPeriod(address account, bytes32 currencyKey) external view returns (uint);\n\n    function settlementOwing(address account, bytes32 currencyKey)\n        external\n        view\n        returns (\n            uint reclaimAmount,\n            uint rebateAmount,\n            uint numEntries\n        );\n\n    function hasWaitingPeriodOrSettlementOwing(address account, bytes32 currencyKey) external view returns (bool);\n\n    function feeRateForExchange(bytes32 sourceCurrencyKey, bytes32 destinationCurrencyKey)\n        external\n        view\n        returns (uint exchangeFeeRate);\n\n    function getAmountsForExchange(\n        uint sourceAmount,\n        bytes32 sourceCurrencyKey,\n        bytes32 destinationCurrencyKey\n    )\n        external\n        view\n        returns (\n            uint amountReceived,\n            uint fee,\n            uint exchangeFeeRate\n        );\n\n    function priceDeviationThresholdFactor() external view returns (uint);\n\n    function waitingPeriodSecs() external view returns (uint);\n\n    // Mutative functions\n    function exchange(\n        address exchangeForAddress,\n        address from,\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        address destinationAddress,\n        bool virtualSynth,\n        address rewardAddress,\n        bytes32 trackingCode\n    ) external returns (uint amountReceived, IVirtualSynth vSynth);\n\n    function exchangeAtomically(\n        address from,\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        address destinationAddress,\n        bytes32 trackingCode\n    ) external returns (uint amountReceived);\n\n    function settle(address from, bytes32 currencyKey)\n        external\n        returns (\n            uint reclaimed,\n            uint refunded,\n            uint numEntries\n        );\n\n    function resetLastExchangeRate(bytes32[] calldata currencyKeys) external;\n\n    function suspendSynthWithInvalidRate(bytes32 currencyKey) external;\n}\n"
    },
    "synthetix/contracts/interfaces/IExchangeRates.sol": {
      "content": "pragma solidity >=0.4.24;\n\n// https://docs.synthetix.io/contracts/source/interfaces/iexchangerates\ninterface IExchangeRates {\n    // Structs\n    struct RateAndUpdatedTime {\n        uint216 rate;\n        uint40 time;\n    }\n\n    // Views\n    function aggregators(bytes32 currencyKey) external view returns (address);\n\n    function aggregatorWarningFlags() external view returns (address);\n\n    function anyRateIsInvalid(bytes32[] calldata currencyKeys) external view returns (bool);\n\n    function currentRoundForRate(bytes32 currencyKey) external view returns (uint);\n\n    function currenciesUsingAggregator(address aggregator) external view returns (bytes32[] memory);\n\n    function effectiveValue(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey\n    ) external view returns (uint value);\n\n    function effectiveValueAndRates(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey\n    )\n        external\n        view\n        returns (\n            uint value,\n            uint sourceRate,\n            uint destinationRate\n        );\n\n    function effectiveAtomicValueAndRates(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey\n    )\n        external\n        view\n        returns (\n            uint value,\n            uint systemValue,\n            uint systemSourceRate,\n            uint systemDestinationRate\n        );\n\n    function effectiveValueAtRound(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        uint roundIdForSrc,\n        uint roundIdForDest\n    ) external view returns (uint value);\n\n    function getCurrentRoundId(bytes32 currencyKey) external view returns (uint);\n\n    function getLastRoundIdBeforeElapsedSecs(\n        bytes32 currencyKey,\n        uint startingRoundId,\n        uint startingTimestamp,\n        uint timediff\n    ) external view returns (uint);\n\n    function lastRateUpdateTimes(bytes32 currencyKey) external view returns (uint256);\n\n    function oracle() external view returns (address);\n\n    function rateAndTimestampAtRound(bytes32 currencyKey, uint roundId) external view returns (uint rate, uint time);\n\n    function rateAndUpdatedTime(bytes32 currencyKey) external view returns (uint rate, uint time);\n\n    function rateAndInvalid(bytes32 currencyKey) external view returns (uint rate, bool isInvalid);\n\n    function rateForCurrency(bytes32 currencyKey) external view returns (uint);\n\n    function rateIsFlagged(bytes32 currencyKey) external view returns (bool);\n\n    function rateIsInvalid(bytes32 currencyKey) external view returns (bool);\n\n    function rateIsStale(bytes32 currencyKey) external view returns (bool);\n\n    function rateStalePeriod() external view returns (uint);\n\n    function ratesAndUpdatedTimeForCurrencyLastNRounds(bytes32 currencyKey, uint numRounds)\n        external\n        view\n        returns (uint[] memory rates, uint[] memory times);\n\n    function ratesAndInvalidForCurrencies(bytes32[] calldata currencyKeys)\n        external\n        view\n        returns (uint[] memory rates, bool anyRateInvalid);\n\n    function ratesForCurrencies(bytes32[] calldata currencyKeys) external view returns (uint[] memory);\n\n    function synthTooVolatileForAtomicExchange(bytes32 currencyKey) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\nimport \"../../introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\n      *\n      * Requirements:\n      *\n      * - `from` cannot be the zero address.\n      * - `to` cannot be the zero address.\n      * - `tokenId` token must exist and be owned by `from`.\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n      *\n      * Emits a {Transfer} event.\n      */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\nimport \"./IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\nimport \"./IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts may inherit from this and call {_registerInterface} to declare\n * their support of an interface.\n */\nabstract contract ERC165 is IERC165 {\n    /*\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\n     */\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n\n    /**\n     * @dev Mapping of interface ids to whether or not it's supported.\n     */\n    mapping(bytes4 => bool) private _supportedInterfaces;\n\n    constructor () internal {\n        // Derived contracts need only register support for their own interfaces,\n        // we register support for ERC165 itself here\n        _registerInterface(_INTERFACE_ID_ERC165);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     *\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @dev Registers the contract as an implementer of the interface defined by\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\n     * registering its interface id is not required.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * Requirements:\n     *\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\n     */\n    function _registerInterface(bytes4 interfaceId) internal virtual {\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n        _supportedInterfaces[interfaceId] = true;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/EnumerableMap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * As of v3.0.0, only maps of type `uint256 -> address` (`UintToAddressMap`) are\n * supported.\n */\nlibrary EnumerableMap {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Map type with\n    // bytes32 keys and values.\n    // The Map implementation uses private functions, and user-facing\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\n    // the underlying Map.\n    // This means that we can only create new EnumerableMaps for types that fit\n    // in bytes32.\n\n    struct MapEntry {\n        bytes32 _key;\n        bytes32 _value;\n    }\n\n    struct Map {\n        // Storage of map keys and values\n        MapEntry[] _entries;\n\n        // Position of the entry defined by a key in the `entries` array, plus 1\n        // because index 0 means a key is not in the map.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function _set(Map storage map, bytes32 key, bytes32 value) private returns (bool) {\n        // We read and store the key's index to prevent multiple reads from the same storage slot\n        uint256 keyIndex = map._indexes[key];\n\n        if (keyIndex == 0) { // Equivalent to !contains(map, key)\n            map._entries.push(MapEntry({ _key: key, _value: value }));\n            // The entry is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            map._indexes[key] = map._entries.length;\n            return true;\n        } else {\n            map._entries[keyIndex - 1]._value = value;\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\n        // We read and store the key's index to prevent multiple reads from the same storage slot\n        uint256 keyIndex = map._indexes[key];\n\n        if (keyIndex != 0) { // Equivalent to contains(map, key)\n            // To delete a key-value pair from the _entries array in O(1), we swap the entry to delete with the last one\n            // in the array, and then remove the last entry (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = keyIndex - 1;\n            uint256 lastIndex = map._entries.length - 1;\n\n            // When the entry to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            MapEntry storage lastEntry = map._entries[lastIndex];\n\n            // Move the last entry to the index where the entry to delete is\n            map._entries[toDeleteIndex] = lastEntry;\n            // Update the index for the moved entry\n            map._indexes[lastEntry._key] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved entry was stored\n            map._entries.pop();\n\n            // Delete the index for the deleted slot\n            delete map._indexes[key];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function _contains(Map storage map, bytes32 key) private view returns (bool) {\n        return map._indexes[key] != 0;\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function _length(Map storage map) private view returns (uint256) {\n        return map._entries.length;\n    }\n\n   /**\n    * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n    *\n    * Note that there are no guarantees on the ordering of entries inside the\n    * array, and it may change when more entries are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {\n        require(map._entries.length > index, \"EnumerableMap: index out of bounds\");\n\n        MapEntry storage entry = map._entries[index];\n        return (entry._key, entry._value);\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function _tryGet(Map storage map, bytes32 key) private view returns (bool, bytes32) {\n        uint256 keyIndex = map._indexes[key];\n        if (keyIndex == 0) return (false, 0); // Equivalent to contains(map, key)\n        return (true, map._entries[keyIndex - 1]._value); // All indexes are 1-based\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\n        uint256 keyIndex = map._indexes[key];\n        require(keyIndex != 0, \"EnumerableMap: nonexistent key\"); // Equivalent to contains(map, key)\n        return map._entries[keyIndex - 1]._value; // All indexes are 1-based\n    }\n\n    /**\n     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {_tryGet}.\n     */\n    function _get(Map storage map, bytes32 key, string memory errorMessage) private view returns (bytes32) {\n        uint256 keyIndex = map._indexes[key];\n        require(keyIndex != 0, errorMessage); // Equivalent to contains(map, key)\n        return map._entries[keyIndex - 1]._value; // All indexes are 1-based\n    }\n\n    // UintToAddressMap\n\n    struct UintToAddressMap {\n        Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\n        return _set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n        return _remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return _contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\n        return _length(map._inner);\n    }\n\n   /**\n    * @dev Returns the element stored at position `index` in the set. O(1).\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\n        return (uint256(key), address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     *\n     * _Available since v3.4._\n     */\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\n        (bool success, bytes32 value) = _tryGet(map._inner, bytes32(key));\n        return (success, address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key)))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(UintToAddressMap storage map, uint256 key, string memory errorMessage) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key), errorMessage))));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        uint256 index = digits - 1;\n        temp = value;\n        while (temp != 0) {\n            buffer[index--] = bytes1(uint8(48 + temp % 10));\n            temp /= 10;\n        }\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor () internal {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "contracts/guarded/OwnerPausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\r\n\r\n/**\r\n * @title OwnerPausable\r\n * @notice An ownable contract allows the owner to pause and unpause the\r\n * contract without a delay.\r\n * @dev Only methods using the provided modifiers will be paused.\r\n */\r\ncontract OwnerPausable is Ownable, Pausable {\r\n    /**\r\n     * @notice Pause the contract. Revert if already paused.\r\n     */\r\n    function pause() external onlyOwner {\r\n        Pausable._pause();\r\n    }\r\n\r\n    /**\r\n     * @notice Unpause the contract. Revert if already unpaused.\r\n     */\r\n    function unpause() external onlyOwner {\r\n        Pausable._unpause();\r\n    }\r\n}\r\n"
    },
    "contracts/guarded/SwapGuarded.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\r\nimport \"./OwnerPausable.sol\";\r\nimport \"./SwapUtilsGuarded.sol\";\r\nimport \"../MathUtils.sol\";\r\nimport \"./Allowlist.sol\";\r\n\r\n/**\r\n * @title Swap - A StableSwap implementation in solidity.\r\n * @notice This contract is responsible for custody of closely pegged assets (eg. group of stablecoins)\r\n * and automatic market making system. Users become an LP (Liquidity Provider) by depositing their tokens\r\n * in desired ratios for an exchange of the pool token that represents their share of the pool.\r\n * Users can burn pool tokens and withdraw their share of token(s).\r\n *\r\n * Each time a swap between the pooled tokens happens, a set fee incurs which effectively gets\r\n * distributed to the LPs.\r\n *\r\n * In case of emergencies, admin can pause additional deposits, swaps, or single-asset withdraws - which\r\n * stops the ratio of the tokens in the pool from changing.\r\n * Users can always withdraw their tokens via multi-asset withdraws.\r\n *\r\n * @dev Most of the logic is stored as a library `SwapUtils` for the sake of reducing contract's\r\n * deployment size.\r\n */\r\ncontract SwapGuarded is OwnerPausable, ReentrancyGuard {\r\n    using SafeERC20 for IERC20;\r\n    using SafeMath for uint256;\r\n    using MathUtils for uint256;\r\n    using SwapUtilsGuarded for SwapUtilsGuarded.Swap;\r\n\r\n    // Struct storing data responsible for automatic market maker functionalities. In order to\r\n    // access this data, this contract uses SwapUtils library. For more details, see SwapUtilsGuarded.sol\r\n    SwapUtilsGuarded.Swap public swapStorage;\r\n\r\n    // Address to allowlist contract that holds information about maximum totaly supply of lp tokens\r\n    // and maximum mintable amount per user address. As this is immutable, this will become a constant\r\n    // after initialization.\r\n    IAllowlist private immutable allowlist;\r\n\r\n    // Boolean value that notates whether this pool is guarded or not. When isGuarded is true,\r\n    // addLiquidity function will be restricted by limits defined in allowlist contract.\r\n    bool private guarded = true;\r\n\r\n    // Maps token address to an index in the pool. Used to prevent duplicate tokens in the pool.\r\n    // getTokenIndex function also relies on this mapping to retrieve token index.\r\n    mapping(address => uint8) private tokenIndexes;\r\n\r\n    /*** EVENTS ***/\r\n\r\n    // events replicated from SwapUtils to make the ABI easier for dumb\r\n    // clients\r\n    event TokenSwap(\r\n        address indexed buyer,\r\n        uint256 tokensSold,\r\n        uint256 tokensBought,\r\n        uint128 soldId,\r\n        uint128 boughtId\r\n    );\r\n    event AddLiquidity(\r\n        address indexed provider,\r\n        uint256[] tokenAmounts,\r\n        uint256[] fees,\r\n        uint256 invariant,\r\n        uint256 lpTokenSupply\r\n    );\r\n    event RemoveLiquidity(\r\n        address indexed provider,\r\n        uint256[] tokenAmounts,\r\n        uint256 lpTokenSupply\r\n    );\r\n    event RemoveLiquidityOne(\r\n        address indexed provider,\r\n        uint256 lpTokenAmount,\r\n        uint256 lpTokenSupply,\r\n        uint256 boughtId,\r\n        uint256 tokensBought\r\n    );\r\n    event RemoveLiquidityImbalance(\r\n        address indexed provider,\r\n        uint256[] tokenAmounts,\r\n        uint256[] fees,\r\n        uint256 invariant,\r\n        uint256 lpTokenSupply\r\n    );\r\n    event NewAdminFee(uint256 newAdminFee);\r\n    event NewSwapFee(uint256 newSwapFee);\r\n    event NewWithdrawFee(uint256 newWithdrawFee);\r\n    event RampA(\r\n        uint256 oldA,\r\n        uint256 newA,\r\n        uint256 initialTime,\r\n        uint256 futureTime\r\n    );\r\n    event StopRampA(uint256 currentA, uint256 time);\r\n\r\n    /**\r\n     * @notice Deploys this Swap contract with given parameters as default\r\n     * values. This will also deploy a LPToken that represents users\r\n     * LP position. The owner of LPToken will be this contract - which means\r\n     * only this contract is allowed to mint new tokens.\r\n     *\r\n     * @param _pooledTokens an array of ERC20s this pool will accept\r\n     * @param decimals the decimals to use for each pooled token,\r\n     * eg 8 for WBTC. Cannot be larger than POOL_PRECISION_DECIMALS\r\n     * @param lpTokenName the long-form name of the token to be deployed\r\n     * @param lpTokenSymbol the short symbol for the token to be deployed\r\n     * @param _a the amplification coefficient * n * (n - 1). See the\r\n     * StableSwap paper for details\r\n     * @param _fee default swap fee to be initialized with\r\n     * @param _adminFee default adminFee to be initialized with\r\n     * @param _withdrawFee default withdrawFee to be initialized with\r\n     * @param _allowlist address of allowlist contract for guarded launch\r\n     */\r\n    constructor(\r\n        IERC20[] memory _pooledTokens,\r\n        uint8[] memory decimals,\r\n        string memory lpTokenName,\r\n        string memory lpTokenSymbol,\r\n        uint256 _a,\r\n        uint256 _fee,\r\n        uint256 _adminFee,\r\n        uint256 _withdrawFee,\r\n        IAllowlist _allowlist\r\n    ) public OwnerPausable() ReentrancyGuard() {\r\n        // Check _pooledTokens and precisions parameter\r\n        require(_pooledTokens.length > 1, \"_pooledTokens.length <= 1\");\r\n        require(_pooledTokens.length <= 32, \"_pooledTokens.length > 32\");\r\n        require(\r\n            _pooledTokens.length == decimals.length,\r\n            \"_pooledTokens decimals mismatch\"\r\n        );\r\n\r\n        uint256[] memory precisionMultipliers = new uint256[](decimals.length);\r\n\r\n        for (uint8 i = 0; i < _pooledTokens.length; i++) {\r\n            if (i > 0) {\r\n                // Check if index is already used. Check if 0th element is a duplicate.\r\n                require(\r\n                    tokenIndexes[address(_pooledTokens[i])] == 0 &&\r\n                        _pooledTokens[0] != _pooledTokens[i],\r\n                    \"Duplicate tokens\"\r\n                );\r\n            }\r\n            require(\r\n                address(_pooledTokens[i]) != address(0),\r\n                \"The 0 address isn't an ERC-20\"\r\n            );\r\n            require(\r\n                decimals[i] <= SwapUtilsGuarded.POOL_PRECISION_DECIMALS,\r\n                \"Token decimals exceeds max\"\r\n            );\r\n            precisionMultipliers[i] =\r\n                10 **\r\n                    uint256(SwapUtilsGuarded.POOL_PRECISION_DECIMALS).sub(\r\n                        uint256(decimals[i])\r\n                    );\r\n            tokenIndexes[address(_pooledTokens[i])] = i;\r\n        }\r\n\r\n        // Check _a, _fee, _adminFee, _withdrawFee, _allowlist parameters\r\n        require(_a < SwapUtilsGuarded.MAX_A, \"_a exceeds maximum\");\r\n        require(_fee < SwapUtilsGuarded.MAX_SWAP_FEE, \"_fee exceeds maximum\");\r\n        require(\r\n            _adminFee < SwapUtilsGuarded.MAX_ADMIN_FEE,\r\n            \"_adminFee exceeds maximum\"\r\n        );\r\n        require(\r\n            _withdrawFee < SwapUtilsGuarded.MAX_WITHDRAW_FEE,\r\n            \"_withdrawFee exceeds maximum\"\r\n        );\r\n        require(\r\n            _allowlist.getPoolCap(address(0x0)) == uint256(0x54dd1e),\r\n            \"Allowlist check failed\"\r\n        );\r\n\r\n        // Initialize swapStorage struct\r\n        swapStorage.lpToken = new LPTokenGuarded(\r\n            lpTokenName,\r\n            lpTokenSymbol,\r\n            SwapUtilsGuarded.POOL_PRECISION_DECIMALS\r\n        );\r\n        swapStorage.pooledTokens = _pooledTokens;\r\n        swapStorage.tokenPrecisionMultipliers = precisionMultipliers;\r\n        swapStorage.balances = new uint256[](_pooledTokens.length);\r\n        swapStorage.initialA = _a.mul(SwapUtilsGuarded.A_PRECISION);\r\n        swapStorage.futureA = _a.mul(SwapUtilsGuarded.A_PRECISION);\r\n        swapStorage.initialATime = 0;\r\n        swapStorage.futureATime = 0;\r\n        swapStorage.swapFee = _fee;\r\n        swapStorage.adminFee = _adminFee;\r\n        swapStorage.defaultWithdrawFee = _withdrawFee;\r\n\r\n        // Initialize variables related to guarding the initial deposits\r\n        allowlist = _allowlist;\r\n        guarded = true;\r\n    }\r\n\r\n    /*** MODIFIERS ***/\r\n\r\n    /**\r\n     * @notice Modifier to check deadline against current timestamp\r\n     * @param deadline latest timestamp to accept this transaction\r\n     */\r\n    modifier deadlineCheck(uint256 deadline) {\r\n        require(block.timestamp <= deadline, \"Deadline not met\");\r\n        _;\r\n    }\r\n\r\n    /*** VIEW FUNCTIONS ***/\r\n\r\n    /**\r\n     * @notice Return A, the amplification coefficient * n * (n - 1)\r\n     * @dev See the StableSwap paper for details\r\n     * @return A parameter\r\n     */\r\n    function getA() external view returns (uint256) {\r\n        return swapStorage.getA();\r\n    }\r\n\r\n    /**\r\n     * @notice Return A in its raw precision form\r\n     * @dev See the StableSwap paper for details\r\n     * @return A parameter in its raw precision form\r\n     */\r\n    function getAPrecise() external view returns (uint256) {\r\n        return swapStorage.getAPrecise();\r\n    }\r\n\r\n    /**\r\n     * @notice Return address of the pooled token at given index. Reverts if tokenIndex is out of range.\r\n     * @param index the index of the token\r\n     * @return address of the token at given index\r\n     */\r\n    function getToken(uint8 index) public view returns (IERC20) {\r\n        require(index < swapStorage.pooledTokens.length, \"Out of range\");\r\n        return swapStorage.pooledTokens[index];\r\n    }\r\n\r\n    /**\r\n     * @notice Return the index of the given token address. Reverts if no matching\r\n     * token is found.\r\n     * @param tokenAddress address of the token\r\n     * @return the index of the given token address\r\n     */\r\n    function getTokenIndex(address tokenAddress) external view returns (uint8) {\r\n        uint8 index = tokenIndexes[tokenAddress];\r\n        require(\r\n            address(getToken(index)) == tokenAddress,\r\n            \"Token does not exist\"\r\n        );\r\n        return index;\r\n    }\r\n\r\n    /**\r\n     * @notice Reads and returns the address of the allowlist that is set during deployment of this contract\r\n     * @return the address of the allowlist contract casted to the IAllowlist interface\r\n     */\r\n    function getAllowlist() external view returns (IAllowlist) {\r\n        return allowlist;\r\n    }\r\n\r\n    /**\r\n     * @notice Return timestamp of last deposit of given address\r\n     * @return timestamp of the last deposit made by the given address\r\n     */\r\n    function getDepositTimestamp(address user) external view returns (uint256) {\r\n        return swapStorage.getDepositTimestamp(user);\r\n    }\r\n\r\n    /**\r\n     * @notice Return current balance of the pooled token at given index\r\n     * @param index the index of the token\r\n     * @return current balance of the pooled token at given index with token's native precision\r\n     */\r\n    function getTokenBalance(uint8 index) external view returns (uint256) {\r\n        require(index < swapStorage.pooledTokens.length, \"Index out of range\");\r\n        return swapStorage.balances[index];\r\n    }\r\n\r\n    /**\r\n     * @notice Get the virtual price, to help calculate profit\r\n     * @return the virtual price, scaled to the POOL_PRECISION_DECIMALS\r\n     */\r\n    function getVirtualPrice() external view returns (uint256) {\r\n        return swapStorage.getVirtualPrice();\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate amount of tokens you receive on swap\r\n     * @param tokenIndexFrom the token the user wants to sell\r\n     * @param tokenIndexTo the token the user wants to buy\r\n     * @param dx the amount of tokens the user wants to sell. If the token charges\r\n     * a fee on transfers, use the amount that gets transferred after the fee.\r\n     * @return amount of tokens the user will receive\r\n     */\r\n    function calculateSwap(\r\n        uint8 tokenIndexFrom,\r\n        uint8 tokenIndexTo,\r\n        uint256 dx\r\n    ) external view returns (uint256) {\r\n        return swapStorage.calculateSwap(tokenIndexFrom, tokenIndexTo, dx);\r\n    }\r\n\r\n    /**\r\n     * @notice A simple method to calculate prices from deposits or\r\n     * withdrawals, excluding fees but including slippage. This is\r\n     * helpful as an input into the various \"min\" parameters on calls\r\n     * to fight front-running\r\n     *\r\n     * @dev This shouldn't be used outside frontends for user estimates.\r\n     *\r\n     * @param account address that is depositing or withdrawing tokens\r\n     * @param amounts an array of token amounts to deposit or withdrawal,\r\n     * corresponding to pooledTokens. The amount should be in each\r\n     * pooled token's native precision. If a token charges a fee on transfers,\r\n     * use the amount that gets transferred after the fee.\r\n     * @param deposit whether this is a deposit or a withdrawal\r\n     * @return token amount the user will receive\r\n     */\r\n    function calculateTokenAmount(\r\n        address account,\r\n        uint256[] calldata amounts,\r\n        bool deposit\r\n    ) external view returns (uint256) {\r\n        return swapStorage.calculateTokenAmount(account, amounts, deposit);\r\n    }\r\n\r\n    /**\r\n     * @notice A simple method to calculate amount of each underlying\r\n     * tokens that is returned upon burning given amount of LP tokens\r\n     * @param account the address that is withdrawing tokens\r\n     * @param amount the amount of LP tokens that would be burned on withdrawal\r\n     * @return array of token balances that the user will receive\r\n     */\r\n    function calculateRemoveLiquidity(address account, uint256 amount)\r\n        external\r\n        view\r\n        returns (uint256[] memory)\r\n    {\r\n        return swapStorage.calculateRemoveLiquidity(account, amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the amount of underlying token available to withdraw\r\n     * when withdrawing via only single token\r\n     * @param account the address that is withdrawing tokens\r\n     * @param tokenAmount the amount of LP token to burn\r\n     * @param tokenIndex index of which token will be withdrawn\r\n     * @return availableTokenAmount calculated amount of underlying token\r\n     * available to withdraw\r\n     */\r\n    function calculateRemoveLiquidityOneToken(\r\n        address account,\r\n        uint256 tokenAmount,\r\n        uint8 tokenIndex\r\n    ) external view returns (uint256 availableTokenAmount) {\r\n        (availableTokenAmount, ) = swapStorage.calculateWithdrawOneToken(\r\n            account,\r\n            tokenAmount,\r\n            tokenIndex\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the fee that is applied when the given user withdraws. The withdraw fee\r\n     * decays linearly over period of 4 weeks. For example, depositing and withdrawing right away\r\n     * will charge you the full amount of withdraw fee. But withdrawing after 4 weeks will charge you\r\n     * no additional fees.\r\n     * @dev returned value should be divided by FEE_DENOMINATOR to convert to correct decimals\r\n     * @param user address you want to calculate withdraw fee of\r\n     * @return current withdraw fee of the user\r\n     */\r\n    function calculateCurrentWithdrawFee(address user)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return swapStorage.calculateCurrentWithdrawFee(user);\r\n    }\r\n\r\n    /**\r\n     * @notice This function reads the accumulated amount of admin fees of the token with given index\r\n     * @param index Index of the pooled token\r\n     * @return admin's token balance in the token's precision\r\n     */\r\n    function getAdminBalance(uint256 index) external view returns (uint256) {\r\n        return swapStorage.getAdminBalance(index);\r\n    }\r\n\r\n    /*** STATE MODIFYING FUNCTIONS ***/\r\n\r\n    /**\r\n     * @notice Swap two tokens using this pool\r\n     * @param tokenIndexFrom the token the user wants to swap from\r\n     * @param tokenIndexTo the token the user wants to swap to\r\n     * @param dx the amount of tokens the user wants to swap from\r\n     * @param minDy the min amount the user would like to receive, or revert.\r\n     * @param deadline latest timestamp to accept this transaction\r\n     */\r\n    function swap(\r\n        uint8 tokenIndexFrom,\r\n        uint8 tokenIndexTo,\r\n        uint256 dx,\r\n        uint256 minDy,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        nonReentrant\r\n        whenNotPaused\r\n        deadlineCheck(deadline)\r\n        returns (uint256)\r\n    {\r\n        return swapStorage.swap(tokenIndexFrom, tokenIndexTo, dx, minDy);\r\n    }\r\n\r\n    /**\r\n     * @notice Add liquidity to the pool with given amounts during guarded launch phase. Only users\r\n     * with valid address and proof can successfully call this function. When this function is called\r\n     * after the guarded release phase is over, the merkleProof is ignored.\r\n     * @param amounts the amounts of each token to add, in their native precision\r\n     * @param minToMint the minimum LP tokens adding this amount of liquidity\r\n     * should mint, otherwise revert. Handy for front-running mitigation\r\n     * @param deadline latest timestamp to accept this transaction\r\n     * @param merkleProof data generated when constructing the allowlist merkle tree. Users can\r\n     * get this data off chain. Even if the address is in the allowlist, users must include\r\n     * a valid proof for this call to succeed. If the pool is no longer in the guarded release phase,\r\n     * this parameter is ignored.\r\n     * @return amount of LP token user minted and received\r\n     */\r\n    function addLiquidity(\r\n        uint256[] calldata amounts,\r\n        uint256 minToMint,\r\n        uint256 deadline,\r\n        bytes32[] calldata merkleProof\r\n    )\r\n        external\r\n        nonReentrant\r\n        whenNotPaused\r\n        deadlineCheck(deadline)\r\n        returns (uint256)\r\n    {\r\n        return swapStorage.addLiquidity(amounts, minToMint, merkleProof);\r\n    }\r\n\r\n    /**\r\n     * @notice Burn LP tokens to remove liquidity from the pool. Withdraw fee that decays linearly\r\n     * over period of 4 weeks since last deposit will apply.\r\n     * @dev Liquidity can always be removed, even when the pool is paused.\r\n     * @param amount the amount of LP tokens to burn\r\n     * @param minAmounts the minimum amounts of each token in the pool\r\n     *        acceptable for this burn. Useful as a front-running mitigation\r\n     * @param deadline latest timestamp to accept this transaction\r\n     * @return amounts of tokens user received\r\n     */\r\n    function removeLiquidity(\r\n        uint256 amount,\r\n        uint256[] calldata minAmounts,\r\n        uint256 deadline\r\n    ) external nonReentrant deadlineCheck(deadline) returns (uint256[] memory) {\r\n        return swapStorage.removeLiquidity(amount, minAmounts);\r\n    }\r\n\r\n    /**\r\n     * @notice Remove liquidity from the pool all in one token. Withdraw fee that decays linearly\r\n     * over period of 4 weeks since last deposit will apply.\r\n     * @param tokenAmount the amount of the token you want to receive\r\n     * @param tokenIndex the index of the token you want to receive\r\n     * @param minAmount the minimum amount to withdraw, otherwise revert\r\n     * @param deadline latest timestamp to accept this transaction\r\n     * @return amount of chosen token user received\r\n     */\r\n    function removeLiquidityOneToken(\r\n        uint256 tokenAmount,\r\n        uint8 tokenIndex,\r\n        uint256 minAmount,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        nonReentrant\r\n        whenNotPaused\r\n        deadlineCheck(deadline)\r\n        returns (uint256)\r\n    {\r\n        return\r\n            swapStorage.removeLiquidityOneToken(\r\n                tokenAmount,\r\n                tokenIndex,\r\n                minAmount\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @notice Remove liquidity from the pool, weighted differently than the\r\n     * pool's current balances. Withdraw fee that decays linearly\r\n     * over period of 4 weeks since last deposit will apply.\r\n     * @param amounts how much of each token to withdraw\r\n     * @param maxBurnAmount the max LP token provider is willing to pay to\r\n     * remove liquidity. Useful as a front-running mitigation.\r\n     * @param deadline latest timestamp to accept this transaction\r\n     * @return amount of LP tokens burned\r\n     */\r\n    function removeLiquidityImbalance(\r\n        uint256[] calldata amounts,\r\n        uint256 maxBurnAmount,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        nonReentrant\r\n        whenNotPaused\r\n        deadlineCheck(deadline)\r\n        returns (uint256)\r\n    {\r\n        return swapStorage.removeLiquidityImbalance(amounts, maxBurnAmount);\r\n    }\r\n\r\n    /*** ADMIN FUNCTIONS ***/\r\n\r\n    /**\r\n     * @notice Updates the user withdraw fee. This function can only be called by\r\n     * the pool token. Should be used to update the withdraw fee on transfer of pool tokens.\r\n     * Transferring your pool token will reset the 4 weeks period. If the recipient is already\r\n     * holding some pool tokens, the withdraw fee will be discounted in respective amounts.\r\n     * @param recipient address of the recipient of pool token\r\n     * @param transferAmount amount of pool token to transfer\r\n     */\r\n    function updateUserWithdrawFee(address recipient, uint256 transferAmount)\r\n        external\r\n    {\r\n        require(\r\n            msg.sender == address(swapStorage.lpToken),\r\n            \"Only callable by pool token\"\r\n        );\r\n        swapStorage.updateUserWithdrawFee(recipient, transferAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraw all admin fees to the contract owner\r\n     */\r\n    function withdrawAdminFees() external onlyOwner {\r\n        swapStorage.withdrawAdminFees(owner());\r\n    }\r\n\r\n    /**\r\n     * @notice Update the admin fee. Admin fee takes portion of the swap fee.\r\n     * @param newAdminFee new admin fee to be applied on future transactions\r\n     */\r\n    function setAdminFee(uint256 newAdminFee) external onlyOwner {\r\n        swapStorage.setAdminFee(newAdminFee);\r\n    }\r\n\r\n    /**\r\n     * @notice Update the swap fee to be applied on swaps\r\n     * @param newSwapFee new swap fee to be applied on future transactions\r\n     */\r\n    function setSwapFee(uint256 newSwapFee) external onlyOwner {\r\n        swapStorage.setSwapFee(newSwapFee);\r\n    }\r\n\r\n    /**\r\n     * @notice Update the withdraw fee. This fee decays linearly over 4 weeks since\r\n     * user's last deposit.\r\n     * @param newWithdrawFee new withdraw fee to be applied on future deposits\r\n     */\r\n    function setDefaultWithdrawFee(uint256 newWithdrawFee) external onlyOwner {\r\n        swapStorage.setDefaultWithdrawFee(newWithdrawFee);\r\n    }\r\n\r\n    /**\r\n     * @notice Start ramping up or down A parameter towards given futureA and futureTime\r\n     * Checks if the change is too rapid, and commits the new A value only when it falls under\r\n     * the limit range.\r\n     * @param futureA the new A to ramp towards\r\n     * @param futureTime timestamp when the new A should be reached\r\n     */\r\n    function rampA(uint256 futureA, uint256 futureTime) external onlyOwner {\r\n        swapStorage.rampA(futureA, futureTime);\r\n    }\r\n\r\n    /**\r\n     * @notice Stop ramping A immediately. Reverts if ramp A is already stopped.\r\n     */\r\n    function stopRampA() external onlyOwner {\r\n        swapStorage.stopRampA();\r\n    }\r\n\r\n    /**\r\n     * @notice Disables the guarded launch phase, removing any limits on deposit amounts and addresses\r\n     */\r\n    function disableGuard() external onlyOwner {\r\n        guarded = false;\r\n    }\r\n\r\n    /**\r\n     * @notice Reads and returns current guarded status of the pool\r\n     * @return guarded_ boolean value indicating whether the deposits should be guarded\r\n     */\r\n    function isGuarded() external view returns (bool) {\r\n        return guarded;\r\n    }\r\n}\r\n"
    },
    "contracts/guarded/SwapUtilsGuarded.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\n// https://etherscan.io/address/0x2b7a5a5923eca5c00c6572cf3e8e08384f563f93#code\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\r\nimport \"./LPTokenGuarded.sol\";\r\nimport \"../MathUtils.sol\";\r\n\r\n/**\r\n * @title SwapUtils library\r\n * @notice A library to be used within Swap.sol. Contains functions responsible for custody and AMM functionalities.\r\n * @dev Contracts relying on this library must initialize SwapUtils.Swap struct then use this library\r\n * for SwapUtils.Swap struct. Note that this library contains both functions called by users and admins.\r\n * Admin functions should be protected within contracts using this library.\r\n */\r\nlibrary SwapUtilsGuarded {\r\n    using SafeERC20 for IERC20;\r\n    using SafeMath for uint256;\r\n    using MathUtils for uint256;\r\n\r\n    /*** EVENTS ***/\r\n\r\n    event TokenSwap(\r\n        address indexed buyer,\r\n        uint256 tokensSold,\r\n        uint256 tokensBought,\r\n        uint128 soldId,\r\n        uint128 boughtId\r\n    );\r\n    event AddLiquidity(\r\n        address indexed provider,\r\n        uint256[] tokenAmounts,\r\n        uint256[] fees,\r\n        uint256 invariant,\r\n        uint256 lpTokenSupply\r\n    );\r\n    event RemoveLiquidity(\r\n        address indexed provider,\r\n        uint256[] tokenAmounts,\r\n        uint256 lpTokenSupply\r\n    );\r\n    event RemoveLiquidityOne(\r\n        address indexed provider,\r\n        uint256 lpTokenAmount,\r\n        uint256 lpTokenSupply,\r\n        uint256 boughtId,\r\n        uint256 tokensBought\r\n    );\r\n    event RemoveLiquidityImbalance(\r\n        address indexed provider,\r\n        uint256[] tokenAmounts,\r\n        uint256[] fees,\r\n        uint256 invariant,\r\n        uint256 lpTokenSupply\r\n    );\r\n    event NewAdminFee(uint256 newAdminFee);\r\n    event NewSwapFee(uint256 newSwapFee);\r\n    event NewWithdrawFee(uint256 newWithdrawFee);\r\n    event RampA(\r\n        uint256 oldA,\r\n        uint256 newA,\r\n        uint256 initialTime,\r\n        uint256 futureTime\r\n    );\r\n    event StopRampA(uint256 currentA, uint256 time);\r\n\r\n    struct Swap {\r\n        // variables around the ramp management of A,\r\n        // the amplification coefficient * n * (n - 1)\r\n        // see https://www.curve.fi/stableswap-paper.pdf for details\r\n        uint256 initialA;\r\n        uint256 futureA;\r\n        uint256 initialATime;\r\n        uint256 futureATime;\r\n        // fee calculation\r\n        uint256 swapFee;\r\n        uint256 adminFee;\r\n        uint256 defaultWithdrawFee;\r\n        LPTokenGuarded lpToken;\r\n        // contract references for all tokens being pooled\r\n        IERC20[] pooledTokens;\r\n        // multipliers for each pooled token's precision to get to POOL_PRECISION_DECIMALS\r\n        // for example, TBTC has 18 decimals, so the multiplier should be 1. WBTC\r\n        // has 8, so the multiplier should be 10 ** 18 / 10 ** 8 => 10 ** 10\r\n        uint256[] tokenPrecisionMultipliers;\r\n        // the pool balance of each token, in the token's precision\r\n        // the contract's actual token balance might differ\r\n        uint256[] balances;\r\n        mapping(address => uint256) depositTimestamp;\r\n        mapping(address => uint256) withdrawFeeMultiplier;\r\n    }\r\n\r\n    // Struct storing variables used in calculations in the\r\n    // calculateWithdrawOneTokenDY function to avoid stack too deep errors\r\n    struct CalculateWithdrawOneTokenDYInfo {\r\n        uint256 d0;\r\n        uint256 d1;\r\n        uint256 newY;\r\n        uint256 feePerToken;\r\n        uint256 preciseA;\r\n    }\r\n\r\n    // Struct storing variables used in calculation in addLiquidity function\r\n    // to avoid stack too deep error\r\n    struct AddLiquidityInfo {\r\n        uint256 d0;\r\n        uint256 d1;\r\n        uint256 d2;\r\n        uint256 preciseA;\r\n    }\r\n\r\n    // Struct storing variables used in calculation in removeLiquidityImbalance function\r\n    // to avoid stack too deep error\r\n    struct RemoveLiquidityImbalanceInfo {\r\n        uint256 d0;\r\n        uint256 d1;\r\n        uint256 d2;\r\n        uint256 preciseA;\r\n    }\r\n\r\n    // the precision all pools tokens will be converted to\r\n    uint8 public constant POOL_PRECISION_DECIMALS = 18;\r\n\r\n    // the denominator used to calculate admin and LP fees. For example, an\r\n    // LP fee might be something like tradeAmount.mul(fee).div(FEE_DENOMINATOR)\r\n    uint256 private constant FEE_DENOMINATOR = 10**10;\r\n\r\n    // Max swap fee is 1% or 100bps of each swap\r\n    uint256 public constant MAX_SWAP_FEE = 10**8;\r\n\r\n    // Max adminFee is 100% of the swapFee\r\n    // adminFee does not add additional fee on top of swapFee\r\n    // Instead it takes a certain % of the swapFee. Therefore it has no impact on the\r\n    // users but only on the earnings of LPs\r\n    uint256 public constant MAX_ADMIN_FEE = 10**10;\r\n\r\n    // Max withdrawFee is 1% of the value withdrawn\r\n    // Fee will be redistributed to the LPs in the pool, rewarding\r\n    // long term providers.\r\n    uint256 public constant MAX_WITHDRAW_FEE = 10**8;\r\n\r\n    // Constant value used as max loop limit\r\n    uint256 private constant MAX_LOOP_LIMIT = 256;\r\n\r\n    // Constant values used in ramping A calculations\r\n    uint256 public constant A_PRECISION = 100;\r\n    uint256 public constant MAX_A = 10**6;\r\n    uint256 private constant MAX_A_CHANGE = 2;\r\n    uint256 private constant MIN_RAMP_TIME = 14 days;\r\n\r\n    /*** VIEW & PURE FUNCTIONS ***/\r\n\r\n    /**\r\n     * @notice Return A, the amplification coefficient * n * (n - 1)\r\n     * @dev See the StableSwap paper for details\r\n     * @param self Swap struct to read from\r\n     * @return A parameter\r\n     */\r\n    function getA(Swap storage self) external view returns (uint256) {\r\n        return _getA(self);\r\n    }\r\n\r\n    /**\r\n     * @notice Return A, the amplification coefficient * n * (n - 1)\r\n     * @dev See the StableSwap paper for details\r\n     * @param self Swap struct to read from\r\n     * @return A parameter\r\n     */\r\n    function _getA(Swap storage self) internal view returns (uint256) {\r\n        return _getAPrecise(self).div(A_PRECISION);\r\n    }\r\n\r\n    /**\r\n     * @notice Return A in its raw precision\r\n     * @dev See the StableSwap paper for details\r\n     * @param self Swap struct to read from\r\n     * @return A parameter in its raw precision form\r\n     */\r\n    function getAPrecise(Swap storage self) external view returns (uint256) {\r\n        return _getAPrecise(self);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates and returns A based on the ramp settings\r\n     * @dev See the StableSwap paper for details\r\n     * @param self Swap struct to read from\r\n     * @return A parameter in its raw precision form\r\n     */\r\n    function _getAPrecise(Swap storage self) internal view returns (uint256) {\r\n        uint256 t1 = self.futureATime; // time when ramp is finished\r\n        uint256 a1 = self.futureA; // final A value when ramp is finished\r\n\r\n        if (block.timestamp < t1) {\r\n            uint256 t0 = self.initialATime; // time when ramp is started\r\n            uint256 a0 = self.initialA; // initial A value when ramp is started\r\n            if (a1 > a0) {\r\n                // a0 + (a1 - a0) * (block.timestamp - t0) / (t1 - t0)\r\n                return\r\n                    a0.add(\r\n                        a1.sub(a0).mul(block.timestamp.sub(t0)).div(t1.sub(t0))\r\n                    );\r\n            } else {\r\n                // a0 - (a0 - a1) * (block.timestamp - t0) / (t1 - t0)\r\n                return\r\n                    a0.sub(\r\n                        a0.sub(a1).mul(block.timestamp.sub(t0)).div(t1.sub(t0))\r\n                    );\r\n            }\r\n        } else {\r\n            return a1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieves the timestamp of last deposit made by the given address\r\n     * @param self Swap struct to read from\r\n     * @return timestamp of last deposit\r\n     */\r\n    function getDepositTimestamp(Swap storage self, address user)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return self.depositTimestamp[user];\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the dy, the amount of selected token that user receives and\r\n     * the fee of withdrawing in one token\r\n     * @param account the address that is withdrawing\r\n     * @param tokenAmount the amount to withdraw in the pool's precision\r\n     * @param tokenIndex which token will be withdrawn\r\n     * @param self Swap struct to read from\r\n     * @return the amount of token user will receive and the associated swap fee\r\n     */\r\n    function calculateWithdrawOneToken(\r\n        Swap storage self,\r\n        address account,\r\n        uint256 tokenAmount,\r\n        uint8 tokenIndex\r\n    ) public view returns (uint256, uint256) {\r\n        uint256 dy;\r\n        uint256 newY;\r\n\r\n        (dy, newY) = calculateWithdrawOneTokenDY(self, tokenIndex, tokenAmount);\r\n\r\n        // dy_0 (without fees)\r\n        // dy, dy_0 - dy\r\n\r\n        uint256 dySwapFee = _xp(self)[tokenIndex]\r\n            .sub(newY)\r\n            .div(self.tokenPrecisionMultipliers[tokenIndex])\r\n            .sub(dy);\r\n\r\n        dy = dy\r\n            .mul(\r\n                FEE_DENOMINATOR.sub(calculateCurrentWithdrawFee(self, account))\r\n            )\r\n            .div(FEE_DENOMINATOR);\r\n\r\n        return (dy, dySwapFee);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the dy of withdrawing in one token\r\n     * @param self Swap struct to read from\r\n     * @param tokenIndex which token will be withdrawn\r\n     * @param tokenAmount the amount to withdraw in the pools precision\r\n     * @return the d and the new y after withdrawing one token\r\n     */\r\n    function calculateWithdrawOneTokenDY(\r\n        Swap storage self,\r\n        uint8 tokenIndex,\r\n        uint256 tokenAmount\r\n    ) internal view returns (uint256, uint256) {\r\n        require(\r\n            tokenIndex < self.pooledTokens.length,\r\n            \"Token index out of range\"\r\n        );\r\n\r\n        // Get the current D, then solve the stableswap invariant\r\n        // y_i for D - tokenAmount\r\n        uint256[] memory xp = _xp(self);\r\n        CalculateWithdrawOneTokenDYInfo\r\n            memory v = CalculateWithdrawOneTokenDYInfo(0, 0, 0, 0, 0);\r\n        v.preciseA = _getAPrecise(self);\r\n        v.d0 = getD(xp, v.preciseA);\r\n        v.d1 = v.d0.sub(tokenAmount.mul(v.d0).div(self.lpToken.totalSupply()));\r\n\r\n        require(tokenAmount <= xp[tokenIndex], \"Withdraw exceeds available\");\r\n\r\n        v.newY = getYD(v.preciseA, tokenIndex, xp, v.d1);\r\n\r\n        uint256[] memory xpReduced = new uint256[](xp.length);\r\n\r\n        v.feePerToken = _feePerToken(self);\r\n        for (uint256 i = 0; i < self.pooledTokens.length; i++) {\r\n            uint256 xpi = xp[i];\r\n            // if i == tokenIndex, dxExpected = xp[i] * d1 / d0 - newY\r\n            // else dxExpected = xp[i] - (xp[i] * d1 / d0)\r\n            // xpReduced[i] -= dxExpected * fee / FEE_DENOMINATOR\r\n            xpReduced[i] = xpi.sub(\r\n                (\r\n                    (i == tokenIndex)\r\n                        ? xpi.mul(v.d1).div(v.d0).sub(v.newY)\r\n                        : xpi.sub(xpi.mul(v.d1).div(v.d0))\r\n                ).mul(v.feePerToken).div(FEE_DENOMINATOR)\r\n            );\r\n        }\r\n\r\n        uint256 dy = xpReduced[tokenIndex].sub(\r\n            getYD(v.preciseA, tokenIndex, xpReduced, v.d1)\r\n        );\r\n        dy = dy.sub(1).div(self.tokenPrecisionMultipliers[tokenIndex]);\r\n\r\n        return (dy, v.newY);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the price of a token in the pool with given\r\n     * precision-adjusted balances and a particular D.\r\n     *\r\n     * @dev This is accomplished via solving the invariant iteratively.\r\n     * See the StableSwap paper and Curve.fi implementation for further details.\r\n     *\r\n     * x_1**2 + x1 * (sum' - (A*n**n - 1) * D / (A * n**n)) = D ** (n + 1) / (n ** (2 * n) * prod' * A)\r\n     * x_1**2 + b*x_1 = c\r\n     * x_1 = (x_1**2 + c) / (2*x_1 + b)\r\n     *\r\n     * @param a the amplification coefficient * n * (n - 1). See the StableSwap paper for details.\r\n     * @param tokenIndex Index of token we are calculating for.\r\n     * @param xp a precision-adjusted set of pool balances. Array should be\r\n     * the same cardinality as the pool.\r\n     * @param d the stableswap invariant\r\n     * @return the price of the token, in the same precision as in xp\r\n     */\r\n    function getYD(\r\n        uint256 a,\r\n        uint8 tokenIndex,\r\n        uint256[] memory xp,\r\n        uint256 d\r\n    ) internal pure returns (uint256) {\r\n        uint256 numTokens = xp.length;\r\n        require(tokenIndex < numTokens, \"Token not found\");\r\n\r\n        uint256 c = d;\r\n        uint256 s;\r\n        uint256 nA = a.mul(numTokens);\r\n\r\n        for (uint256 i = 0; i < numTokens; i++) {\r\n            if (i != tokenIndex) {\r\n                s = s.add(xp[i]);\r\n                c = c.mul(d).div(xp[i].mul(numTokens));\r\n                // If we were to protect the division loss we would have to keep the denominator separate\r\n                // and divide at the end. However this leads to overflow with large numTokens or/and D.\r\n                // c = c * D * D * D * ... overflow!\r\n            }\r\n        }\r\n        c = c.mul(d).mul(A_PRECISION).div(nA.mul(numTokens));\r\n\r\n        uint256 b = s.add(d.mul(A_PRECISION).div(nA));\r\n        uint256 yPrev;\r\n        uint256 y = d;\r\n        for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {\r\n            yPrev = y;\r\n            y = y.mul(y).add(c).div(y.mul(2).add(b).sub(d));\r\n            if (y.within1(yPrev)) {\r\n                return y;\r\n            }\r\n        }\r\n        revert(\"Approximation did not converge\");\r\n    }\r\n\r\n    /**\r\n     * @notice Get D, the StableSwap invariant, based on a set of balances and a particular A.\r\n     * @param xp a precision-adjusted set of pool balances. Array should be the same cardinality\r\n     * as the pool.\r\n     * @param a the amplification coefficient * n * (n - 1) in A_PRECISION.\r\n     * See the StableSwap paper for details\r\n     * @return the invariant, at the precision of the pool\r\n     */\r\n    function getD(uint256[] memory xp, uint256 a)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 numTokens = xp.length;\r\n        uint256 s;\r\n        for (uint256 i = 0; i < numTokens; i++) {\r\n            s = s.add(xp[i]);\r\n        }\r\n        if (s == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 prevD;\r\n        uint256 d = s;\r\n        uint256 nA = a.mul(numTokens);\r\n\r\n        for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {\r\n            uint256 dP = d;\r\n            for (uint256 j = 0; j < numTokens; j++) {\r\n                dP = dP.mul(d).div(xp[j].mul(numTokens));\r\n                // If we were to protect the division loss we would have to keep the denominator separate\r\n                // and divide at the end. However this leads to overflow with large numTokens or/and D.\r\n                // dP = dP * D * D * D * ... overflow!\r\n            }\r\n            prevD = d;\r\n            d = nA.mul(s).div(A_PRECISION).add(dP.mul(numTokens)).mul(d).div(\r\n                nA.sub(A_PRECISION).mul(d).div(A_PRECISION).add(\r\n                    numTokens.add(1).mul(dP)\r\n                )\r\n            );\r\n            if (d.within1(prevD)) {\r\n                return d;\r\n            }\r\n        }\r\n\r\n        // Convergence should occur in 4 loops or less. If this is reached, there may be something wrong\r\n        // with the pool. If this were to occur repeatedly, LPs should withdraw via `removeLiquidity()`\r\n        // function which does not rely on D.\r\n        revert(\"D does not converge\");\r\n    }\r\n\r\n    /**\r\n     * @notice Get D, the StableSwap invariant, based on self Swap struct\r\n     * @param self Swap struct to read from\r\n     * @return The invariant, at the precision of the pool\r\n     */\r\n    function getD(Swap storage self) internal view returns (uint256) {\r\n        return getD(_xp(self), _getAPrecise(self));\r\n    }\r\n\r\n    /**\r\n     * @notice Given a set of balances and precision multipliers, return the\r\n     * precision-adjusted balances.\r\n     *\r\n     * @param balances an array of token balances, in their native precisions.\r\n     * These should generally correspond with pooled tokens.\r\n     *\r\n     * @param precisionMultipliers an array of multipliers, corresponding to\r\n     * the amounts in the balances array. When multiplied together they\r\n     * should yield amounts at the pool's precision.\r\n     *\r\n     * @return an array of amounts \"scaled\" to the pool's precision\r\n     */\r\n    function _xp(\r\n        uint256[] memory balances,\r\n        uint256[] memory precisionMultipliers\r\n    ) internal pure returns (uint256[] memory) {\r\n        uint256 numTokens = balances.length;\r\n        require(\r\n            numTokens == precisionMultipliers.length,\r\n            \"Balances must match multipliers\"\r\n        );\r\n        uint256[] memory xp = new uint256[](numTokens);\r\n        for (uint256 i = 0; i < numTokens; i++) {\r\n            xp[i] = balances[i].mul(precisionMultipliers[i]);\r\n        }\r\n        return xp;\r\n    }\r\n\r\n    /**\r\n     * @notice Return the precision-adjusted balances of all tokens in the pool\r\n     * @param self Swap struct to read from\r\n     * @param balances array of balances to scale\r\n     * @return balances array \"scaled\" to the pool's precision, allowing\r\n     * them to be more easily compared.\r\n     */\r\n    function _xp(Swap storage self, uint256[] memory balances)\r\n        internal\r\n        view\r\n        returns (uint256[] memory)\r\n    {\r\n        return _xp(balances, self.tokenPrecisionMultipliers);\r\n    }\r\n\r\n    /**\r\n     * @notice Return the precision-adjusted balances of all tokens in the pool\r\n     * @param self Swap struct to read from\r\n     * @return the pool balances \"scaled\" to the pool's precision, allowing\r\n     * them to be more easily compared.\r\n     */\r\n    function _xp(Swap storage self) internal view returns (uint256[] memory) {\r\n        return _xp(self.balances, self.tokenPrecisionMultipliers);\r\n    }\r\n\r\n    /**\r\n     * @notice Get the virtual price, to help calculate profit\r\n     * @param self Swap struct to read from\r\n     * @return the virtual price, scaled to precision of POOL_PRECISION_DECIMALS\r\n     */\r\n    function getVirtualPrice(Swap storage self)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 d = getD(_xp(self), _getAPrecise(self));\r\n        uint256 supply = self.lpToken.totalSupply();\r\n        if (supply > 0) {\r\n            return\r\n                d.mul(10**uint256(ERC20(self.lpToken).decimals())).div(supply);\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the new balances of the tokens given the indexes of the token\r\n     * that is swapped from (FROM) and the token that is swapped to (TO).\r\n     * This function is used as a helper function to calculate how much TO token\r\n     * the user should receive on swap.\r\n     *\r\n     * @param self Swap struct to read from\r\n     * @param tokenIndexFrom index of FROM token\r\n     * @param tokenIndexTo index of TO token\r\n     * @param x the new total amount of FROM token\r\n     * @param xp balances of the tokens in the pool\r\n     * @return the amount of TO token that should remain in the pool\r\n     */\r\n    function getY(\r\n        Swap storage self,\r\n        uint8 tokenIndexFrom,\r\n        uint8 tokenIndexTo,\r\n        uint256 x,\r\n        uint256[] memory xp\r\n    ) internal view returns (uint256) {\r\n        uint256 numTokens = self.pooledTokens.length;\r\n        require(\r\n            tokenIndexFrom != tokenIndexTo,\r\n            \"Can't compare token to itself\"\r\n        );\r\n        require(\r\n            tokenIndexFrom < numTokens && tokenIndexTo < numTokens,\r\n            \"Tokens must be in pool\"\r\n        );\r\n\r\n        uint256 a = _getAPrecise(self);\r\n        uint256 d = getD(xp, a);\r\n        uint256 c = d;\r\n        uint256 s;\r\n        uint256 nA = numTokens.mul(a);\r\n\r\n        uint256 _x;\r\n        for (uint256 i = 0; i < numTokens; i++) {\r\n            if (i == tokenIndexFrom) {\r\n                _x = x;\r\n            } else if (i != tokenIndexTo) {\r\n                _x = xp[i];\r\n            } else {\r\n                continue;\r\n            }\r\n            s = s.add(_x);\r\n            c = c.mul(d).div(_x.mul(numTokens));\r\n            // If we were to protect the division loss we would have to keep the denominator separate\r\n            // and divide at the end. However this leads to overflow with large numTokens or/and D.\r\n            // c = c * D * D * D * ... overflow!\r\n        }\r\n        c = c.mul(d).mul(A_PRECISION).div(nA.mul(numTokens));\r\n        uint256 b = s.add(d.mul(A_PRECISION).div(nA));\r\n        uint256 yPrev;\r\n        uint256 y = d;\r\n\r\n        // iterative approximation\r\n        for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {\r\n            yPrev = y;\r\n            y = y.mul(y).add(c).div(y.mul(2).add(b).sub(d));\r\n            if (y.within1(yPrev)) {\r\n                return y;\r\n            }\r\n        }\r\n        revert(\"Approximation did not converge\");\r\n    }\r\n\r\n    /**\r\n     * @notice Externally calculates a swap between two tokens.\r\n     * @param self Swap struct to read from\r\n     * @param tokenIndexFrom the token to sell\r\n     * @param tokenIndexTo the token to buy\r\n     * @param dx the number of tokens to sell. If the token charges a fee on transfers,\r\n     * use the amount that gets transferred after the fee.\r\n     * @return dy the number of tokens the user will get\r\n     */\r\n    function calculateSwap(\r\n        Swap storage self,\r\n        uint8 tokenIndexFrom,\r\n        uint8 tokenIndexTo,\r\n        uint256 dx\r\n    ) external view returns (uint256 dy) {\r\n        (dy, ) = _calculateSwap(self, tokenIndexFrom, tokenIndexTo, dx);\r\n    }\r\n\r\n    /**\r\n     * @notice Internally calculates a swap between two tokens.\r\n     *\r\n     * @dev The caller is expected to transfer the actual amounts (dx and dy)\r\n     * using the token contracts.\r\n     *\r\n     * @param self Swap struct to read from\r\n     * @param tokenIndexFrom the token to sell\r\n     * @param tokenIndexTo the token to buy\r\n     * @param dx the number of tokens to sell. If the token charges a fee on transfers,\r\n     * use the amount that gets transferred after the fee.\r\n     * @return dy the number of tokens the user will get\r\n     * @return dyFee the associated fee\r\n     */\r\n    function _calculateSwap(\r\n        Swap storage self,\r\n        uint8 tokenIndexFrom,\r\n        uint8 tokenIndexTo,\r\n        uint256 dx\r\n    ) internal view returns (uint256 dy, uint256 dyFee) {\r\n        uint256[] memory xp = _xp(self);\r\n        require(\r\n            tokenIndexFrom < xp.length && tokenIndexTo < xp.length,\r\n            \"Token index out of range\"\r\n        );\r\n        uint256 x = dx.mul(self.tokenPrecisionMultipliers[tokenIndexFrom]).add(\r\n            xp[tokenIndexFrom]\r\n        );\r\n        uint256 y = getY(self, tokenIndexFrom, tokenIndexTo, x, xp);\r\n        dy = xp[tokenIndexTo].sub(y).sub(1);\r\n        dyFee = dy.mul(self.swapFee).div(FEE_DENOMINATOR);\r\n        dy = dy.sub(dyFee).div(self.tokenPrecisionMultipliers[tokenIndexTo]);\r\n    }\r\n\r\n    /**\r\n     * @notice A simple method to calculate amount of each underlying\r\n     * tokens that is returned upon burning given amount of\r\n     * LP tokens\r\n     *\r\n     * @param account the address that is removing liquidity. required for withdraw fee calculation\r\n     * @param amount the amount of LP tokens that would to be burned on\r\n     * withdrawal\r\n     * @return array of amounts of tokens user will receive\r\n     */\r\n    function calculateRemoveLiquidity(\r\n        Swap storage self,\r\n        address account,\r\n        uint256 amount\r\n    ) external view returns (uint256[] memory) {\r\n        return _calculateRemoveLiquidity(self, account, amount);\r\n    }\r\n\r\n    function _calculateRemoveLiquidity(\r\n        Swap storage self,\r\n        address account,\r\n        uint256 amount\r\n    ) internal view returns (uint256[] memory) {\r\n        uint256 totalSupply = self.lpToken.totalSupply();\r\n        require(amount <= totalSupply, \"Cannot exceed total supply\");\r\n\r\n        uint256 feeAdjustedAmount = amount\r\n            .mul(\r\n                FEE_DENOMINATOR.sub(calculateCurrentWithdrawFee(self, account))\r\n            )\r\n            .div(FEE_DENOMINATOR);\r\n\r\n        uint256[] memory amounts = new uint256[](self.pooledTokens.length);\r\n\r\n        for (uint256 i = 0; i < self.pooledTokens.length; i++) {\r\n            amounts[i] = self.balances[i].mul(feeAdjustedAmount).div(\r\n                totalSupply\r\n            );\r\n        }\r\n        return amounts;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the fee that is applied when the given user withdraws.\r\n     * Withdraw fee decays linearly over 4 weeks.\r\n     * @param user address you want to calculate withdraw fee of\r\n     * @return current withdraw fee of the user\r\n     */\r\n    function calculateCurrentWithdrawFee(Swap storage self, address user)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 endTime = self.depositTimestamp[user].add(4 weeks);\r\n        if (endTime > block.timestamp) {\r\n            uint256 timeLeftover = endTime.sub(block.timestamp);\r\n            return\r\n                self\r\n                    .defaultWithdrawFee\r\n                    .mul(self.withdrawFeeMultiplier[user])\r\n                    .mul(timeLeftover)\r\n                    .div(4 weeks)\r\n                    .div(FEE_DENOMINATOR);\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * @notice A simple method to calculate prices from deposits or\r\n     * withdrawals, excluding fees but including slippage. This is\r\n     * helpful as an input into the various \"min\" parameters on calls\r\n     * to fight front-running\r\n     *\r\n     * @dev This shouldn't be used outside frontends for user estimates.\r\n     *\r\n     * @param self Swap struct to read from\r\n     * @param account address of the account depositing or withdrawing tokens\r\n     * @param amounts an array of token amounts to deposit or withdrawal,\r\n     * corresponding to pooledTokens. The amount should be in each\r\n     * pooled token's native precision. If a token charges a fee on transfers,\r\n     * use the amount that gets transferred after the fee.\r\n     * @param deposit whether this is a deposit or a withdrawal\r\n     * @return if deposit was true, total amount of lp token that will be minted and if\r\n     * deposit was false, total amount of lp token that will be burned\r\n     */\r\n    function calculateTokenAmount(\r\n        Swap storage self,\r\n        address account,\r\n        uint256[] calldata amounts,\r\n        bool deposit\r\n    ) external view returns (uint256) {\r\n        uint256 numTokens = self.pooledTokens.length;\r\n        uint256 a = _getAPrecise(self);\r\n        uint256 d0 = getD(_xp(self, self.balances), a);\r\n        uint256[] memory balances1 = self.balances;\r\n        for (uint256 i = 0; i < numTokens; i++) {\r\n            if (deposit) {\r\n                balances1[i] = balances1[i].add(amounts[i]);\r\n            } else {\r\n                balances1[i] = balances1[i].sub(\r\n                    amounts[i],\r\n                    \"Cannot withdraw more than available\"\r\n                );\r\n            }\r\n        }\r\n        uint256 d1 = getD(_xp(self, balances1), a);\r\n        uint256 totalSupply = self.lpToken.totalSupply();\r\n\r\n        if (deposit) {\r\n            return d1.sub(d0).mul(totalSupply).div(d0);\r\n        } else {\r\n            return\r\n                d0.sub(d1).mul(totalSupply).div(d0).mul(FEE_DENOMINATOR).div(\r\n                    FEE_DENOMINATOR.sub(\r\n                        calculateCurrentWithdrawFee(self, account)\r\n                    )\r\n                );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice return accumulated amount of admin fees of the token with given index\r\n     * @param self Swap struct to read from\r\n     * @param index Index of the pooled token\r\n     * @return admin balance in the token's precision\r\n     */\r\n    function getAdminBalance(Swap storage self, uint256 index)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        require(index < self.pooledTokens.length, \"Token index out of range\");\r\n        return\r\n            self.pooledTokens[index].balanceOf(address(this)).sub(\r\n                self.balances[index]\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @notice internal helper function to calculate fee per token multiplier used in\r\n     * swap fee calculations\r\n     * @param self Swap struct to read from\r\n     */\r\n    function _feePerToken(Swap storage self) internal view returns (uint256) {\r\n        return\r\n            self.swapFee.mul(self.pooledTokens.length).div(\r\n                self.pooledTokens.length.sub(1).mul(4)\r\n            );\r\n    }\r\n\r\n    /*** STATE MODIFYING FUNCTIONS ***/\r\n\r\n    /**\r\n     * @notice swap two tokens in the pool\r\n     * @param self Swap struct to read from and write to\r\n     * @param tokenIndexFrom the token the user wants to sell\r\n     * @param tokenIndexTo the token the user wants to buy\r\n     * @param dx the amount of tokens the user wants to sell\r\n     * @param minDy the min amount the user would like to receive, or revert.\r\n     * @return amount of token user received on swap\r\n     */\r\n    function swap(\r\n        Swap storage self,\r\n        uint8 tokenIndexFrom,\r\n        uint8 tokenIndexTo,\r\n        uint256 dx,\r\n        uint256 minDy\r\n    ) external returns (uint256) {\r\n        require(\r\n            dx <= self.pooledTokens[tokenIndexFrom].balanceOf(msg.sender),\r\n            \"Cannot swap more than you own\"\r\n        );\r\n\r\n        // Transfer tokens first to see if a fee was charged on transfer\r\n        uint256 beforeBalance = self.pooledTokens[tokenIndexFrom].balanceOf(\r\n            address(this)\r\n        );\r\n        self.pooledTokens[tokenIndexFrom].safeTransferFrom(\r\n            msg.sender,\r\n            address(this),\r\n            dx\r\n        );\r\n\r\n        // Use the actual transferred amount for AMM math\r\n        uint256 transferredDx = self\r\n            .pooledTokens[tokenIndexFrom]\r\n            .balanceOf(address(this))\r\n            .sub(beforeBalance);\r\n\r\n        (uint256 dy, uint256 dyFee) = _calculateSwap(\r\n            self,\r\n            tokenIndexFrom,\r\n            tokenIndexTo,\r\n            transferredDx\r\n        );\r\n        require(dy >= minDy, \"Swap didn't result in min tokens\");\r\n\r\n        uint256 dyAdminFee = dyFee.mul(self.adminFee).div(FEE_DENOMINATOR).div(\r\n            self.tokenPrecisionMultipliers[tokenIndexTo]\r\n        );\r\n\r\n        self.balances[tokenIndexFrom] = self.balances[tokenIndexFrom].add(\r\n            transferredDx\r\n        );\r\n        self.balances[tokenIndexTo] = self.balances[tokenIndexTo].sub(dy).sub(\r\n            dyAdminFee\r\n        );\r\n\r\n        self.pooledTokens[tokenIndexTo].safeTransfer(msg.sender, dy);\r\n\r\n        emit TokenSwap(\r\n            msg.sender,\r\n            transferredDx,\r\n            dy,\r\n            tokenIndexFrom,\r\n            tokenIndexTo\r\n        );\r\n\r\n        return dy;\r\n    }\r\n\r\n    /**\r\n     * @notice Add liquidity to the pool\r\n     * @param self Swap struct to read from and write to\r\n     * @param amounts the amounts of each token to add, in their native precision\r\n     * @param minToMint the minimum LP tokens adding this amount of liquidity\r\n     * should mint, otherwise revert. Handy for front-running mitigation\r\n     * @param merkleProof bytes32 array that will be used to prove the existence of the caller's address in the list of\r\n     * allowed addresses. If the pool is not in the guarded launch phase, this parameter will be ignored.\r\n     * @return amount of LP token user received\r\n     */\r\n    function addLiquidity(\r\n        Swap storage self,\r\n        uint256[] memory amounts,\r\n        uint256 minToMint,\r\n        bytes32[] calldata merkleProof\r\n    ) external returns (uint256) {\r\n        require(\r\n            amounts.length == self.pooledTokens.length,\r\n            \"Amounts must match pooled tokens\"\r\n        );\r\n\r\n        uint256[] memory fees = new uint256[](self.pooledTokens.length);\r\n\r\n        // current state\r\n        AddLiquidityInfo memory v = AddLiquidityInfo(0, 0, 0, 0);\r\n\r\n        if (self.lpToken.totalSupply() != 0) {\r\n            v.d0 = getD(self);\r\n        }\r\n        uint256[] memory newBalances = self.balances;\r\n\r\n        for (uint256 i = 0; i < self.pooledTokens.length; i++) {\r\n            require(\r\n                self.lpToken.totalSupply() != 0 || amounts[i] > 0,\r\n                \"Must supply all tokens in pool\"\r\n            );\r\n\r\n            // Transfer tokens first to see if a fee was charged on transfer\r\n            if (amounts[i] != 0) {\r\n                uint256 beforeBalance = self.pooledTokens[i].balanceOf(\r\n                    address(this)\r\n                );\r\n                self.pooledTokens[i].safeTransferFrom(\r\n                    msg.sender,\r\n                    address(this),\r\n                    amounts[i]\r\n                );\r\n\r\n                // Update the amounts[] with actual transfer amount\r\n                amounts[i] = self.pooledTokens[i].balanceOf(address(this)).sub(\r\n                    beforeBalance\r\n                );\r\n            }\r\n\r\n            newBalances[i] = self.balances[i].add(amounts[i]);\r\n        }\r\n\r\n        // invariant after change\r\n        v.preciseA = _getAPrecise(self);\r\n        v.d1 = getD(_xp(self, newBalances), v.preciseA);\r\n        require(v.d1 > v.d0, \"D should increase\");\r\n\r\n        // updated to reflect fees and calculate the user's LP tokens\r\n        v.d2 = v.d1;\r\n        if (self.lpToken.totalSupply() != 0) {\r\n            uint256 feePerToken = _feePerToken(self);\r\n            for (uint256 i = 0; i < self.pooledTokens.length; i++) {\r\n                uint256 idealBalance = v.d1.mul(self.balances[i]).div(v.d0);\r\n                fees[i] = feePerToken\r\n                    .mul(idealBalance.difference(newBalances[i]))\r\n                    .div(FEE_DENOMINATOR);\r\n                self.balances[i] = newBalances[i].sub(\r\n                    fees[i].mul(self.adminFee).div(FEE_DENOMINATOR)\r\n                );\r\n                newBalances[i] = newBalances[i].sub(fees[i]);\r\n            }\r\n            v.d2 = getD(_xp(self, newBalances), v.preciseA);\r\n        } else {\r\n            // the initial depositor doesn't pay fees\r\n            self.balances = newBalances;\r\n        }\r\n\r\n        uint256 toMint;\r\n        if (self.lpToken.totalSupply() == 0) {\r\n            toMint = v.d1;\r\n        } else {\r\n            toMint = v.d2.sub(v.d0).mul(self.lpToken.totalSupply()).div(v.d0);\r\n        }\r\n\r\n        require(toMint >= minToMint, \"Couldn't mint min requested\");\r\n\r\n        // mint the user's LP tokens\r\n        self.lpToken.mint(msg.sender, toMint, merkleProof);\r\n\r\n        emit AddLiquidity(\r\n            msg.sender,\r\n            amounts,\r\n            fees,\r\n            v.d1,\r\n            self.lpToken.totalSupply()\r\n        );\r\n\r\n        return toMint;\r\n    }\r\n\r\n    /**\r\n     * @notice Update the withdraw fee for `user`. If the user is currently\r\n     * not providing liquidity in the pool, sets to default value. If not, recalculate\r\n     * the starting withdraw fee based on the last deposit's time & amount relative\r\n     * to the new deposit.\r\n     *\r\n     * @param self Swap struct to read from and write to\r\n     * @param user address of the user depositing tokens\r\n     * @param toMint amount of pool tokens to be minted\r\n     */\r\n    function updateUserWithdrawFee(\r\n        Swap storage self,\r\n        address user,\r\n        uint256 toMint\r\n    ) external {\r\n        _updateUserWithdrawFee(self, user, toMint);\r\n    }\r\n\r\n    function _updateUserWithdrawFee(\r\n        Swap storage self,\r\n        address user,\r\n        uint256 toMint\r\n    ) internal {\r\n        // If token is transferred to address 0 (or burned), don't update the fee.\r\n        if (user == address(0)) {\r\n            return;\r\n        }\r\n        if (self.defaultWithdrawFee == 0) {\r\n            // If current fee is set to 0%, set multiplier to FEE_DENOMINATOR\r\n            self.withdrawFeeMultiplier[user] = FEE_DENOMINATOR;\r\n        } else {\r\n            // Otherwise, calculate appropriate discount based on last deposit amount\r\n            uint256 currentFee = calculateCurrentWithdrawFee(self, user);\r\n            uint256 currentBalance = self.lpToken.balanceOf(user);\r\n\r\n            // ((currentBalance * currentFee) + (toMint * defaultWithdrawFee)) * FEE_DENOMINATOR /\r\n            // ((toMint + currentBalance) * defaultWithdrawFee)\r\n            self.withdrawFeeMultiplier[user] = currentBalance\r\n                .mul(currentFee)\r\n                .add(toMint.mul(self.defaultWithdrawFee))\r\n                .mul(FEE_DENOMINATOR)\r\n                .div(toMint.add(currentBalance).mul(self.defaultWithdrawFee));\r\n        }\r\n        self.depositTimestamp[user] = block.timestamp;\r\n    }\r\n\r\n    /**\r\n     * @notice Burn LP tokens to remove liquidity from the pool.\r\n     * @dev Liquidity can always be removed, even when the pool is paused.\r\n     * @param self Swap struct to read from and write to\r\n     * @param amount the amount of LP tokens to burn\r\n     * @param minAmounts the minimum amounts of each token in the pool\r\n     * acceptable for this burn. Useful as a front-running mitigation\r\n     * @return amounts of tokens the user received\r\n     */\r\n    function removeLiquidity(\r\n        Swap storage self,\r\n        uint256 amount,\r\n        uint256[] calldata minAmounts\r\n    ) external returns (uint256[] memory) {\r\n        require(amount <= self.lpToken.balanceOf(msg.sender), \">LP.balanceOf\");\r\n        require(\r\n            minAmounts.length == self.pooledTokens.length,\r\n            \"minAmounts must match poolTokens\"\r\n        );\r\n\r\n        uint256[] memory amounts = _calculateRemoveLiquidity(\r\n            self,\r\n            msg.sender,\r\n            amount\r\n        );\r\n\r\n        for (uint256 i = 0; i < amounts.length; i++) {\r\n            require(amounts[i] >= minAmounts[i], \"amounts[i] < minAmounts[i]\");\r\n            self.balances[i] = self.balances[i].sub(amounts[i]);\r\n            self.pooledTokens[i].safeTransfer(msg.sender, amounts[i]);\r\n        }\r\n\r\n        self.lpToken.burnFrom(msg.sender, amount);\r\n\r\n        emit RemoveLiquidity(msg.sender, amounts, self.lpToken.totalSupply());\r\n\r\n        return amounts;\r\n    }\r\n\r\n    /**\r\n     * @notice Remove liquidity from the pool all in one token.\r\n     * @param self Swap struct to read from and write to\r\n     * @param tokenAmount the amount of the lp tokens to burn\r\n     * @param tokenIndex the index of the token you want to receive\r\n     * @param minAmount the minimum amount to withdraw, otherwise revert\r\n     * @return amount chosen token that user received\r\n     */\r\n    function removeLiquidityOneToken(\r\n        Swap storage self,\r\n        uint256 tokenAmount,\r\n        uint8 tokenIndex,\r\n        uint256 minAmount\r\n    ) external returns (uint256) {\r\n        uint256 totalSupply = self.lpToken.totalSupply();\r\n        uint256 numTokens = self.pooledTokens.length;\r\n        require(\r\n            tokenAmount <= self.lpToken.balanceOf(msg.sender),\r\n            \">LP.balanceOf\"\r\n        );\r\n        require(tokenIndex < numTokens, \"Token not found\");\r\n\r\n        uint256 dyFee;\r\n        uint256 dy;\r\n\r\n        (dy, dyFee) = calculateWithdrawOneToken(\r\n            self,\r\n            msg.sender,\r\n            tokenAmount,\r\n            tokenIndex\r\n        );\r\n\r\n        require(dy >= minAmount, \"dy < minAmount\");\r\n\r\n        self.balances[tokenIndex] = self.balances[tokenIndex].sub(\r\n            dy.add(dyFee.mul(self.adminFee).div(FEE_DENOMINATOR))\r\n        );\r\n        self.lpToken.burnFrom(msg.sender, tokenAmount);\r\n        self.pooledTokens[tokenIndex].safeTransfer(msg.sender, dy);\r\n\r\n        emit RemoveLiquidityOne(\r\n            msg.sender,\r\n            tokenAmount,\r\n            totalSupply,\r\n            tokenIndex,\r\n            dy\r\n        );\r\n\r\n        return dy;\r\n    }\r\n\r\n    /**\r\n     * @notice Remove liquidity from the pool, weighted differently than the\r\n     * pool's current balances.\r\n     *\r\n     * @param self Swap struct to read from and write to\r\n     * @param amounts how much of each token to withdraw\r\n     * @param maxBurnAmount the max LP token provider is willing to pay to\r\n     * remove liquidity. Useful as a front-running mitigation.\r\n     * @return actual amount of LP tokens burned in the withdrawal\r\n     */\r\n    function removeLiquidityImbalance(\r\n        Swap storage self,\r\n        uint256[] memory amounts,\r\n        uint256 maxBurnAmount\r\n    ) public returns (uint256) {\r\n        require(\r\n            amounts.length == self.pooledTokens.length,\r\n            \"Amounts should match pool tokens\"\r\n        );\r\n        require(\r\n            maxBurnAmount <= self.lpToken.balanceOf(msg.sender) &&\r\n                maxBurnAmount != 0,\r\n            \">LP.balanceOf\"\r\n        );\r\n\r\n        RemoveLiquidityImbalanceInfo memory v = RemoveLiquidityImbalanceInfo(\r\n            0,\r\n            0,\r\n            0,\r\n            0\r\n        );\r\n\r\n        uint256 tokenSupply = self.lpToken.totalSupply();\r\n        uint256 feePerToken = _feePerToken(self);\r\n\r\n        uint256[] memory balances1 = self.balances;\r\n\r\n        v.preciseA = _getAPrecise(self);\r\n        v.d0 = getD(_xp(self), v.preciseA);\r\n        for (uint256 i = 0; i < self.pooledTokens.length; i++) {\r\n            balances1[i] = balances1[i].sub(\r\n                amounts[i],\r\n                \"Cannot withdraw more than available\"\r\n            );\r\n        }\r\n        v.d1 = getD(_xp(self, balances1), v.preciseA);\r\n        uint256[] memory fees = new uint256[](self.pooledTokens.length);\r\n\r\n        for (uint256 i = 0; i < self.pooledTokens.length; i++) {\r\n            uint256 idealBalance = v.d1.mul(self.balances[i]).div(v.d0);\r\n            uint256 difference = idealBalance.difference(balances1[i]);\r\n            fees[i] = feePerToken.mul(difference).div(FEE_DENOMINATOR);\r\n            self.balances[i] = balances1[i].sub(\r\n                fees[i].mul(self.adminFee).div(FEE_DENOMINATOR)\r\n            );\r\n            balances1[i] = balances1[i].sub(fees[i]);\r\n        }\r\n\r\n        v.d2 = getD(_xp(self, balances1), v.preciseA);\r\n\r\n        uint256 tokenAmount = v.d0.sub(v.d2).mul(tokenSupply).div(v.d0);\r\n        require(tokenAmount != 0, \"Burnt amount cannot be zero\");\r\n        tokenAmount = tokenAmount.add(1).mul(FEE_DENOMINATOR).div(\r\n            FEE_DENOMINATOR.sub(calculateCurrentWithdrawFee(self, msg.sender))\r\n        );\r\n\r\n        require(tokenAmount <= maxBurnAmount, \"tokenAmount > maxBurnAmount\");\r\n\r\n        self.lpToken.burnFrom(msg.sender, tokenAmount);\r\n\r\n        for (uint256 i = 0; i < self.pooledTokens.length; i++) {\r\n            self.pooledTokens[i].safeTransfer(msg.sender, amounts[i]);\r\n        }\r\n\r\n        emit RemoveLiquidityImbalance(\r\n            msg.sender,\r\n            amounts,\r\n            fees,\r\n            v.d1,\r\n            tokenSupply.sub(tokenAmount)\r\n        );\r\n\r\n        return tokenAmount;\r\n    }\r\n\r\n    /**\r\n     * @notice withdraw all admin fees to a given address\r\n     * @param self Swap struct to withdraw fees from\r\n     * @param to Address to send the fees to\r\n     */\r\n    function withdrawAdminFees(Swap storage self, address to) external {\r\n        for (uint256 i = 0; i < self.pooledTokens.length; i++) {\r\n            IERC20 token = self.pooledTokens[i];\r\n            uint256 balance = token.balanceOf(address(this)).sub(\r\n                self.balances[i]\r\n            );\r\n            if (balance != 0) {\r\n                token.safeTransfer(to, balance);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the admin fee\r\n     * @dev adminFee cannot be higher than 100% of the swap fee\r\n     * @param self Swap struct to update\r\n     * @param newAdminFee new admin fee to be applied on future transactions\r\n     */\r\n    function setAdminFee(Swap storage self, uint256 newAdminFee) external {\r\n        require(newAdminFee <= MAX_ADMIN_FEE, \"Fee is too high\");\r\n        self.adminFee = newAdminFee;\r\n\r\n        emit NewAdminFee(newAdminFee);\r\n    }\r\n\r\n    /**\r\n     * @notice update the swap fee\r\n     * @dev fee cannot be higher than 1% of each swap\r\n     * @param self Swap struct to update\r\n     * @param newSwapFee new swap fee to be applied on future transactions\r\n     */\r\n    function setSwapFee(Swap storage self, uint256 newSwapFee) external {\r\n        require(newSwapFee <= MAX_SWAP_FEE, \"Fee is too high\");\r\n        self.swapFee = newSwapFee;\r\n\r\n        emit NewSwapFee(newSwapFee);\r\n    }\r\n\r\n    /**\r\n     * @notice update the default withdraw fee. This also affects deposits made in the past as well.\r\n     * @param self Swap struct to update\r\n     * @param newWithdrawFee new withdraw fee to be applied\r\n     */\r\n    function setDefaultWithdrawFee(Swap storage self, uint256 newWithdrawFee)\r\n        external\r\n    {\r\n        require(newWithdrawFee <= MAX_WITHDRAW_FEE, \"Fee is too high\");\r\n        self.defaultWithdrawFee = newWithdrawFee;\r\n\r\n        emit NewWithdrawFee(newWithdrawFee);\r\n    }\r\n\r\n    /**\r\n     * @notice Start ramping up or down A parameter towards given futureA_ and futureTime_\r\n     * Checks if the change is too rapid, and commits the new A value only when it falls under\r\n     * the limit range.\r\n     * @param self Swap struct to update\r\n     * @param futureA_ the new A to ramp towards\r\n     * @param futureTime_ timestamp when the new A should be reached\r\n     */\r\n    function rampA(\r\n        Swap storage self,\r\n        uint256 futureA_,\r\n        uint256 futureTime_\r\n    ) external {\r\n        require(\r\n            block.timestamp >= self.initialATime.add(1 days),\r\n            \"Wait 1 day before starting ramp\"\r\n        );\r\n        require(\r\n            futureTime_ >= block.timestamp.add(MIN_RAMP_TIME),\r\n            \"Insufficient ramp time\"\r\n        );\r\n        require(\r\n            futureA_ > 0 && futureA_ < MAX_A,\r\n            \"futureA_ must be > 0 and < MAX_A\"\r\n        );\r\n\r\n        uint256 initialAPrecise = _getAPrecise(self);\r\n        uint256 futureAPrecise = futureA_.mul(A_PRECISION);\r\n\r\n        if (futureAPrecise < initialAPrecise) {\r\n            require(\r\n                futureAPrecise.mul(MAX_A_CHANGE) >= initialAPrecise,\r\n                \"futureA_ is too small\"\r\n            );\r\n        } else {\r\n            require(\r\n                futureAPrecise <= initialAPrecise.mul(MAX_A_CHANGE),\r\n                \"futureA_ is too large\"\r\n            );\r\n        }\r\n\r\n        self.initialA = initialAPrecise;\r\n        self.futureA = futureAPrecise;\r\n        self.initialATime = block.timestamp;\r\n        self.futureATime = futureTime_;\r\n\r\n        emit RampA(\r\n            initialAPrecise,\r\n            futureAPrecise,\r\n            block.timestamp,\r\n            futureTime_\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Stops ramping A immediately. Once this function is called, rampA()\r\n     * cannot be called for another 24 hours\r\n     * @param self Swap struct to update\r\n     */\r\n    function stopRampA(Swap storage self) external {\r\n        require(self.futureATime > block.timestamp, \"Ramp is already stopped\");\r\n        uint256 currentA = _getAPrecise(self);\r\n\r\n        self.initialA = currentA;\r\n        self.futureA = currentA;\r\n        self.initialATime = block.timestamp;\r\n        self.futureATime = block.timestamp;\r\n\r\n        emit StopRampA(currentA, block.timestamp);\r\n    }\r\n}\r\n"
    },
    "contracts/guarded/Allowlist.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/cryptography/MerkleProof.sol\";\r\nimport \"../interfaces/IAllowlist.sol\";\r\n\r\n/**\r\n * @title Allowlist\r\n * @notice This contract is a registry holding information about how much each swap contract should\r\n * contain upto. Swap.sol will rely on this contract to determine whether the pool cap is reached and\r\n * also whether a user's deposit limit is reached.\r\n */\r\ncontract Allowlist is Ownable, IAllowlist {\r\n    using SafeMath for uint256;\r\n\r\n    // Represents the root node of merkle tree containing a list of eligible addresses\r\n    bytes32 public merkleRoot;\r\n    // Maps pool address -> maximum total supply\r\n    mapping(address => uint256) private poolCaps;\r\n    // Maps pool address -> maximum amount of pool token mintable per account\r\n    mapping(address => uint256) private accountLimits;\r\n    // Maps account address -> boolean value indicating whether it has been checked and verified against the merkle tree\r\n    mapping(address => bool) private verified;\r\n\r\n    event PoolCap(address indexed poolAddress, uint256 poolCap);\r\n    event PoolAccountLimit(address indexed poolAddress, uint256 accountLimit);\r\n    event NewMerkleRoot(bytes32 merkleRoot);\r\n\r\n    /**\r\n     * @notice Creates this contract and sets the PoolCap of 0x0 with uint256(0x54dd1e) for\r\n     * crude checking whether an address holds this contract.\r\n     * @param merkleRoot_ bytes32 that represent a merkle root node. This is generated off chain with the list of\r\n     * qualifying addresses.\r\n     */\r\n    constructor(bytes32 merkleRoot_) public {\r\n        merkleRoot = merkleRoot_;\r\n\r\n        // This value will be used as a way of crude checking whether an address holds this Allowlist contract\r\n        // Value 0x54dd1e has no inherent meaning other than it is arbitrary value that checks for\r\n        // user error.\r\n        poolCaps[address(0x0)] = uint256(0x54dd1e);\r\n        emit PoolCap(address(0x0), uint256(0x54dd1e));\r\n        emit NewMerkleRoot(merkleRoot_);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the max mintable amount of the lp token per account in given pool address.\r\n     * @param poolAddress address of the pool\r\n     * @return max mintable amount of the lp token per account\r\n     */\r\n    function getPoolAccountLimit(address poolAddress)\r\n        external\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return accountLimits[poolAddress];\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the maximum total supply of the pool token for the given pool address.\r\n     * @param poolAddress address of the pool\r\n     */\r\n    function getPoolCap(address poolAddress)\r\n        external\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return poolCaps[poolAddress];\r\n    }\r\n\r\n    /**\r\n     * @notice Returns true if the given account's existence has been verified against any of the past or\r\n     * the present merkle tree. Note that if it has been verified in the past, this function will return true\r\n     * even if the current merkle tree does not contain the account.\r\n     * @param account the address to check if it has been verified\r\n     * @return a boolean value representing whether the account has been verified in the past or the present merkle tree\r\n     */\r\n    function isAccountVerified(address account) external view returns (bool) {\r\n        return verified[account];\r\n    }\r\n\r\n    /**\r\n     * @notice Checks the existence of keccak256(account) as a node in the merkle tree inferred by the merkle root node\r\n     * stored in this contract. Pools should use this function to check if the given address qualifies for depositing.\r\n     * If the given account has already been verified with the correct merkleProof, this function will return true when\r\n     * merkleProof is empty. The verified status will be overwritten if the previously verified user calls this function\r\n     * with an incorrect merkleProof.\r\n     * @param account address to confirm its existence in the merkle tree\r\n     * @param merkleProof data that is used to prove the existence of given parameters. This is generated\r\n     * during the creation of the merkle tree. Users should retrieve this data off-chain.\r\n     * @return a boolean value that corresponds to whether the address with the proof has been verified in the past\r\n     * or if they exist in the current merkle tree.\r\n     */\r\n    function verifyAddress(address account, bytes32[] calldata merkleProof)\r\n        external\r\n        override\r\n        returns (bool)\r\n    {\r\n        if (merkleProof.length != 0) {\r\n            // Verify the account exists in the merkle tree via the MerkleProof library\r\n            bytes32 node = keccak256(abi.encodePacked(account));\r\n            if (MerkleProof.verify(merkleProof, merkleRoot, node)) {\r\n                verified[account] = true;\r\n                return true;\r\n            }\r\n        }\r\n        return verified[account];\r\n    }\r\n\r\n    // ADMIN FUNCTIONS\r\n\r\n    /**\r\n     * @notice Sets the account limit of allowed deposit amounts for the given pool\r\n     * @param poolAddress address of the pool\r\n     * @param accountLimit the max number of the pool token a single user can mint\r\n     */\r\n    function setPoolAccountLimit(address poolAddress, uint256 accountLimit)\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(poolAddress != address(0x0), \"0x0 is not a pool address\");\r\n        accountLimits[poolAddress] = accountLimit;\r\n        emit PoolAccountLimit(poolAddress, accountLimit);\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the max total supply of LPToken for the given pool address\r\n     * @param poolAddress address of the pool\r\n     * @param poolCap the max total supply of the pool token\r\n     */\r\n    function setPoolCap(address poolAddress, uint256 poolCap)\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(poolAddress != address(0x0), \"0x0 is not a pool address\");\r\n        poolCaps[poolAddress] = poolCap;\r\n        emit PoolCap(poolAddress, poolCap);\r\n    }\r\n\r\n    /**\r\n     * @notice Updates the merkle root that is stored in this contract. This can only be called by\r\n     * the owner. If more addresses are added to the list, a new merkle tree and a merkle root node should be generated,\r\n     * and merkleRoot should be updated accordingly.\r\n     * @param merkleRoot_ a new merkle root node that contains a list of deposit allowed addresses\r\n     */\r\n    function updateMerkleRoot(bytes32 merkleRoot_) external onlyOwner {\r\n        merkleRoot = merkleRoot_;\r\n        emit NewMerkleRoot(merkleRoot_);\r\n    }\r\n}\r\n"
    },
    "contracts/guarded/LPTokenGuarded.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\n// https://etherscan.io/address/0xC28DF698475dEC994BE00C9C9D8658A548e6304F#code\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\nimport \"../interfaces/ISwapGuarded.sol\";\r\n\r\n/**\r\n * @title Liquidity Provider Token\r\n * @notice This token is an ERC20 detailed token with added capability to be minted by the owner.\r\n * It is used to represent user's shares when providing liquidity to swap contracts.\r\n */\r\ncontract LPTokenGuarded is ERC20Burnable, Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    // Address of the swap contract that owns this LP token. When a user adds liquidity to the swap contract,\r\n    // they receive a proportionate amount of this LPToken.\r\n    ISwapGuarded public swap;\r\n\r\n    // Maps user account to total number of LPToken minted by them. Used to limit minting during guarded release phase\r\n    mapping(address => uint256) public mintedAmounts;\r\n\r\n    /**\r\n     * @notice Deploys LPToken contract with given name, symbol, and decimals\r\n     * @dev the caller of this constructor will become the owner of this contract\r\n     * @param name_ name of this token\r\n     * @param symbol_ symbol of this token\r\n     * @param decimals_ number of decimals this token will be based on\r\n     */\r\n    constructor(\r\n        string memory name_,\r\n        string memory symbol_,\r\n        uint8 decimals_\r\n    ) public ERC20(name_, symbol_) {\r\n        _setupDecimals(decimals_);\r\n        swap = ISwapGuarded(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @notice Mints the given amount of LPToken to the recipient. During the guarded release phase, the total supply\r\n     * and the maximum number of the tokens that a single account can mint are limited.\r\n     * @dev only owner can call this mint function\r\n     * @param recipient address of account to receive the tokens\r\n     * @param amount amount of tokens to mint\r\n     * @param merkleProof the bytes32 array data that is used to prove recipient's address exists in the merkle tree\r\n     * stored in the allowlist contract. If the pool is not guarded, this parameter is ignored.\r\n     */\r\n    function mint(\r\n        address recipient,\r\n        uint256 amount,\r\n        bytes32[] calldata merkleProof\r\n    ) external onlyOwner {\r\n        require(amount != 0, \"amount == 0\");\r\n\r\n        // If the pool is in the guarded launch phase, the following checks are done to restrict deposits.\r\n        //   1. Check if the given merkleProof corresponds to the recipient's address in the merkle tree stored in the\r\n        //      allowlist contract. If the account has been already verified, merkleProof is ignored.\r\n        //   2. Limit the total number of this LPToken minted to recipient as defined by the allowlist contract.\r\n        //   3. Limit the total supply of this LPToken as defined by the allowlist contract.\r\n        if (swap.isGuarded()) {\r\n            IAllowlist allowlist = swap.getAllowlist();\r\n            require(\r\n                allowlist.verifyAddress(recipient, merkleProof),\r\n                \"Invalid merkle proof\"\r\n            );\r\n            uint256 totalMinted = mintedAmounts[recipient].add(amount);\r\n            require(\r\n                totalMinted <= allowlist.getPoolAccountLimit(address(swap)),\r\n                \"account deposit limit\"\r\n            );\r\n            require(\r\n                totalSupply().add(amount) <=\r\n                    allowlist.getPoolCap(address(swap)),\r\n                \"pool total supply limit\"\r\n            );\r\n            mintedAmounts[recipient] = totalMinted;\r\n        }\r\n        _mint(recipient, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Overrides ERC20._beforeTokenTransfer() which get called on every transfers including\r\n     * minting and burning. This ensures that swap.updateUserWithdrawFees are called everytime.\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal override(ERC20) {\r\n        super._beforeTokenTransfer(from, to, amount);\r\n        swap.updateUserWithdrawFee(to, amount);\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/Context.sol\";\nimport \"./ERC20.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n    using SafeMath for uint256;\n\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, \"ERC20: burn amount exceeds allowance\");\n\n        _approve(account, _msgSender(), decreasedAllowance);\n        _burn(account, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/cryptography/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle trees (hash trees),\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        bytes32 computedHash = leaf;\n\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n\n            if (computedHash <= proofElement) {\n                // Hash(current computed hash + current element of the proof)\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\n            } else {\n                // Hash(current element of the proof + current computed hash)\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\n            }\n        }\n\n        // Check if the computed hash (root) is equal to the provided root\n        return computedHash == root;\n    }\n}\n"
    },
    "contracts/interfaces/IMetaSwapDeposit.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"./ISwap.sol\";\r\nimport \"./IMetaSwap.sol\";\r\n\r\ninterface IMetaSwapDeposit {\r\n    function initialize(\r\n        ISwap _baseSwap,\r\n        IMetaSwap _metaSwap,\r\n        IERC20 _metaLPToken\r\n    ) external;\r\n}\r\n"
    },
    "contracts/permissionless/PermissionlessDeployer.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\r\nimport \"../interfaces/ISwap.sol\";\r\nimport \"../interfaces/IMetaSwap.sol\";\r\nimport \"../interfaces/IMetaSwapDeposit.sol\";\r\nimport \"../interfaces/IPoolRegistry.sol\";\r\nimport \"../interfaces/IMasterRegistry.sol\";\r\n\r\n/**\r\n * @title PermissionlessDeployer\r\n * @notice Allows for anyone to indepentantly deploy pools and meta pools of given tokens. A user will set\r\n * custom parameters for the pool such as the trading/admin fees, as well as the a-parameter.\r\n *\r\n * Ownership of the pools are given to the deploying address. kinesis will collect 50% of the trading fees earned\r\n * by the pool.\r\n */\r\ncontract PermissionlessDeployer is AccessControl {\r\n    IMasterRegistry public immutable MASTER_REGISTRY;\r\n    bytes32 public constant POOL_REGISTRY_NAME =\r\n        0x506f6f6c52656769737472790000000000000000000000000000000000000000;\r\n\r\n    /// @notice Role responsible for managing target addresses\r\n    bytes32 public constant kinesis_MANAGER_ROLE =\r\n        keccak256(\"kinesis_MANAGER_ROLE\");\r\n\r\n    address public targetLPToken;\r\n    address public targetSwap;\r\n    address public targetMetaSwap;\r\n    address public targetMetaSwapDeposit;\r\n    string public constant LP_TOKEN_NAME0 = \"kinesis \";\r\n    string public constant LP_TOKEN_NAME1 = \" LP Token\";\r\n\r\n    IPoolRegistry public poolRegistryCached;\r\n\r\n    /**\r\n     * @notice Emmited when a new pool is deployed\r\n     * @param deployer address of the deployer\r\n     * @param swapAddress address of the deployed pool\r\n     * @param pooledTokens, array of addresses of the tokens in the pool\r\n     */\r\n    event NewSwapPool(\r\n        address indexed deployer,\r\n        address swapAddress,\r\n        IERC20[] pooledTokens\r\n    );\r\n\r\n    event NewClone(address indexed target, address cloneAddress);\r\n\r\n    /**\r\n     * @notice Emmited when the pool registry cache is updated\r\n     * @param poolRegistry address of the current kinesis Pool Registry\r\n     */\r\n    event PoolRegistryUpdated(address indexed poolRegistry);\r\n    event TargetLPTokenUpdated(address indexed target);\r\n    event TargetSwapUpdated(address indexed target);\r\n    event TargetMetaSwapUpdated(address indexed target);\r\n    event TargetMetaSwapDepositUpdated(address indexed target);\r\n\r\n    struct DeploySwapInput {\r\n        bytes32 poolName; // name of the pool\r\n        IERC20[] tokens; // array of addresses of the tokens in the pool\r\n        uint8[] decimals; // array of decimals of the tokens in the pool\r\n        string lpTokenSymbol; // symbol of the LPToken\r\n        uint256 a; // a-parameter of the pool\r\n        uint256 fee; // trading fee of the pool\r\n        uint256 adminFee; // admin fee of the pool\r\n        address owner; // owner address of the pool\r\n        uint8 typeOfAsset; // USD/BTC/ETH/OTHER\r\n    }\r\n\r\n    struct DeployMetaSwapInput {\r\n        bytes32 poolName; // name of the pool\r\n        IERC20[] tokens; // array of addresses of the tokens in the pool\r\n        uint8[] decimals; // array of decimals of the tokens in the pool\r\n        string lpTokenSymbol; // symbol of the LPToken\r\n        uint256 a; // a-parameter of the pool\r\n        uint256 fee; // trading fee of the pool\r\n        uint256 adminFee; // admin fee of the pool\r\n        address baseSwap; // address of the basepool\r\n        address owner; // owner address of the pool\r\n        uint8 typeOfAsset; // USD/BTC/ETH/OTHER\r\n    }\r\n\r\n    constructor(\r\n        address admin,\r\n        address _masterRegistry,\r\n        address _targetLPToken,\r\n        address _targetSwap,\r\n        address _targetMetaSwap,\r\n        address _targetMetaSwapDeposit\r\n    ) public payable {\r\n        require(admin != address(0), \"admin == 0\");\r\n        require(_masterRegistry != address(0), \"masterRegistry == 0\");\r\n\r\n        _setupRole(DEFAULT_ADMIN_ROLE, admin);\r\n        _setupRole(kinesis_MANAGER_ROLE, msg.sender);\r\n\r\n        _setTargetLPToken(_targetLPToken);\r\n        _setTargetSwap(_targetSwap);\r\n        _setTargetMetaSwap(_targetMetaSwap);\r\n        _setTargetMetaSwapDeposit(_targetMetaSwapDeposit);\r\n\r\n        MASTER_REGISTRY = IMasterRegistry(_masterRegistry);\r\n        _updatePoolRegistryCache(_masterRegistry);\r\n    }\r\n\r\n    modifier onlyManager() {\r\n        require(hasRole(kinesis_MANAGER_ROLE, msg.sender), \"only manager\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Uses openzeppelin's clone mechanism to clone an existing a pool for cheaper deployments.\r\n     * @param target the address of the target pool to be cloned\r\n     * @return newClone an address of the cloned pool\r\n     */\r\n    function clone(address target) public payable returns (address newClone) {\r\n        newClone = Clones.clone(target);\r\n        emit NewClone(target, newClone);\r\n    }\r\n\r\n    /**\r\n     * @notice Deploys a new pool, adds an entry in the kinesis Pool Registry.\r\n     * @param input, a struct containing the input parameters for the pool to be deployed,\r\n     * must include a unique pool name.\r\n     * @return deployedSwap the address of the deployed pool.\r\n     */\r\n\r\n    function deploySwap(DeploySwapInput memory input)\r\n        external\r\n        payable\r\n        returns (address deployedSwap)\r\n    {\r\n        require(\r\n            poolRegistryCached.poolsIndexOfNamePlusOne(input.poolName) == 0,\r\n            \"pool name already exists\"\r\n        );\r\n\r\n        address swapClone = clone(targetSwap);\r\n\r\n        ISwap(swapClone).initialize(\r\n            input.tokens,\r\n            input.decimals,\r\n            string(\r\n                abi.encodePacked(\r\n                    LP_TOKEN_NAME0,\r\n                    input.lpTokenSymbol,\r\n                    LP_TOKEN_NAME1\r\n                )\r\n            ),\r\n            input.lpTokenSymbol,\r\n            input.a,\r\n            input.fee,\r\n            input.adminFee,\r\n            targetLPToken\r\n        );\r\n        Ownable(swapClone).transferOwnership(input.owner);\r\n        (, , , , , , address lpToken) = ISwap(swapClone).swapStorage();\r\n\r\n        IPoolRegistry.PoolData memory poolData = IPoolRegistry.PoolData({\r\n            poolAddress: swapClone,\r\n            lpToken: lpToken,\r\n            typeOfAsset: input.typeOfAsset,\r\n            poolName: input.poolName,\r\n            targetAddress: targetSwap,\r\n            tokens: input.tokens,\r\n            underlyingTokens: new IERC20[](0),\r\n            basePoolAddress: address(0),\r\n            metaSwapDepositAddress: address(0),\r\n            iskinesisApproved: false,\r\n            isRemoved: false,\r\n            isGuarded: false\r\n        });\r\n\r\n        emit NewSwapPool(msg.sender, swapClone, input.tokens);\r\n\r\n        poolRegistryCached.addCommunityPool(poolData);\r\n        return swapClone;\r\n    }\r\n\r\n    /**\r\n     * @notice Deploys a new meta pool.\r\n     * @param input, a DeployMetaSwapInput struct containing the input parameters for the meta pool.\r\n     */\r\n    function deployMetaSwap(DeployMetaSwapInput memory input)\r\n        external\r\n        payable\r\n        returns (address deployedMetaSwap, address deployedMetaSwapDeposit)\r\n    {\r\n        require(\r\n            poolRegistryCached.poolsIndexOfNamePlusOne(input.poolName) == 0,\r\n            \"pool name already exists\"\r\n        );\r\n\r\n        deployedMetaSwap = clone(targetMetaSwap);\r\n        IMetaSwap(deployedMetaSwap).initializeMetaSwap(\r\n            input.tokens,\r\n            input.decimals,\r\n            string(\r\n                abi.encodePacked(\r\n                    LP_TOKEN_NAME0,\r\n                    input.lpTokenSymbol,\r\n                    LP_TOKEN_NAME1\r\n                )\r\n            ),\r\n            input.lpTokenSymbol,\r\n            input.a,\r\n            input.fee,\r\n            input.adminFee,\r\n            targetLPToken,\r\n            ISwap(input.baseSwap)\r\n        );\r\n        (, , , , , , address lpToken) = ISwap(deployedMetaSwap).swapStorage();\r\n        Ownable(deployedMetaSwap).transferOwnership(input.owner);\r\n\r\n        deployedMetaSwapDeposit = clone(targetMetaSwapDeposit);\r\n        IMetaSwapDeposit(deployedMetaSwapDeposit).initialize(\r\n            ISwap(input.baseSwap),\r\n            IMetaSwap(deployedMetaSwap),\r\n            IERC20(lpToken)\r\n        );\r\n\r\n        IERC20[] memory baseTokens = poolRegistryCached.getTokens(\r\n            input.baseSwap\r\n        ); // revert if baseSwap is not registered\r\n        IERC20[] memory underlyingTokens = new IERC20[](\r\n            input.tokens.length - 1 + baseTokens.length\r\n        );\r\n        uint256 metaLPTokenIndex = input.tokens.length - 1;\r\n        for (uint256 i = 0; i < metaLPTokenIndex; i++) {\r\n            underlyingTokens[i] = input.tokens[i];\r\n        }\r\n        for (uint256 i = metaLPTokenIndex; i < underlyingTokens.length; i++) {\r\n            underlyingTokens[i] = baseTokens[i - metaLPTokenIndex];\r\n        }\r\n\r\n        IPoolRegistry.PoolData memory poolData = IPoolRegistry.PoolData({\r\n            poolAddress: deployedMetaSwap,\r\n            lpToken: lpToken,\r\n            typeOfAsset: input.typeOfAsset,\r\n            poolName: input.poolName,\r\n            targetAddress: targetSwap,\r\n            tokens: input.tokens,\r\n            underlyingTokens: underlyingTokens,\r\n            basePoolAddress: input.baseSwap,\r\n            metaSwapDepositAddress: deployedMetaSwapDeposit,\r\n            iskinesisApproved: false,\r\n            isRemoved: false,\r\n            isGuarded: false\r\n        });\r\n\r\n        emit NewSwapPool(msg.sender, deployedMetaSwap, input.tokens);\r\n        emit NewSwapPool(msg.sender, deployedMetaSwapDeposit, underlyingTokens);\r\n\r\n        poolRegistryCached.addCommunityPool(poolData);\r\n    }\r\n\r\n    /**\r\n     * @notice Updates cached address of the pool registry **should be onlymanager?\r\n     */\r\n    function updatePoolRegistryCache() external {\r\n        _updatePoolRegistryCache(address(MASTER_REGISTRY));\r\n    }\r\n\r\n    function _updatePoolRegistryCache(address masterRegistry) internal {\r\n        poolRegistryCached = IPoolRegistry(\r\n            IMasterRegistry(masterRegistry).resolveNameToLatestAddress(\r\n                POOL_REGISTRY_NAME\r\n            )\r\n        );\r\n    }\r\n\r\n    function setTargetLPToken(address _targetLPToken)\r\n        external\r\n        payable\r\n        onlyManager\r\n    {\r\n        _setTargetLPToken(_targetLPToken);\r\n    }\r\n\r\n    function _setTargetLPToken(address _targetLPToken) internal {\r\n        require(\r\n            address(_targetLPToken) != address(0),\r\n            \"Target LPToken cannot be 0\"\r\n        );\r\n        targetLPToken = _targetLPToken;\r\n        emit TargetLPTokenUpdated(_targetLPToken);\r\n    }\r\n\r\n    function setTargetSwap(address _targetSwap) external payable onlyManager {\r\n        _setTargetSwap(_targetSwap);\r\n    }\r\n\r\n    function _setTargetSwap(address _targetSwap) internal {\r\n        require(address(_targetSwap) != address(0), \"Target Swap cannot be 0\");\r\n        targetSwap = _targetSwap;\r\n        emit TargetSwapUpdated(_targetSwap);\r\n    }\r\n\r\n    function setTargetMetaSwap(address _targetMetaSwap)\r\n        public\r\n        payable\r\n        onlyManager\r\n    {\r\n        _setTargetMetaSwap(_targetMetaSwap);\r\n    }\r\n\r\n    function _setTargetMetaSwap(address _targetMetaSwap) internal {\r\n        require(\r\n            address(_targetMetaSwap) != address(0),\r\n            \"Target MetaSwap cannot be 0\"\r\n        );\r\n        targetMetaSwap = _targetMetaSwap;\r\n        emit TargetMetaSwapUpdated(_targetMetaSwap);\r\n    }\r\n\r\n    function setTargetMetaSwapDeposit(address _targetMetaSwapDeposit)\r\n        external\r\n        payable\r\n        onlyManager\r\n    {\r\n        _setTargetMetaSwapDeposit(_targetMetaSwapDeposit);\r\n    }\r\n\r\n    function _setTargetMetaSwapDeposit(address _targetMetaSwapDeposit)\r\n        internal\r\n    {\r\n        require(\r\n            address(_targetMetaSwapDeposit) != address(0),\r\n            \"Target MetaSwapDeposit cannot be 0\"\r\n        );\r\n        targetMetaSwapDeposit = _targetMetaSwapDeposit;\r\n        emit TargetMetaSwapDepositUpdated(_targetMetaSwapDeposit);\r\n    }\r\n}\r\n"
    },
    "contracts/SwapMigrator.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"./interfaces/ISwap.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\r\n\r\n/**\r\n * @title SwapMigrator\r\n * @notice This contract is responsible for migrating old USD pool liquidity to the new ones.\r\n * Users can use this contract to remove their liquidity from the old pools and add them to the new\r\n * ones with a single transaction.\r\n */\r\ncontract SwapMigrator {\r\n    using SafeERC20 for IERC20;\r\n\r\n    struct MigrationData {\r\n        address oldPoolAddress;\r\n        IERC20 oldPoolLPTokenAddress;\r\n        address newPoolAddress;\r\n        IERC20 newPoolLPTokenAddress;\r\n        IERC20[] underlyingTokens;\r\n    }\r\n\r\n    MigrationData public usdPoolMigrationData;\r\n    address public owner;\r\n\r\n    uint256 private constant MAX_UINT256 = 2**256 - 1;\r\n\r\n    /**\r\n     * @notice Sets the storage variables and approves tokens to be used by the old and new swap contracts\r\n     * @param usdData_ MigrationData struct with information about old and new USD pools\r\n     * @param owner_ owner that is allowed to call the `rescue()` function\r\n     */\r\n    constructor(MigrationData memory usdData_, address owner_) public {\r\n        // Approve old USD LP Token to be used by the old USD pool\r\n        usdData_.oldPoolLPTokenAddress.approve(\r\n            usdData_.oldPoolAddress,\r\n            MAX_UINT256\r\n        );\r\n\r\n        // Approve USD tokens to be used by the new USD pool\r\n        for (uint256 i = 0; i < usdData_.underlyingTokens.length; i++) {\r\n            usdData_.underlyingTokens[i].safeApprove(\r\n                usdData_.newPoolAddress,\r\n                MAX_UINT256\r\n            );\r\n        }\r\n\r\n        // Set storage variables\r\n        usdPoolMigrationData = usdData_;\r\n        owner = owner_;\r\n    }\r\n\r\n    /**\r\n     * @notice Migrates old USD pool's LPToken to the new pool\r\n     * @param amount Amount of old LPToken to migrate\r\n     * @param minAmount Minimum amount of new LPToken to receive\r\n     */\r\n    function migrateUSDPool(uint256 amount, uint256 minAmount)\r\n        external\r\n        returns (uint256)\r\n    {\r\n        // Transfer old LP token from the caller\r\n        usdPoolMigrationData.oldPoolLPTokenAddress.safeTransferFrom(\r\n            msg.sender,\r\n            address(this),\r\n            amount\r\n        );\r\n\r\n        // Remove liquidity from the old pool and add them to the new pool\r\n        uint256[] memory amounts = ISwap(usdPoolMigrationData.oldPoolAddress)\r\n            .removeLiquidity(\r\n                amount,\r\n                new uint256[](usdPoolMigrationData.underlyingTokens.length),\r\n                MAX_UINT256\r\n            );\r\n        uint256 mintedAmount = ISwap(usdPoolMigrationData.newPoolAddress)\r\n            .addLiquidity(amounts, minAmount, MAX_UINT256);\r\n\r\n        // Transfer new LP Token to the caller\r\n        usdPoolMigrationData.newPoolLPTokenAddress.safeTransfer(\r\n            msg.sender,\r\n            mintedAmount\r\n        );\r\n        return mintedAmount;\r\n    }\r\n\r\n    /**\r\n     * @notice Rescues any token that may be sent to this contract accidentally.\r\n     * @param token Amount of old LPToken to migrate\r\n     * @param to Minimum amount of new LPToken to receive\r\n     */\r\n    function rescue(IERC20 token, address to) external {\r\n        require(msg.sender == owner, \"is not owner\");\r\n        token.safeTransfer(to, token.balanceOf(address(this)));\r\n    }\r\n}\r\n"
    },
    "contracts/StakeableTokenWrapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\n// Generalized and adapted from https://github.com/k06a/Unipool 🙇\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\r\n\r\n/**\r\n * @title StakeableTokenWrapper\r\n * @notice A wrapper for an ERC-20 that can be staked and withdrawn.\r\n * @dev In this contract, staked tokens don't do anything- instead other\r\n * contracts can inherit from this one to add functionality.\r\n */\r\ncontract StakeableTokenWrapper {\r\n    using SafeERC20 for IERC20;\r\n    using SafeMath for uint256;\r\n\r\n    uint256 public totalSupply;\r\n    IERC20 public stakedToken;\r\n    mapping(address => uint256) private _balances;\r\n\r\n    event Staked(address indexed user, uint256 amount);\r\n    event Withdrawn(address indexed user, uint256 amount);\r\n\r\n    /**\r\n     * @notice Creates a new StakeableTokenWrapper with given `_stakedToken` address\r\n     * @param _stakedToken address of a token that will be used to stake\r\n     */\r\n    constructor(IERC20 _stakedToken) public {\r\n        stakedToken = _stakedToken;\r\n    }\r\n\r\n    /**\r\n     * @notice Read how much `account` has staked in this contract\r\n     * @param account address of an account\r\n     * @return amount of total staked ERC20(this.stakedToken) by `account`\r\n     */\r\n    function balanceOf(address account) external view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @notice Stakes given `amount` in this contract\r\n     * @param amount amount of ERC20(this.stakedToken) to stake\r\n     */\r\n    function stake(uint256 amount) external {\r\n        require(amount != 0, \"amount == 0\");\r\n        totalSupply = totalSupply.add(amount);\r\n        _balances[msg.sender] = _balances[msg.sender].add(amount);\r\n        stakedToken.safeTransferFrom(msg.sender, address(this), amount);\r\n        emit Staked(msg.sender, amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraws given `amount` from this contract\r\n     * @param amount amount of ERC20(this.stakedToken) to withdraw\r\n     */\r\n    function withdraw(uint256 amount) external {\r\n        totalSupply = totalSupply.sub(amount);\r\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\r\n        stakedToken.safeTransfer(msg.sender, amount);\r\n        emit Withdrawn(msg.sender, amount);\r\n    }\r\n}\r\n"
    },
    "contracts/libraries/SwapCalculator.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\nimport \"../MathUtils.sol\";\r\nimport \"../interfaces/ISwap.sol\";\r\nimport \"../helper/BaseBoringBatchable.sol\";\r\n\r\ninterface IERC20Decimals {\r\n    function decimals() external returns (uint8);\r\n}\r\n\r\n/**\r\n * @title SwapCalculator\r\n * @notice A contract to help calculate exact input and output amounts for a swap. Supports pools with ISwap interfaces.\r\n * Additionally includes functions to calculate with arbitrary balances, A parameter, and swap fee.\r\n */\r\ncontract SwapCalculator is BaseBoringBatchable {\r\n    using SafeMath for uint256;\r\n    using MathUtils for uint256;\r\n\r\n    // Constant values\r\n    uint256 private constant BALANCE_PRECISION = 1e18;\r\n    uint256 private constant BALANCE_DECIMALS = 18;\r\n    uint256 private constant A_PRECISION = 100;\r\n    uint256 private constant MAX_LOOP_LIMIT = 256;\r\n    uint256 private constant MAX_TOKENS_LENGTH = 8;\r\n    uint256 private constant FEE_DENOMINATOR = 10**10;\r\n\r\n    mapping(address => uint256[]) public storedDecimals;\r\n\r\n    /**\r\n     * @notice Calculate the expected output amount for given pool, indexes, and input amount\r\n     * @param pool address of a pool contract that implements ISwap\r\n     * @param inputIndex index of the input token in the pool\r\n     * @param outputIndex index of the output token in the pool\r\n     * @param inputAmount amount of input token to swap\r\n     * @return outputAmount expected output amount\r\n     */\r\n    function calculateSwapOutput(\r\n        address pool,\r\n        uint256 inputIndex,\r\n        uint256 outputIndex,\r\n        uint256 inputAmount\r\n    ) external view returns (uint256 outputAmount) {\r\n        outputAmount = ISwap(pool).calculateSwap(\r\n            uint8(inputIndex),\r\n            uint8(outputIndex),\r\n            inputAmount\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the expected input amount for given pool, indexes, and out amount\r\n     * @param pool address of a pool contract that implements ISwap\r\n     * @param inputIndex index of the input token in the pool\r\n     * @param outputIndex index of the output token in the pool\r\n     * @param outputAmount desired amount of output token to receive on swap\r\n     * @return inputAmount expected input amount\r\n     */\r\n    function calculateSwapInput(\r\n        address pool,\r\n        uint256 inputIndex,\r\n        uint256 outputIndex,\r\n        uint256 outputAmount\r\n    ) external view returns (uint256 inputAmount) {\r\n        uint256[] memory decimalsArr = storedDecimals[pool];\r\n        require(decimalsArr.length > 0, \"Must call addPool() first\");\r\n\r\n        uint256[] memory balances = new uint256[](decimalsArr.length);\r\n        for (uint256 i = 0; i < decimalsArr.length; i++) {\r\n            uint256 multiplier = 10**BALANCE_DECIMALS.sub(decimalsArr[i]);\r\n            balances[i] = ISwap(pool).getTokenBalance(uint8(i)).mul(multiplier);\r\n        }\r\n        outputAmount = outputAmount.mul(\r\n            10**BALANCE_DECIMALS.sub(decimalsArr[outputIndex])\r\n        );\r\n\r\n        (, , , , uint256 swapFee, , ) = ISwap(pool).swapStorage();\r\n\r\n        inputAmount = calculateSwapInputCustom(\r\n            balances,\r\n            ISwap(pool).getAPrecise(),\r\n            swapFee,\r\n            inputIndex,\r\n            outputIndex,\r\n            outputAmount\r\n        ).div(10**BALANCE_DECIMALS.sub(decimalsArr[inputIndex]));\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates the relative price between two assets in a pool\r\n     * @param pool address of a pool contract that implements ISwap\r\n     * @param inputIndex index of the input token in the pool\r\n     * @param outputIndex index of the output token in the pool\r\n     * @return price relative price of output tokens per one input token\r\n     */\r\n    function relativePrice(\r\n        address pool,\r\n        uint256 inputIndex,\r\n        uint256 outputIndex\r\n    ) external view returns (uint256 price) {\r\n        uint256[] memory decimalsArr = storedDecimals[pool];\r\n        require(decimalsArr.length > 0, \"Must call addPool() first\");\r\n\r\n        uint256[] memory balances = new uint256[](decimalsArr.length);\r\n        for (uint256 i = 0; i < decimalsArr.length; i++) {\r\n            uint256 multiplier = 10**BALANCE_DECIMALS.sub(decimalsArr[i]);\r\n            balances[i] = ISwap(pool).getTokenBalance(uint8(i)).mul(multiplier);\r\n        }\r\n\r\n        price = relativePriceCustom(\r\n            balances,\r\n            ISwap(pool).getAPrecise(),\r\n            inputIndex,\r\n            outputIndex\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the expected input amount for given balances, A, swap fee, indexes, and out amount\r\n     * @dev Uses 1e18 precision for balances, 1e2 for A, and 1e10 for swap fee\r\n     * @param balances array of balances\r\n     * @param a A parameter to be used in the calculation\r\n     * @param swapFee fee to be charged per swap\r\n     * @param inputIndex index of the input token in the pool\r\n     * @param outputIndex index of the output token in the pool\r\n     * @param inputAmount amount of input token to swap\r\n     * @return outputAmount expected output amount\r\n     */\r\n    function calculateSwapOutputCustom(\r\n        uint256[] memory balances,\r\n        uint256 a,\r\n        uint256 swapFee,\r\n        uint256 inputIndex,\r\n        uint256 outputIndex,\r\n        uint256 inputAmount\r\n    ) public pure returns (uint256 outputAmount) {\r\n        require(\r\n            inputIndex < balances.length && outputIndex < balances.length,\r\n            \"Invalid token index\"\r\n        );\r\n        // Calculate the swap\r\n        uint256 x = inputAmount.add(balances[inputIndex]);\r\n        uint256 y = getY(a, inputIndex, outputIndex, x, balances);\r\n        outputAmount = balances[outputIndex].sub(y).sub(1);\r\n\r\n        // Simulate the swap fee\r\n        uint256 fee = outputAmount.mul(swapFee).div(FEE_DENOMINATOR);\r\n        outputAmount = outputAmount.sub(fee);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the expected input amount for given balances, A, swap fee, indexes, and out amount\r\n     * @dev Uses 1e18 precision for balances, 1e2 for A, and 1e10 for swap fee\r\n     * @param balances array of balances\r\n     * @param a A parameter to be used in the calculation\r\n     * @param swapFee fee to be charged per swap\r\n     * @param inputIndex index of the input token in the pool\r\n     * @param outputIndex index of the output token in the pool\r\n     * @param outputAmount desired amount of output token to receive on swap\r\n     * @return inputAmount expected input amount\r\n     */\r\n    function calculateSwapInputCustom(\r\n        uint256[] memory balances,\r\n        uint256 a,\r\n        uint256 swapFee,\r\n        uint256 inputIndex,\r\n        uint256 outputIndex,\r\n        uint256 outputAmount\r\n    ) public pure returns (uint256 inputAmount) {\r\n        require(\r\n            inputIndex < balances.length && outputIndex < balances.length,\r\n            \"Invalid token index\"\r\n        );\r\n\r\n        // Simulate the swap fee\r\n        uint256 fee = outputAmount.mul(swapFee).div(\r\n            FEE_DENOMINATOR.sub(swapFee)\r\n        );\r\n        outputAmount = outputAmount.add(fee);\r\n\r\n        // Calculate the swap\r\n        uint256 y = balances[outputIndex].sub(outputAmount);\r\n        uint256 x = getX(a, inputIndex, outputIndex, y, balances);\r\n        inputAmount = x.sub(balances[inputIndex]).add(1);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the relative price between two assets in given setup of balances and A\r\n     * @dev Uses 1e18 precision for balances, 1e2 for A\r\n     * @param balances array of balances\r\n     * @param a A parameter to be used in the calculation\r\n     * @param inputIndex index of the input token in the pool\r\n     * @param outputIndex index of the output token in the pool\r\n     * @return price relative price of output tokens per one input token\r\n     */\r\n    function relativePriceCustom(\r\n        uint256[] memory balances,\r\n        uint256 a,\r\n        uint256 inputIndex,\r\n        uint256 outputIndex\r\n    ) public pure returns (uint256 price) {\r\n        return\r\n            calculateSwapOutputCustom(\r\n                balances,\r\n                a,\r\n                0,\r\n                inputIndex,\r\n                outputIndex,\r\n                BALANCE_PRECISION\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @notice Add and registers a new pool. This function exist to cache decimal information.\r\n     * @param pool address of a pool contract that implements ISwap\r\n     */\r\n    function addPool(address pool) external payable {\r\n        uint256[] memory decimalsArr = new uint256[](MAX_TOKENS_LENGTH);\r\n\r\n        for (uint256 i = 0; i < MAX_TOKENS_LENGTH; i++) {\r\n            try ISwap(pool).getToken(uint8(i)) returns (IERC20 token) {\r\n                require(address(token) != address(0), \"Token invalid\");\r\n                decimalsArr[i] = IERC20Decimals(address(token)).decimals();\r\n            } catch {\r\n                assembly {\r\n                    mstore(decimalsArr, sub(mload(decimalsArr), sub(8, i)))\r\n                }\r\n                break;\r\n            }\r\n        }\r\n\r\n        require(decimalsArr.length > 0, \"Must call addPool() first\");\r\n        storedDecimals[pool] = decimalsArr;\r\n    }\r\n\r\n    /**\r\n     * @notice Get D, the StableSwap invariant, based on a set of balances and a particular A.\r\n     * @param xp a precision-adjusted set of pool balances. Array should be the same cardinality\r\n     * as the pool.\r\n     * @param a the amplification coefficient * n * (n - 1) in A_PRECISION.\r\n     * See the StableSwap paper for details\r\n     * @return the invariant, at the precision of the pool\r\n     */\r\n    function getD(uint256[] memory xp, uint256 a)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 numTokens = xp.length;\r\n        uint256 s;\r\n        for (uint256 i = 0; i < numTokens; i++) {\r\n            s = s.add(xp[i]);\r\n        }\r\n        if (s == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 prevD;\r\n        uint256 d = s;\r\n        uint256 nA = a.mul(numTokens);\r\n\r\n        for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {\r\n            uint256 dP = d;\r\n            for (uint256 j = 0; j < numTokens; j++) {\r\n                dP = dP.mul(d).div(xp[j].mul(numTokens));\r\n                // If we were to protect the division loss we would have to keep the denominator separate\r\n                // and divide at the end. However this leads to overflow with large numTokens or/and D.\r\n                // dP = dP * D * D * D * ... overflow!\r\n            }\r\n            prevD = d;\r\n            d = nA.mul(s).div(A_PRECISION).add(dP.mul(numTokens)).mul(d).div(\r\n                nA.sub(A_PRECISION).mul(d).div(A_PRECISION).add(\r\n                    numTokens.add(1).mul(dP)\r\n                )\r\n            );\r\n            if (d.within1(prevD)) {\r\n                return d;\r\n            }\r\n        }\r\n\r\n        // Convergence should occur in 4 loops or less. If this is reached, there may be something wrong\r\n        // with the pool. If this were to occur repeatedly, LPs should withdraw via `removeLiquidity()`\r\n        // function which does not rely on D.\r\n        revert(\"D does not converge\");\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the new balances of the tokens given the indexes of the token\r\n     * that is swapped from (FROM) and the token that is swapped to (TO).\r\n     * This function is used as a helper function to calculate how much TO token\r\n     * the user should receive on swap.\r\n     *\r\n     * @param preciseA precise form of amplification coefficient\r\n     * @param tokenIndexFrom index of FROM token\r\n     * @param tokenIndexTo index of TO token\r\n     * @param x the new total amount of FROM token\r\n     * @param xp balances of the tokens in the pool\r\n     * @return the amount of TO token that should remain in the pool\r\n     */\r\n    function getY(\r\n        uint256 preciseA,\r\n        uint256 tokenIndexFrom,\r\n        uint256 tokenIndexTo,\r\n        uint256 x,\r\n        uint256[] memory xp\r\n    ) internal pure returns (uint256) {\r\n        uint256 numTokens = xp.length;\r\n        require(\r\n            tokenIndexFrom != tokenIndexTo,\r\n            \"Can't compare token to itself\"\r\n        );\r\n        require(\r\n            tokenIndexFrom < numTokens && tokenIndexTo < numTokens,\r\n            \"Tokens must be in pool\"\r\n        );\r\n\r\n        uint256 d = getD(xp, preciseA);\r\n        uint256 c = d;\r\n        uint256 s;\r\n        uint256 nA = numTokens.mul(preciseA);\r\n\r\n        uint256 _x;\r\n        for (uint256 i = 0; i < numTokens; i++) {\r\n            if (i == tokenIndexFrom) {\r\n                _x = x;\r\n            } else if (i != tokenIndexTo) {\r\n                _x = xp[i];\r\n            } else {\r\n                continue;\r\n            }\r\n            s = s.add(_x);\r\n            c = c.mul(d).div(_x.mul(numTokens));\r\n            // If we were to protect the division loss we would have to keep the denominator separate\r\n            // and divide at the end. However this leads to overflow with large numTokens or/and D.\r\n            // c = c * D * D * D * ... overflow!\r\n        }\r\n        c = c.mul(d).mul(A_PRECISION).div(nA.mul(numTokens));\r\n        uint256 b = s.add(d.mul(A_PRECISION).div(nA));\r\n        uint256 yPrev;\r\n        uint256 y = d;\r\n\r\n        // iterative approximation\r\n        for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {\r\n            yPrev = y;\r\n            y = y.mul(y).add(c).div(y.mul(2).add(b).sub(d));\r\n            if (y.within1(yPrev)) {\r\n                return y;\r\n            }\r\n        }\r\n        revert(\"Approximation did not converge\");\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the new balances of the tokens given the indexes of the token\r\n     * that is swapped from (FROM) and the token that is swapped to (TO).\r\n     * This function is used as a helper function to calculate how much FROM token\r\n     * the user will be required to transfer on swap.\r\n     *\r\n     * @param preciseA precise form of amplification coefficient\r\n     * @param tokenIndexFrom index of FROM token\r\n     * @param tokenIndexTo index of TO token\r\n     * @param y the new total amount of TO token\r\n     * @param xp balances of the tokens in the pool\r\n     * @return the amount of FROM token that will be required\r\n     */\r\n    function getX(\r\n        uint256 preciseA,\r\n        uint256 tokenIndexFrom,\r\n        uint256 tokenIndexTo,\r\n        uint256 y,\r\n        uint256[] memory xp\r\n    ) internal pure returns (uint256) {\r\n        return getY(preciseA, tokenIndexTo, tokenIndexFrom, y, xp);\r\n    }\r\n}\r\n"
    },
    "contracts/helper/FlashLoanBorrowerExample.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\r\nimport \"../interfaces/IFlashLoanReceiver.sol\";\r\nimport \"../interfaces/ISwapFlashLoan.sol\";\r\nimport \"hardhat/console.sol\";\r\n\r\ncontract FlashLoanBorrowerExample is IFlashLoanReceiver {\r\n    using SafeMath for uint256;\r\n\r\n    // Typical executeOperation function should do the 3 following actions\r\n    // 1. Check if the flashLoan was successful\r\n    // 2. Do actions with the borrowed tokens\r\n    // 3. Repay the debt to the `pool`\r\n    function executeOperation(\r\n        address pool,\r\n        address token,\r\n        uint256 amount,\r\n        uint256 fee,\r\n        bytes calldata params\r\n    ) external override {\r\n        // 1. Check if the flashLoan was valid\r\n        require(\r\n            IERC20(token).balanceOf(address(this)) >= amount,\r\n            \"flashloan is broken?\"\r\n        );\r\n\r\n        // 2. Do actions with the borrowed token\r\n        bytes32 paramsHash = keccak256(params);\r\n        if (paramsHash == keccak256(bytes(\"dontRepayDebt\"))) {\r\n            return;\r\n        } else if (paramsHash == keccak256(bytes(\"reentrancy_addLiquidity\"))) {\r\n            ISwapFlashLoan(pool).addLiquidity(\r\n                new uint256[](0),\r\n                0,\r\n                block.timestamp\r\n            );\r\n        } else if (paramsHash == keccak256(bytes(\"reentrancy_swap\"))) {\r\n            ISwapFlashLoan(pool).swap(1, 0, 1e6, 0, now);\r\n        } else if (\r\n            paramsHash == keccak256(bytes(\"reentrancy_removeLiquidity\"))\r\n        ) {\r\n            ISwapFlashLoan(pool).removeLiquidity(1e18, new uint256[](0), now);\r\n        } else if (\r\n            paramsHash == keccak256(bytes(\"reentrancy_removeLiquidityOneToken\"))\r\n        ) {\r\n            ISwapFlashLoan(pool).removeLiquidityOneToken(1e18, 0, 1e18, now);\r\n        }\r\n\r\n        // 3. Payback debt\r\n        uint256 totalDebt = amount.add(fee);\r\n        IERC20(token).transfer(pool, totalDebt);\r\n    }\r\n\r\n    function flashLoan(\r\n        ISwapFlashLoan swap,\r\n        IERC20 token,\r\n        uint256 amount,\r\n        bytes memory params\r\n    ) external {\r\n        swap.flashLoan(address(this), token, amount, params);\r\n    }\r\n}\r\n"
    },
    "contracts/interfaces/ISwapFlashLoan.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"./ISwap.sol\";\r\n\r\ninterface ISwapFlashLoan is ISwap {\r\n    function flashLoan(\r\n        address receiver,\r\n        IERC20 token,\r\n        uint256 amount,\r\n        bytes memory params\r\n    ) external;\r\n}\r\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "contracts/helper/test/TestSwapReturnValues.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"../../interfaces/ISwap.sol\";\r\nimport \"hardhat/console.sol\";\r\n\r\ncontract TestSwapReturnValues {\r\n    using SafeMath for uint256;\r\n\r\n    ISwap public swap;\r\n    IERC20 public lpToken;\r\n    uint8 public n;\r\n\r\n    uint256 public constant MAX_INT = 2**256 - 1;\r\n\r\n    constructor(\r\n        ISwap swapContract,\r\n        IERC20 lpTokenContract,\r\n        uint8 numOfTokens\r\n    ) public {\r\n        swap = swapContract;\r\n        lpToken = lpTokenContract;\r\n        n = numOfTokens;\r\n\r\n        // Pre-approve tokens\r\n        for (uint8 i; i < n; i++) {\r\n            swap.getToken(i).approve(address(swap), MAX_INT);\r\n        }\r\n        lpToken.approve(address(swap), MAX_INT);\r\n    }\r\n\r\n    function test_swap(\r\n        uint8 tokenIndexFrom,\r\n        uint8 tokenIndexTo,\r\n        uint256 dx,\r\n        uint256 minDy\r\n    ) public {\r\n        uint256 balanceBefore = swap.getToken(tokenIndexTo).balanceOf(\r\n            address(this)\r\n        );\r\n        uint256 returnValue = swap.swap(\r\n            tokenIndexFrom,\r\n            tokenIndexTo,\r\n            dx,\r\n            minDy,\r\n            block.timestamp\r\n        );\r\n        uint256 balanceAfter = swap.getToken(tokenIndexTo).balanceOf(\r\n            address(this)\r\n        );\r\n\r\n        console.log(\r\n            \"swap: Expected %s, got %s\",\r\n            balanceAfter.sub(balanceBefore),\r\n            returnValue\r\n        );\r\n\r\n        require(\r\n            returnValue == balanceAfter.sub(balanceBefore),\r\n            \"swap()'s return value does not match received amount\"\r\n        );\r\n    }\r\n\r\n    function test_addLiquidity(uint256[] calldata amounts, uint256 minToMint)\r\n        public\r\n    {\r\n        uint256 balanceBefore = lpToken.balanceOf(address(this));\r\n        uint256 returnValue = swap.addLiquidity(amounts, minToMint, MAX_INT);\r\n        uint256 balanceAfter = lpToken.balanceOf(address(this));\r\n\r\n        console.log(\r\n            \"addLiquidity: Expected %s, got %s\",\r\n            balanceAfter.sub(balanceBefore),\r\n            returnValue\r\n        );\r\n\r\n        require(\r\n            returnValue == balanceAfter.sub(balanceBefore),\r\n            \"addLiquidity()'s return value does not match minted amount\"\r\n        );\r\n    }\r\n\r\n    function test_removeLiquidity(uint256 amount, uint256[] memory minAmounts)\r\n        public\r\n    {\r\n        uint256[] memory balanceBefore = new uint256[](n);\r\n        uint256[] memory balanceAfter = new uint256[](n);\r\n\r\n        for (uint8 i = 0; i < n; i++) {\r\n            balanceBefore[i] = swap.getToken(i).balanceOf(address(this));\r\n        }\r\n\r\n        uint256[] memory returnValue = swap.removeLiquidity(\r\n            amount,\r\n            minAmounts,\r\n            MAX_INT\r\n        );\r\n\r\n        for (uint8 i = 0; i < n; i++) {\r\n            balanceAfter[i] = swap.getToken(i).balanceOf(address(this));\r\n            console.log(\r\n                \"removeLiquidity: Expected %s, got %s\",\r\n                balanceAfter[i].sub(balanceBefore[i]),\r\n                returnValue[i]\r\n            );\r\n            require(\r\n                balanceAfter[i].sub(balanceBefore[i]) == returnValue[i],\r\n                \"removeLiquidity()'s return value does not match received amounts of tokens\"\r\n            );\r\n        }\r\n    }\r\n\r\n    function test_removeLiquidityImbalance(\r\n        uint256[] calldata amounts,\r\n        uint256 maxBurnAmount\r\n    ) public {\r\n        uint256 balanceBefore = lpToken.balanceOf(address(this));\r\n        uint256 returnValue = swap.removeLiquidityImbalance(\r\n            amounts,\r\n            maxBurnAmount,\r\n            MAX_INT\r\n        );\r\n        uint256 balanceAfter = lpToken.balanceOf(address(this));\r\n\r\n        console.log(\r\n            \"removeLiquidityImbalance: Expected %s, got %s\",\r\n            balanceBefore.sub(balanceAfter),\r\n            returnValue\r\n        );\r\n\r\n        require(\r\n            returnValue == balanceBefore.sub(balanceAfter),\r\n            \"removeLiquidityImbalance()'s return value does not match burned lpToken amount\"\r\n        );\r\n    }\r\n\r\n    function test_removeLiquidityOneToken(\r\n        uint256 tokenAmount,\r\n        uint8 tokenIndex,\r\n        uint256 minAmount\r\n    ) public {\r\n        uint256 balanceBefore = swap.getToken(tokenIndex).balanceOf(\r\n            address(this)\r\n        );\r\n        uint256 returnValue = swap.removeLiquidityOneToken(\r\n            tokenAmount,\r\n            tokenIndex,\r\n            minAmount,\r\n            MAX_INT\r\n        );\r\n        uint256 balanceAfter = swap.getToken(tokenIndex).balanceOf(\r\n            address(this)\r\n        );\r\n\r\n        console.log(\r\n            \"removeLiquidityOneToken: Expected %s, got %s\",\r\n            balanceAfter.sub(balanceBefore),\r\n            returnValue\r\n        );\r\n\r\n        require(\r\n            returnValue == balanceAfter.sub(balanceBefore),\r\n            \"removeLiquidityOneToken()'s return value does not match received token amount\"\r\n        );\r\n    }\r\n}\r\n"
    },
    "contracts/helper/GenericERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\n/**\r\n * @title Generic ERC20 token\r\n * @notice This contract simulates a generic ERC20 token that is mintable and burnable.\r\n */\r\ncontract GenericERC20 is ERC20, Ownable {\r\n    /**\r\n     * @notice Deploy this contract with given name, symbol, and decimals\r\n     * @dev the caller of this constructor will become the owner of this contract\r\n     * @param name_ name of this token\r\n     * @param symbol_ symbol of this token\r\n     * @param decimals_ number of decimals this token will be based on\r\n     */\r\n    constructor(\r\n        string memory name_,\r\n        string memory symbol_,\r\n        uint8 decimals_\r\n    ) public ERC20(name_, symbol_) {\r\n        _setupDecimals(decimals_);\r\n    }\r\n\r\n    /**\r\n     * @notice Mints given amount of tokens to recipient\r\n     * @dev only owner can call this mint function\r\n     * @param recipient address of account to receive the tokens\r\n     * @param amount amount of tokens to mint\r\n     */\r\n    function mint(address recipient, uint256 amount) external onlyOwner {\r\n        require(amount != 0, \"amount == 0\");\r\n        _mint(recipient, amount);\r\n    }\r\n}\r\n"
    },
    "contracts/GeneralizedSwapMigrator.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"./interfaces/ISwap.sol\";\r\nimport \"./helper/BaseBoringBatchable.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\n/**\r\n * @title GeneralizedSwapMigrator\r\n * @notice This contract is responsible for migration liquidity between pools\r\n * Users can use this contract to remove their liquidity from the old pools and add them to the new\r\n * ones with a single transaction.\r\n */\r\ncontract GeneralizedSwapMigrator is Ownable, BaseBoringBatchable {\r\n    using SafeERC20 for IERC20;\r\n\r\n    struct MigrationData {\r\n        address newPoolAddress;\r\n        IERC20 oldPoolLPTokenAddress;\r\n        IERC20 newPoolLPTokenAddress;\r\n        IERC20[] tokens;\r\n    }\r\n\r\n    uint256 private constant MAX_UINT256 = 2**256 - 1;\r\n    mapping(address => MigrationData) public migrationMap;\r\n\r\n    event AddMigrationData(address indexed oldPoolAddress, MigrationData mData);\r\n    event Migrate(\r\n        address indexed migrator,\r\n        address indexed oldPoolAddress,\r\n        uint256 oldLPTokenAmount,\r\n        uint256 newLPTokenAmount\r\n    );\r\n\r\n    constructor() public Ownable() {}\r\n\r\n    /**\r\n     * @notice Add new migration data to the contract\r\n     * @param oldPoolAddress pool address to migrate from\r\n     * @param mData MigrationData struct that contains information of the old and new pools\r\n     * @param overwrite should overwrite existing migration data\r\n     */\r\n    function addMigrationData(\r\n        address oldPoolAddress,\r\n        MigrationData memory mData,\r\n        bool overwrite\r\n    ) external onlyOwner {\r\n        // Check\r\n        if (!overwrite) {\r\n            require(\r\n                address(migrationMap[oldPoolAddress].oldPoolLPTokenAddress) ==\r\n                    address(0),\r\n                \"cannot overwrite existing migration data\"\r\n            );\r\n        }\r\n        require(\r\n            address(mData.oldPoolLPTokenAddress) != address(0),\r\n            \"oldPoolLPTokenAddress == 0\"\r\n        );\r\n        require(\r\n            address(mData.newPoolLPTokenAddress) != address(0),\r\n            \"newPoolLPTokenAddress == 0\"\r\n        );\r\n\r\n        for (uint8 i = 0; i < 32; i++) {\r\n            address oldPoolToken;\r\n            try ISwap(oldPoolAddress).getToken(i) returns (IERC20 token) {\r\n                oldPoolToken = address(token);\r\n            } catch {\r\n                require(i > 0, \"Failed to get tokens underlying kinesis pool.\");\r\n                oldPoolToken = address(0);\r\n            }\r\n\r\n            try ISwap(mData.newPoolAddress).getToken(i) returns (IERC20 token) {\r\n                require(\r\n                    oldPoolToken == address(token) &&\r\n                        oldPoolToken == address(mData.tokens[i]),\r\n                    \"Failed to match tokens list\"\r\n                );\r\n            } catch {\r\n                require(i > 0, \"Failed to get tokens underlying kinesis pool.\");\r\n                require(\r\n                    oldPoolToken == address(0) && i == mData.tokens.length,\r\n                    \"Failed to match tokens list\"\r\n                );\r\n                break;\r\n            }\r\n        }\r\n\r\n        // Effect\r\n        migrationMap[oldPoolAddress] = mData;\r\n\r\n        // Interaction\r\n        // Approve old LP Token to be used for withdraws.\r\n        mData.oldPoolLPTokenAddress.approve(oldPoolAddress, MAX_UINT256);\r\n\r\n        // Approve underlying tokens to be used for deposits.\r\n        for (uint256 i = 0; i < mData.tokens.length; i++) {\r\n            mData.tokens[i].safeApprove(mData.newPoolAddress, 0);\r\n            mData.tokens[i].safeApprove(mData.newPoolAddress, MAX_UINT256);\r\n        }\r\n\r\n        emit AddMigrationData(oldPoolAddress, mData);\r\n    }\r\n\r\n    /**\r\n     * @notice Migrates kinesis LP tokens from a pool to another\r\n     * @param oldPoolAddress pool address to migrate from\r\n     * @param amount amount of LP tokens to migrate\r\n     * @param minAmount of new LP tokens to receive\r\n     */\r\n    function migrate(\r\n        address oldPoolAddress,\r\n        uint256 amount,\r\n        uint256 minAmount\r\n    ) external returns (uint256) {\r\n        // Check\r\n        MigrationData memory mData = migrationMap[oldPoolAddress];\r\n        require(\r\n            address(mData.oldPoolLPTokenAddress) != address(0),\r\n            \"migration is not available\"\r\n        );\r\n\r\n        // Interactions\r\n        // Transfer old LP token from the caller\r\n        mData.oldPoolLPTokenAddress.safeTransferFrom(\r\n            msg.sender,\r\n            address(this),\r\n            amount\r\n        );\r\n\r\n        // Remove liquidity from the old pool\r\n        uint256[] memory amounts = ISwap(oldPoolAddress).removeLiquidity(\r\n            amount,\r\n            new uint256[](mData.tokens.length),\r\n            MAX_UINT256\r\n        );\r\n        // Add acquired liquidity to the new pool\r\n        uint256 mintedAmount = ISwap(mData.newPoolAddress).addLiquidity(\r\n            amounts,\r\n            minAmount,\r\n            MAX_UINT256\r\n        );\r\n\r\n        // Transfer new LP Token to the caller\r\n        mData.newPoolLPTokenAddress.safeTransfer(msg.sender, mintedAmount);\r\n\r\n        emit Migrate(msg.sender, oldPoolAddress, amount, mintedAmount);\r\n        return mintedAmount;\r\n    }\r\n\r\n    /**\r\n     * @notice Rescues any token that may be sent to this contract accidentally.\r\n     * @param token Amount of old LPToken to migrate\r\n     * @param to Minimum amount of new LPToken to receive\r\n     */\r\n    function rescue(IERC20 token, address to) external onlyOwner {\r\n        token.safeTransfer(to, token.balanceOf(address(this)));\r\n    }\r\n}\r\n"
    },
    "contracts/helper/test/TestMathUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\n\r\nimport \"../../MathUtils.sol\";\r\n\r\ncontract TestMathUtils {\r\n    using MathUtils for uint256;\r\n\r\n    function difference(uint256 a, uint256 b) public pure returns (uint256) {\r\n        return a.difference(b);\r\n    }\r\n\r\n    function within1(uint256 a, uint256 b) public pure returns (bool) {\r\n        return a.within1(b);\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 10000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": ["ast"]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}
